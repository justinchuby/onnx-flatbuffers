# automatically generated by the FlatBuffers compiler, do not modify
from __future__ import annotations

# namespace: onnx

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from flatbuffers.table import Table
from typing import Optional
np = import_numpy()

class Version(object):
    _START_VERSION = 0
    IR_VERSION_2017_10_10 = 1
    IR_VERSION_2017_10_30 = 2
    IR_VERSION_2017_11_3 = 3
    IR_VERSION_2019_1_22 = 4
    IR_VERSION_2019_3_18 = 5
    IR_VERSION_2019_9_19 = 6
    IR_VERSION_2020_5_8 = 7
    IR_VERSION_2021_7_30 = 8
    IR_VERSION_2023_5_5 = 9
    IR_VERSION_2024_3_25 = 10
    IR_VERSION_2025_05_12 = 11
    IR_VERSION = 12


class AttributeType(object):
    UNDEFINED = 0
    FLOAT = 1
    INT = 2
    STRING = 3
    TENSOR = 4
    GRAPH = 5
    FLOATS = 6
    INTS = 7
    STRINGS = 8
    TENSORS = 9
    GRAPHS = 10
    SPARSE_TENSOR = 11
    SPARSE_TENSORS = 12
    TYPE_PROTO = 13
    TYPE_PROTOS = 14


class DataType(object):
    UNDEFINED = 0
    FLOAT = 1
    UINT8 = 2
    INT8 = 3
    UINT16 = 4
    INT16 = 5
    INT32 = 6
    INT64 = 7
    STRING = 8
    BOOL = 9
    FLOAT16 = 10
    DOUBLE = 11
    UINT32 = 12
    UINT64 = 13
    COMPLEX64 = 14
    COMPLEX128 = 15
    BFLOAT16 = 16
    FLOAT8E4M3FN = 17
    FLOAT8E4M3FNUZ = 18
    FLOAT8E5M2 = 19
    FLOAT8E5M2FNUZ = 20
    UINT4 = 21
    INT4 = 22
    FLOAT4E2M1 = 23
    FLOAT8E8M0 = 24


class TensorDataLocation(object):
    DEFAULT = 0
    EXTERNAL = 1


class OperatorStatus(object):
    EXPERIMENTAL = 0
    STABLE = 1


class DimensionValueType(object):
    UNKNOWN = 0
    VALUE = 1
    PARAM = 2


class ValueType(object):
    NONE = 0
    tensor_type = 1
    sequence_type = 2
    map_type = 3
    optional_type = 4
    sparse_tensor_type = 5


class Attribute(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Attribute()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAttribute(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Attribute
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Attribute
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def RefAttrName(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Attribute
    def F(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Attribute
    def I(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Attribute
    def S(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def T(self) -> Optional[Tensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def G(self) -> Optional[Graph]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def SparseTensor(self) -> Optional[SparseTensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = SparseTensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def Tp(self) -> Optional[TypeInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def Floats(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Attribute
    def FloatsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Attribute
    def FloatsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def FloatsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # Attribute
    def Ints(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # Attribute
    def IntsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # Attribute
    def IntsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def IntsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

    # Attribute
    def Strings(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Attribute
    def StringsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def StringsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        return o == 0

    # Attribute
    def Tensors(self, j: int) -> Optional[Tensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def TensorsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def TensorsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return o == 0

    # Attribute
    def Graphs(self, j: int) -> Optional[Graph]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def GraphsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def GraphsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        return o == 0

    # Attribute
    def SparseTensors(self, j: int) -> Optional[SparseTensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SparseTensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def SparseTensorsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def SparseTensorsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        return o == 0

    # Attribute
    def Types(self, j: int) -> Optional[TypeInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def TypesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def TypesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        return o == 0

def AttributeStart(builder: flatbuffers.Builder):
    builder.StartObject(18)

def AttributeAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AttributeAddRefAttrName(builder: flatbuffers.Builder, refAttrName: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(refAttrName), 0)

def AttributeAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def AttributeAddType(builder: flatbuffers.Builder, type: int):
    builder.PrependInt32Slot(3, type, 0)

def AttributeAddF(builder: flatbuffers.Builder, f: float):
    builder.PrependFloat32Slot(4, f, 0.0)

def AttributeAddI(builder: flatbuffers.Builder, i: int):
    builder.PrependInt64Slot(5, i, 0)

def AttributeAddS(builder: flatbuffers.Builder, s: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(s), 0)

def AttributeAddT(builder: flatbuffers.Builder, t: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(t), 0)

def AttributeAddG(builder: flatbuffers.Builder, g: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(g), 0)

def AttributeAddSparseTensor(builder: flatbuffers.Builder, sparseTensor: int):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(sparseTensor), 0)

def AttributeAddTp(builder: flatbuffers.Builder, tp: int):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(tp), 0)

def AttributeAddFloats(builder: flatbuffers.Builder, floats: int):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(floats), 0)

def AttributeStartFloatsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def AttributeAddInts(builder: flatbuffers.Builder, ints: int):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(ints), 0)

def AttributeStartIntsVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def AttributeAddStrings(builder: flatbuffers.Builder, strings: int):
    builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(strings), 0)

def AttributeStartStringsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def AttributeAddTensors(builder: flatbuffers.Builder, tensors: int):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(tensors), 0)

def AttributeStartTensorsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def AttributeAddGraphs(builder: flatbuffers.Builder, graphs: int):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(graphs), 0)

def AttributeStartGraphsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def AttributeAddSparseTensors(builder: flatbuffers.Builder, sparseTensors: int):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(sparseTensors), 0)

def AttributeStartSparseTensorsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def AttributeAddTypes(builder: flatbuffers.Builder, types: int):
    builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(types), 0)

def AttributeStartTypesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def AttributeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class IntIntListEntry(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IntIntListEntry()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIntIntListEntry(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # IntIntListEntry
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IntIntListEntry
    def Key(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # IntIntListEntry
    def Value(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # IntIntListEntry
    def ValueAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # IntIntListEntry
    def ValueLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # IntIntListEntry
    def ValueIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def IntIntListEntryStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def IntIntListEntryAddKey(builder: flatbuffers.Builder, key: int):
    builder.PrependInt64Slot(0, key, 0)

def IntIntListEntryAddValue(builder: flatbuffers.Builder, value: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def IntIntListEntryStartValueVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def IntIntListEntryEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class NodeDeviceConfiguration(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = NodeDeviceConfiguration()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNodeDeviceConfiguration(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # NodeDeviceConfiguration
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # NodeDeviceConfiguration
    def ConfigurationId(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # NodeDeviceConfiguration
    def ShardingSpec(self, j: int) -> Optional[ShardingSpec]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ShardingSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # NodeDeviceConfiguration
    def ShardingSpecLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # NodeDeviceConfiguration
    def ShardingSpecIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # NodeDeviceConfiguration
    def PipelineStage(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def NodeDeviceConfigurationStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def NodeDeviceConfigurationAddConfigurationId(builder: flatbuffers.Builder, configurationId: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(configurationId), 0)

def NodeDeviceConfigurationAddShardingSpec(builder: flatbuffers.Builder, shardingSpec: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(shardingSpec), 0)

def NodeDeviceConfigurationStartShardingSpecVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def NodeDeviceConfigurationAddPipelineStage(builder: flatbuffers.Builder, pipelineStage: int):
    builder.PrependInt32Slot(2, pipelineStage, 0)

def NodeDeviceConfigurationEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class ShardingSpec(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ShardingSpec()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsShardingSpec(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # ShardingSpec
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ShardingSpec
    def TensorName(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ShardingSpec
    def Device(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # ShardingSpec
    def DeviceAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # ShardingSpec
    def DeviceLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ShardingSpec
    def DeviceIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # ShardingSpec
    def IndexToDeviceGroupMap(self, j: int) -> Optional[IntIntListEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = IntIntListEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ShardingSpec
    def IndexToDeviceGroupMapLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ShardingSpec
    def IndexToDeviceGroupMapIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # ShardingSpec
    def ShardedDim(self, j: int) -> Optional[ShardedDim]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ShardedDim()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ShardingSpec
    def ShardedDimLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ShardingSpec
    def ShardedDimIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ShardingSpecStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def ShardingSpecAddTensorName(builder: flatbuffers.Builder, tensorName: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(tensorName), 0)

def ShardingSpecAddDevice(builder: flatbuffers.Builder, device: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(device), 0)

def ShardingSpecStartDeviceVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def ShardingSpecAddIndexToDeviceGroupMap(builder: flatbuffers.Builder, indexToDeviceGroupMap: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(indexToDeviceGroupMap), 0)

def ShardingSpecStartIndexToDeviceGroupMapVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ShardingSpecAddShardedDim(builder: flatbuffers.Builder, shardedDim: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(shardedDim), 0)

def ShardingSpecStartShardedDimVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ShardingSpecEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class ShardedDim(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ShardedDim()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsShardedDim(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # ShardedDim
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ShardedDim
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # ShardedDim
    def SimpleSharding(self, j: int) -> Optional[SimpleShardedDim]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SimpleShardedDim()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ShardedDim
    def SimpleShardingLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ShardedDim
    def SimpleShardingIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def ShardedDimStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def ShardedDimAddAxis(builder: flatbuffers.Builder, axis: int):
    builder.PrependInt64Slot(0, axis, 0)

def ShardedDimAddSimpleSharding(builder: flatbuffers.Builder, simpleSharding: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(simpleSharding), 0)

def ShardedDimStartSimpleShardingVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ShardedDimEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class SimpleShardedDim(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SimpleShardedDim()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSimpleShardedDim(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SimpleShardedDim
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SimpleShardedDim
    def Dim(self) -> Optional[DimensionValue]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = DimensionValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SimpleShardedDim
    def NumShards(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

def SimpleShardedDimStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def SimpleShardedDimAddDim(builder: flatbuffers.Builder, dim: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(dim), 0)

def SimpleShardedDimAddNumShards(builder: flatbuffers.Builder, numShards: int):
    builder.PrependInt64Slot(1, numShards, 0)

def SimpleShardedDimEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class TrainingInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TrainingInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTrainingInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TrainingInfo
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TrainingInfo
    def Initialization(self) -> Optional[Graph]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TrainingInfo
    def Algorithm(self) -> Optional[Graph]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TrainingInfo
    def InitializationBinding(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TrainingInfo
    def InitializationBindingLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TrainingInfo
    def InitializationBindingIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # TrainingInfo
    def UpdateBinding(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TrainingInfo
    def UpdateBindingLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TrainingInfo
    def UpdateBindingIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def TrainingInfoStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def TrainingInfoAddInitialization(builder: flatbuffers.Builder, initialization: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(initialization), 0)

def TrainingInfoAddAlgorithm(builder: flatbuffers.Builder, algorithm: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(algorithm), 0)

def TrainingInfoAddInitializationBinding(builder: flatbuffers.Builder, initializationBinding: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(initializationBinding), 0)

def TrainingInfoStartInitializationBindingVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TrainingInfoAddUpdateBinding(builder: flatbuffers.Builder, updateBinding: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(updateBinding), 0)

def TrainingInfoStartUpdateBindingVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TrainingInfoEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class DeviceConfiguration(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DeviceConfiguration()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDeviceConfiguration(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # DeviceConfiguration
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DeviceConfiguration
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # DeviceConfiguration
    def NumDevices(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # DeviceConfiguration
    def Device(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # DeviceConfiguration
    def DeviceLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # DeviceConfiguration
    def DeviceIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def DeviceConfigurationStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def DeviceConfigurationAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def DeviceConfigurationAddNumDevices(builder: flatbuffers.Builder, numDevices: int):
    builder.PrependInt32Slot(1, numDevices, 0)

def DeviceConfigurationAddDevice(builder: flatbuffers.Builder, device: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(device), 0)

def DeviceConfigurationStartDeviceVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def DeviceConfigurationEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class StringStringEntry(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = StringStringEntry()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsStringStringEntry(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # StringStringEntry
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # StringStringEntry
    def Key(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # StringStringEntry
    def Value(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def StringStringEntryStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def StringStringEntryAddKey(builder: flatbuffers.Builder, key: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0)

def StringStringEntryAddValue(builder: flatbuffers.Builder, value: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def StringStringEntryEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class TensorAnnotation(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TensorAnnotation()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensorAnnotation(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TensorAnnotation
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TensorAnnotation
    def TensorName(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # TensorAnnotation
    def QuantParameterTensorNames(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # TensorAnnotation
    def QuantParameterTensorNamesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TensorAnnotation
    def QuantParameterTensorNamesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def TensorAnnotationStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def TensorAnnotationAddTensorName(builder: flatbuffers.Builder, tensorName: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(tensorName), 0)

def TensorAnnotationAddQuantParameterTensorNames(builder: flatbuffers.Builder, quantParameterTensorNames: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(quantParameterTensorNames), 0)

def TensorAnnotationStartQuantParameterTensorNamesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TensorAnnotationEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Tensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Tensor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Tensor
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Tensor
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Tensor
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Tensor
    def Dims(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # Tensor
    def DimsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # Tensor
    def DimsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def DimsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Tensor
    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def RawData(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Tensor
    def RawDataAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Tensor
    def RawDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def RawDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Tensor
    def StringData(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Tensor
    def StringDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def StringDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Tensor
    def ExternalData(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Tensor
    def ExternalDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def ExternalDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Tensor
    def DataLocation(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def MetadataProps(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Tensor
    def MetadataPropsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def MetadataPropsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

def TensorStart(builder: flatbuffers.Builder):
    builder.StartObject(9)

def TensorAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def TensorAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def TensorAddDims(builder: flatbuffers.Builder, dims: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(dims), 0)

def TensorStartDimsVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def TensorAddDataType(builder: flatbuffers.Builder, dataType: int):
    builder.PrependInt32Slot(3, dataType, 0)

def TensorAddRawData(builder: flatbuffers.Builder, rawData: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(rawData), 0)

def TensorStartRawDataVector(builder, numElems: int) -> int:
    return builder.StartVector(1, numElems, 1)

def TensorAddStringData(builder: flatbuffers.Builder, stringData: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(stringData), 0)

def TensorStartStringDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TensorAddExternalData(builder: flatbuffers.Builder, externalData: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(externalData), 0)

def TensorStartExternalDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TensorAddDataLocation(builder: flatbuffers.Builder, dataLocation: int):
    builder.PrependUint8Slot(7, dataLocation, 0)

def TensorAddMetadataProps(builder: flatbuffers.Builder, metadataProps: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(metadataProps), 0)

def TensorStartMetadataPropsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TensorEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class TensorSegment(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TensorSegment()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensorSegment(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TensorSegment
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TensorSegment
    def Begin(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # TensorSegment
    def End(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

def TensorSegmentStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def TensorSegmentAddBegin(builder: flatbuffers.Builder, begin: int):
    builder.PrependInt64Slot(0, begin, 0)

def TensorSegmentAddEnd(builder: flatbuffers.Builder, end: int):
    builder.PrependInt64Slot(1, end, 0)

def TensorSegmentEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class SparseTensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseTensor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSparseTensor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SparseTensor
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SparseTensor
    def Values(self) -> Optional[Tensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensor
    def Indices(self) -> Optional[Tensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SparseTensor
    def Dims(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # SparseTensor
    def DimsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # SparseTensor
    def DimsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SparseTensor
    def DimsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def SparseTensorStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def SparseTensorAddValues(builder: flatbuffers.Builder, values: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0)

def SparseTensorAddIndices(builder: flatbuffers.Builder, indices: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indices), 0)

def SparseTensorAddDims(builder: flatbuffers.Builder, dims: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(dims), 0)

def SparseTensorStartDimsVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def SparseTensorEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Shape(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Shape()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsShape(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Shape
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Shape
    def Dim(self, j: int) -> Optional[Dimension]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Dimension()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Shape
    def DimLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Shape
    def DimIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def ShapeStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def ShapeAddDim(builder: flatbuffers.Builder, dim: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(dim), 0)

def ShapeStartDimVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ShapeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Dimension(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Dimension()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDimension(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Dimension
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dimension
    def Value(self) -> Optional[DimensionValue]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = DimensionValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Dimension
    def Denotation(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def DimensionStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def DimensionAddValue(builder: flatbuffers.Builder, value: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def DimensionAddDenotation(builder: flatbuffers.Builder, denotation: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(denotation), 0)

def DimensionEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class DimensionValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DimensionValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDimensionValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # DimensionValue
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DimensionValue
    def DimType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # DimensionValue
    def DimValue(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # DimensionValue
    def DimParam(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def DimensionValueStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def DimensionValueAddDimType(builder: flatbuffers.Builder, dimType: int):
    builder.PrependInt8Slot(0, dimType, 0)

def DimensionValueAddDimValue(builder: flatbuffers.Builder, dimValue: int):
    builder.PrependInt64Slot(1, dimValue, 0)

def DimensionValueAddDimParam(builder: flatbuffers.Builder, dimParam: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(dimParam), 0)

def DimensionValueEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class TypeInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TypeInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTypeInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TypeInfo
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TypeInfo
    def ValueType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # TypeInfo
    def Value(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # TypeInfo
    def Denotation(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def TypeInfoStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def TypeInfoAddValueType(builder: flatbuffers.Builder, valueType: int):
    builder.PrependUint8Slot(0, valueType, 0)

def TypeInfoAddValue(builder: flatbuffers.Builder, value: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def TypeInfoAddDenotation(builder: flatbuffers.Builder, denotation: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(denotation), 0)

def TypeInfoEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class TensorType(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TensorType()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensorType(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TensorType
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TensorType
    def ElemType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # TensorType
    def Shape(self) -> Optional[Shape]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Shape()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def TensorTypeStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def TensorTypeAddElemType(builder: flatbuffers.Builder, elemType: int):
    builder.PrependInt32Slot(0, elemType, 0)

def TensorTypeAddShape(builder: flatbuffers.Builder, shape: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

def TensorTypeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class SequenceType(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SequenceType()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSequenceType(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SequenceType
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SequenceType
    def ElemTypeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # SequenceType
    def ElemType(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def SequenceTypeStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def SequenceTypeAddElemTypeType(builder: flatbuffers.Builder, elemTypeType: int):
    builder.PrependUint8Slot(0, elemTypeType, 0)

def SequenceTypeAddElemType(builder: flatbuffers.Builder, elemType: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(elemType), 0)

def SequenceTypeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class MapType(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MapType()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMapType(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MapType
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MapType
    def KeyType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # MapType
    def ValueTypeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # MapType
    def ValueType(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def MapTypeStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def MapTypeAddKeyType(builder: flatbuffers.Builder, keyType: int):
    builder.PrependInt32Slot(0, keyType, 0)

def MapTypeAddValueTypeType(builder: flatbuffers.Builder, valueTypeType: int):
    builder.PrependUint8Slot(1, valueTypeType, 0)

def MapTypeAddValueType(builder: flatbuffers.Builder, valueType: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(valueType), 0)

def MapTypeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class OptionalType(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OptionalType()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOptionalType(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # OptionalType
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OptionalType
    def ElemTypeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # OptionalType
    def ElemType(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def OptionalTypeStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def OptionalTypeAddElemTypeType(builder: flatbuffers.Builder, elemTypeType: int):
    builder.PrependUint8Slot(0, elemTypeType, 0)

def OptionalTypeAddElemType(builder: flatbuffers.Builder, elemType: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(elemType), 0)

def OptionalTypeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class SparseTensorType(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SparseTensorType()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSparseTensorType(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SparseTensorType
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SparseTensorType
    def ElemType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # SparseTensorType
    def Shape(self) -> Optional[Shape]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Shape()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def SparseTensorTypeStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def SparseTensorTypeAddElemType(builder: flatbuffers.Builder, elemType: int):
    builder.PrependInt32Slot(0, elemType, 0)

def SparseTensorTypeAddShape(builder: flatbuffers.Builder, shape: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

def SparseTensorTypeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class OperatorSetId(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OperatorSetId()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOperatorSetId(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # OperatorSetId
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OperatorSetId
    def Domain(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # OperatorSetId
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

def OperatorSetIdStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def OperatorSetIdAddDomain(builder: flatbuffers.Builder, domain: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(domain), 0)

def OperatorSetIdAddVersion(builder: flatbuffers.Builder, version: int):
    builder.PrependInt64Slot(1, version, 0)

def OperatorSetIdEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class ValueInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ValueInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsValueInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # ValueInfo
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ValueInfo
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ValueInfo
    def Type(self) -> Optional[TypeInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ValueInfo
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ValueInfo
    def MetadataProps(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ValueInfo
    def MetadataPropsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ValueInfo
    def MetadataPropsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ValueInfoStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def ValueInfoAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def ValueInfoAddType(builder: flatbuffers.Builder, type: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)

def ValueInfoAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def ValueInfoAddMetadataProps(builder: flatbuffers.Builder, metadataProps: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(metadataProps), 0)

def ValueInfoStartMetadataPropsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ValueInfoEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Node(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Node()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Node
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Node
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def OpType(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def Domain(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def Overload(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def Input(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Node
    def InputLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def InputIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Node
    def Output(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Node
    def OutputLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def OutputIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Node
    def Attribute(self, j: int) -> Optional[Attribute]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Attribute()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Node
    def AttributeLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def AttributeIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Node
    def DeviceConfigurations(self, j: int) -> Optional[NodeDeviceConfiguration]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = NodeDeviceConfiguration()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Node
    def DeviceConfigurationsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def DeviceConfigurationsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Node
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def MetadataProps(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Node
    def MetadataPropsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def MetadataPropsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

def NodeStart(builder: flatbuffers.Builder):
    builder.StartObject(10)

def NodeAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def NodeAddOpType(builder: flatbuffers.Builder, opType: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(opType), 0)

def NodeAddDomain(builder: flatbuffers.Builder, domain: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(domain), 0)

def NodeAddOverload(builder: flatbuffers.Builder, overload: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(overload), 0)

def NodeAddInput(builder: flatbuffers.Builder, input: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(input), 0)

def NodeStartInputVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def NodeAddOutput(builder: flatbuffers.Builder, output: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(output), 0)

def NodeStartOutputVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def NodeAddAttribute(builder: flatbuffers.Builder, attribute: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(attribute), 0)

def NodeStartAttributeVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def NodeAddDeviceConfigurations(builder: flatbuffers.Builder, deviceConfigurations: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(deviceConfigurations), 0)

def NodeStartDeviceConfigurationsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def NodeAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def NodeAddMetadataProps(builder: flatbuffers.Builder, metadataProps: int):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(metadataProps), 0)

def NodeStartMetadataPropsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def NodeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Graph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Graph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Graph
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Graph
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Graph
    def Node(self, j: int) -> Optional[Node]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Node()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def NodeLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def NodeIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Graph
    def Initializer(self, j: int) -> Optional[Tensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def InitializerLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def InitializerIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Graph
    def SparseInitializer(self, j: int) -> Optional[SparseTensor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SparseTensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def SparseInitializerLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def SparseInitializerIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Graph
    def Input(self, j: int) -> Optional[ValueInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ValueInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def InputLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def InputIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Graph
    def Output(self, j: int) -> Optional[ValueInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ValueInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def OutputLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def OutputIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Graph
    def ValueInfo(self, j: int) -> Optional[ValueInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ValueInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def ValueInfoLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def ValueInfoIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Graph
    def QuantizationAnnotation(self, j: int) -> Optional[TensorAnnotation]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = TensorAnnotation()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def QuantizationAnnotationLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def QuantizationAnnotationIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Graph
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Graph
    def MetadataProps(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def MetadataPropsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def MetadataPropsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

def GraphStart(builder: flatbuffers.Builder):
    builder.StartObject(10)

def GraphAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def GraphAddNode(builder: flatbuffers.Builder, node: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(node), 0)

def GraphStartNodeVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddInitializer(builder: flatbuffers.Builder, initializer: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(initializer), 0)

def GraphStartInitializerVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddSparseInitializer(builder: flatbuffers.Builder, sparseInitializer: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(sparseInitializer), 0)

def GraphStartSparseInitializerVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddInput(builder: flatbuffers.Builder, input: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(input), 0)

def GraphStartInputVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddOutput(builder: flatbuffers.Builder, output: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(output), 0)

def GraphStartOutputVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddValueInfo(builder: flatbuffers.Builder, valueInfo: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(valueInfo), 0)

def GraphStartValueInfoVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddQuantizationAnnotation(builder: flatbuffers.Builder, quantizationAnnotation: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(quantizationAnnotation), 0)

def GraphStartQuantizationAnnotationVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def GraphAddMetadataProps(builder: flatbuffers.Builder, metadataProps: int):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(metadataProps), 0)

def GraphStartMetadataPropsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def GraphEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Function(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Function()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFunction(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Function
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Function
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Function
    def Domain(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Function
    def Overload(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Function
    def OpsetImport(self, j: int) -> Optional[OperatorSetId]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = OperatorSetId()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Function
    def OpsetImportLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def OpsetImportIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Function
    def Input(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Function
    def InputLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def InputIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Function
    def Output(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Function
    def OutputLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def OutputIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Function
    def Attribute(self, j: int) -> Optional[Attribute]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Attribute()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Function
    def AttributeLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def AttributeIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Function
    def Node(self, j: int) -> Optional[Node]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Node()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Function
    def NodeLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def NodeIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Function
    def ValueInfo(self, j: int) -> Optional[ValueInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ValueInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Function
    def ValueInfoLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def ValueInfoIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # Function
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Function
    def MetadataProps(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Function
    def MetadataPropsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Function
    def MetadataPropsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

def FunctionStart(builder: flatbuffers.Builder):
    builder.StartObject(11)

def FunctionAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def FunctionAddDomain(builder: flatbuffers.Builder, domain: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(domain), 0)

def FunctionAddOverload(builder: flatbuffers.Builder, overload: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(overload), 0)

def FunctionAddOpsetImport(builder: flatbuffers.Builder, opsetImport: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(opsetImport), 0)

def FunctionStartOpsetImportVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionAddInput(builder: flatbuffers.Builder, input: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(input), 0)

def FunctionStartInputVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionAddOutput(builder: flatbuffers.Builder, output: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(output), 0)

def FunctionStartOutputVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionAddAttribute(builder: flatbuffers.Builder, attribute: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(attribute), 0)

def FunctionStartAttributeVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionAddNode(builder: flatbuffers.Builder, node: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(node), 0)

def FunctionStartNodeVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionAddValueInfo(builder: flatbuffers.Builder, valueInfo: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(valueInfo), 0)

def FunctionStartValueInfoVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def FunctionAddMetadataProps(builder: flatbuffers.Builder, metadataProps: int):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(metadataProps), 0)

def FunctionStartMetadataPropsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FunctionEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class Model(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Model()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsModel(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Model
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Model
    def IrVersion(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Model
    def OpsetImport(self, j: int) -> Optional[OperatorSetId]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = OperatorSetId()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def OpsetImportLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Model
    def OpsetImportIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Model
    def ProducerName(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Model
    def ProducerVersion(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Model
    def Domain(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Model
    def ModelVersion(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Model
    def Graph(self) -> Optional[Graph]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def Functions(self, j: int) -> Optional[Function]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Function()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def FunctionsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Model
    def FunctionsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Model
    def TrainingInfo(self, j: int) -> Optional[TrainingInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = TrainingInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def TrainingInfoLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Model
    def TrainingInfoIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # Model
    def Configuration(self, j: int) -> Optional[DeviceConfiguration]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = DeviceConfiguration()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def ConfigurationLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Model
    def ConfigurationIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # Model
    def DocString(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Model
    def MetadataProps(self, j: int) -> Optional[StringStringEntry]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = StringStringEntry()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def MetadataPropsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Model
    def MetadataPropsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

def ModelStart(builder: flatbuffers.Builder):
    builder.StartObject(12)

def ModelAddIrVersion(builder: flatbuffers.Builder, irVersion: int):
    builder.PrependInt64Slot(0, irVersion, 0)

def ModelAddOpsetImport(builder: flatbuffers.Builder, opsetImport: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(opsetImport), 0)

def ModelStartOpsetImportVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ModelAddProducerName(builder: flatbuffers.Builder, producerName: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(producerName), 0)

def ModelAddProducerVersion(builder: flatbuffers.Builder, producerVersion: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(producerVersion), 0)

def ModelAddDomain(builder: flatbuffers.Builder, domain: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(domain), 0)

def ModelAddModelVersion(builder: flatbuffers.Builder, modelVersion: int):
    builder.PrependInt64Slot(5, modelVersion, 0)

def ModelAddGraph(builder: flatbuffers.Builder, graph: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(graph), 0)

def ModelAddFunctions(builder: flatbuffers.Builder, functions: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(functions), 0)

def ModelStartFunctionsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ModelAddTrainingInfo(builder: flatbuffers.Builder, trainingInfo: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(trainingInfo), 0)

def ModelStartTrainingInfoVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ModelAddConfiguration(builder: flatbuffers.Builder, configuration: int):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(configuration), 0)

def ModelStartConfigurationVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ModelAddDocString(builder: flatbuffers.Builder, docString: int):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def ModelAddMetadataProps(builder: flatbuffers.Builder, metadataProps: int):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(metadataProps), 0)

def ModelStartMetadataPropsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ModelEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()
