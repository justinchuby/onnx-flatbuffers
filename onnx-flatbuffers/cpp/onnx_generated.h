// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ONNX_ONNX_H_
#define FLATBUFFERS_GENERATED_ONNX_ONNX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace onnx {

struct AttributeProto;
struct AttributeProtoBuilder;

struct ValueInfoProto;
struct ValueInfoProtoBuilder;

struct NodeProto;
struct NodeProtoBuilder;

struct TrainingInfoProto;
struct TrainingInfoProtoBuilder;

struct ModelProto;
struct ModelProtoBuilder;

struct StringStringEntryProto;
struct StringStringEntryProtoBuilder;

struct TensorAnnotation;
struct TensorAnnotationBuilder;

struct GraphProto;
struct GraphProtoBuilder;

struct TensorProto;
struct TensorProtoBuilder;

namespace TensorProto_ {

struct Segment;
struct SegmentBuilder;

}  // namespace TensorProto_

struct SparseTensorProto;
struct SparseTensorProtoBuilder;

struct TensorShapeProto;
struct TensorShapeProtoBuilder;

namespace TensorShapeProto_ {

struct Dimension;
struct DimensionBuilder;

namespace Dimension_ {

struct Anonymous0;
struct Anonymous0Builder;

}  // namespace Dimension_
}  // namespace TensorShapeProto_

struct TypeProto;
struct TypeProtoBuilder;

namespace TypeProto_ {

struct Tensor;
struct TensorBuilder;

struct Sequence;
struct SequenceBuilder;

struct Map;
struct MapBuilder;

struct Optional;
struct OptionalBuilder;

struct SparseTensor;
struct SparseTensorBuilder;

struct Anonymous1;
struct Anonymous1Builder;

}  // namespace TypeProto_

struct OperatorSetIdProto;
struct OperatorSetIdProtoBuilder;

struct FunctionProto;
struct FunctionProtoBuilder;

inline const ::flatbuffers::TypeTable *AttributeProtoTypeTable();

inline const ::flatbuffers::TypeTable *ValueInfoProtoTypeTable();

inline const ::flatbuffers::TypeTable *NodeProtoTypeTable();

inline const ::flatbuffers::TypeTable *TrainingInfoProtoTypeTable();

inline const ::flatbuffers::TypeTable *ModelProtoTypeTable();

inline const ::flatbuffers::TypeTable *StringStringEntryProtoTypeTable();

inline const ::flatbuffers::TypeTable *TensorAnnotationTypeTable();

inline const ::flatbuffers::TypeTable *GraphProtoTypeTable();

inline const ::flatbuffers::TypeTable *TensorProtoTypeTable();

namespace TensorProto_ {

inline const ::flatbuffers::TypeTable *SegmentTypeTable();

}  // namespace TensorProto_

inline const ::flatbuffers::TypeTable *SparseTensorProtoTypeTable();

inline const ::flatbuffers::TypeTable *TensorShapeProtoTypeTable();

namespace TensorShapeProto_ {

inline const ::flatbuffers::TypeTable *DimensionTypeTable();

namespace Dimension_ {

inline const ::flatbuffers::TypeTable *Anonymous0TypeTable();

}  // namespace Dimension_
}  // namespace TensorShapeProto_

inline const ::flatbuffers::TypeTable *TypeProtoTypeTable();

namespace TypeProto_ {

inline const ::flatbuffers::TypeTable *TensorTypeTable();

inline const ::flatbuffers::TypeTable *SequenceTypeTable();

inline const ::flatbuffers::TypeTable *MapTypeTable();

inline const ::flatbuffers::TypeTable *OptionalTypeTable();

inline const ::flatbuffers::TypeTable *SparseTensorTypeTable();

inline const ::flatbuffers::TypeTable *Anonymous1TypeTable();

}  // namespace TypeProto_

inline const ::flatbuffers::TypeTable *OperatorSetIdProtoTypeTable();

inline const ::flatbuffers::TypeTable *FunctionProtoTypeTable();

enum class Version : int32_t {
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION_2017_11_3 = 3,
  IR_VERSION_2019_1_22 = 4,
  IR_VERSION_2019_3_18 = 5,
  IR_VERSION_2019_9_19 = 6,
  IR_VERSION_2020_5_8 = 7,
  IR_VERSION_2021_7_30 = 8,
  IR_VERSION = 9,
  MIN = _START_VERSION,
  MAX = IR_VERSION
};

inline const Version (&EnumValuesVersion())[10] {
  static const Version values[] = {
    Version::_START_VERSION,
    Version::IR_VERSION_2017_10_10,
    Version::IR_VERSION_2017_10_30,
    Version::IR_VERSION_2017_11_3,
    Version::IR_VERSION_2019_1_22,
    Version::IR_VERSION_2019_3_18,
    Version::IR_VERSION_2019_9_19,
    Version::IR_VERSION_2020_5_8,
    Version::IR_VERSION_2021_7_30,
    Version::IR_VERSION
  };
  return values;
}

inline const char * const *EnumNamesVersion() {
  static const char * const names[11] = {
    "_START_VERSION",
    "IR_VERSION_2017_10_10",
    "IR_VERSION_2017_10_30",
    "IR_VERSION_2017_11_3",
    "IR_VERSION_2019_1_22",
    "IR_VERSION_2019_3_18",
    "IR_VERSION_2019_9_19",
    "IR_VERSION_2020_5_8",
    "IR_VERSION_2021_7_30",
    "IR_VERSION",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersion(Version e) {
  if (::flatbuffers::IsOutRange(e, Version::_START_VERSION, Version::IR_VERSION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVersion()[index];
}

namespace AttributeProto_ {

enum class AttributeType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSOR = 11,
  SPARSE_TENSORS = 12,
  TYPE_PROTO = 13,
  TYPE_PROTOS = 14,
  MIN = UNDEFINED,
  MAX = TYPE_PROTOS
};

inline const AttributeType (&EnumValuesAttributeType())[15] {
  static const AttributeType values[] = {
    AttributeType::UNDEFINED,
    AttributeType::FLOAT,
    AttributeType::INT,
    AttributeType::STRING,
    AttributeType::TENSOR,
    AttributeType::GRAPH,
    AttributeType::FLOATS,
    AttributeType::INTS,
    AttributeType::STRINGS,
    AttributeType::TENSORS,
    AttributeType::GRAPHS,
    AttributeType::SPARSE_TENSOR,
    AttributeType::SPARSE_TENSORS,
    AttributeType::TYPE_PROTO,
    AttributeType::TYPE_PROTOS
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[16] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    "TYPE_PROTO",
    "TYPE_PROTOS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType::UNDEFINED, AttributeType::TYPE_PROTOS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

}  // namespace AttributeProto_

namespace TensorProto_ {

enum class DataType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  INT32 = 6,
  INT64 = 7,
  STRING = 8,
  BOOL = 9,
  FLOAT16 = 10,
  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,
  COMPLEX128 = 15,
  BFLOAT16 = 16,
  FLOAT8E4M3FN = 17,
  FLOAT8E4M3FNUZ = 18,
  FLOAT8E5M2 = 19,
  FLOAT8E5M2FNUZ = 20,
  MIN = UNDEFINED,
  MAX = FLOAT8E5M2FNUZ
};

inline const DataType (&EnumValuesDataType())[21] {
  static const DataType values[] = {
    DataType::UNDEFINED,
    DataType::FLOAT,
    DataType::UINT8,
    DataType::INT8,
    DataType::UINT16,
    DataType::INT16,
    DataType::INT32,
    DataType::INT64,
    DataType::STRING,
    DataType::BOOL,
    DataType::FLOAT16,
    DataType::DOUBLE,
    DataType::UINT32,
    DataType::UINT64,
    DataType::COMPLEX64,
    DataType::COMPLEX128,
    DataType::BFLOAT16,
    DataType::FLOAT8E4M3FN,
    DataType::FLOAT8E4M3FNUZ,
    DataType::FLOAT8E5M2,
    DataType::FLOAT8E5M2FNUZ
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[22] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType::UNDEFINED, DataType::FLOAT8E5M2FNUZ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class DataLocation : int32_t {
  DEFAULT = 0,
  EXTERNAL = 1,
  MIN = DEFAULT,
  MAX = EXTERNAL
};

inline const DataLocation (&EnumValuesDataLocation())[2] {
  static const DataLocation values[] = {
    DataLocation::DEFAULT,
    DataLocation::EXTERNAL
  };
  return values;
}

inline const char * const *EnumNamesDataLocation() {
  static const char * const names[3] = {
    "DEFAULT",
    "EXTERNAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataLocation(DataLocation e) {
  if (::flatbuffers::IsOutRange(e, DataLocation::DEFAULT, DataLocation::EXTERNAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataLocation()[index];
}

}  // namespace TensorProto_

enum class OperatorStatus : int32_t {
  EXPERIMENTAL = 0,
  STABLE = 1,
  MIN = EXPERIMENTAL,
  MAX = STABLE
};

inline const OperatorStatus (&EnumValuesOperatorStatus())[2] {
  static const OperatorStatus values[] = {
    OperatorStatus::EXPERIMENTAL,
    OperatorStatus::STABLE
  };
  return values;
}

inline const char * const *EnumNamesOperatorStatus() {
  static const char * const names[3] = {
    "EXPERIMENTAL",
    "STABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperatorStatus(OperatorStatus e) {
  if (::flatbuffers::IsOutRange(e, OperatorStatus::EXPERIMENTAL, OperatorStatus::STABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperatorStatus()[index];
}

struct AttributeProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttributeProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.AttributeProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_REF_ATTR_NAME = 6,
    VT_DOC_STRING = 8,
    VT_TYPE = 10,
    VT_F = 12,
    VT_I = 14,
    VT_S = 16,
    VT_T = 18,
    VT_G = 20,
    VT_SPARSE_TENSOR = 22,
    VT_TP = 24,
    VT_FLOATS = 26,
    VT_INTS = 28,
    VT_STRINGS = 30,
    VT_TENSORS = 32,
    VT_GRAPHS = 34,
    VT_SPARSE_TENSORS = 36,
    VT_TYPE_PROTOS = 38
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *ref_attr_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_ATTR_NAME);
  }
  ::flatbuffers::String *mutable_ref_attr_name() {
    return GetPointer<::flatbuffers::String *>(VT_REF_ATTR_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  onnx::AttributeProto_::AttributeType type() const {
    return static_cast<onnx::AttributeProto_::AttributeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool mutate_type(onnx::AttributeProto_::AttributeType _type = static_cast<onnx::AttributeProto_::AttributeType>(0)) {
    return SetField<int32_t>(VT_TYPE, static_cast<int32_t>(_type), 0);
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  bool mutate_f(float _f = 0.0f) {
    return SetField<float>(VT_F, _f, 0.0f);
  }
  int64_t i() const {
    return GetField<int64_t>(VT_I, 0);
  }
  bool mutate_i(int64_t _i = 0) {
    return SetField<int64_t>(VT_I, _i, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *s() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_S);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_s() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_S);
  }
  const onnx::TensorProto *t() const {
    return GetPointer<const onnx::TensorProto *>(VT_T);
  }
  onnx::TensorProto *mutable_t() {
    return GetPointer<onnx::TensorProto *>(VT_T);
  }
  const onnx::GraphProto *g() const {
    return GetPointer<const onnx::GraphProto *>(VT_G);
  }
  onnx::GraphProto *mutable_g() {
    return GetPointer<onnx::GraphProto *>(VT_G);
  }
  const onnx::SparseTensorProto *sparse_tensor() const {
    return GetPointer<const onnx::SparseTensorProto *>(VT_SPARSE_TENSOR);
  }
  onnx::SparseTensorProto *mutable_sparse_tensor() {
    return GetPointer<onnx::SparseTensorProto *>(VT_SPARSE_TENSOR);
  }
  const onnx::TypeProto *tp() const {
    return GetPointer<const onnx::TypeProto *>(VT_TP);
  }
  onnx::TypeProto *mutable_tp() {
    return GetPointer<onnx::TypeProto *>(VT_TP);
  }
  const ::flatbuffers::Vector<float> *floats() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  ::flatbuffers::Vector<float> *mutable_floats() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const ::flatbuffers::Vector<int64_t> *ints() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_ints() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_strings() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *>(VT_TENSORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *mutable_tensors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::GraphProto>> *graphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::GraphProto>> *>(VT_GRAPHS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::GraphProto>> *mutable_graphs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::GraphProto>> *>(VT_GRAPHS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *sparse_tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *>(VT_SPARSE_TENSORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *mutable_sparse_tensors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *>(VT_SPARSE_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeProto>> *type_protos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeProto>> *>(VT_TYPE_PROTOS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeProto>> *mutable_type_protos() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeProto>> *>(VT_TYPE_PROTOS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REF_ATTR_NAME) &&
           verifier.VerifyString(ref_attr_name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<float>(verifier, VT_F, 4) &&
           VerifyField<int64_t>(verifier, VT_I, 8) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyVector(s()) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyTable(t()) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyTable(g()) &&
           VerifyOffset(verifier, VT_SPARSE_TENSOR) &&
           verifier.VerifyTable(sparse_tensor()) &&
           VerifyOffset(verifier, VT_TP) &&
           verifier.VerifyTable(tp()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_GRAPHS) &&
           verifier.VerifyVector(graphs()) &&
           verifier.VerifyVectorOfTables(graphs()) &&
           VerifyOffset(verifier, VT_SPARSE_TENSORS) &&
           verifier.VerifyVector(sparse_tensors()) &&
           verifier.VerifyVectorOfTables(sparse_tensors()) &&
           VerifyOffset(verifier, VT_TYPE_PROTOS) &&
           verifier.VerifyVector(type_protos()) &&
           verifier.VerifyVectorOfTables(type_protos()) &&
           verifier.EndTable();
  }
};

struct AttributeProtoBuilder {
  typedef AttributeProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AttributeProto::VT_NAME, name);
  }
  void add_ref_attr_name(::flatbuffers::Offset<::flatbuffers::String> ref_attr_name) {
    fbb_.AddOffset(AttributeProto::VT_REF_ATTR_NAME, ref_attr_name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(AttributeProto::VT_DOC_STRING, doc_string);
  }
  void add_type(onnx::AttributeProto_::AttributeType type) {
    fbb_.AddElement<int32_t>(AttributeProto::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(AttributeProto::VT_F, f, 0.0f);
  }
  void add_i(int64_t i) {
    fbb_.AddElement<int64_t>(AttributeProto::VT_I, i, 0);
  }
  void add_s(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> s) {
    fbb_.AddOffset(AttributeProto::VT_S, s);
  }
  void add_t(::flatbuffers::Offset<onnx::TensorProto> t) {
    fbb_.AddOffset(AttributeProto::VT_T, t);
  }
  void add_g(::flatbuffers::Offset<onnx::GraphProto> g) {
    fbb_.AddOffset(AttributeProto::VT_G, g);
  }
  void add_sparse_tensor(::flatbuffers::Offset<onnx::SparseTensorProto> sparse_tensor) {
    fbb_.AddOffset(AttributeProto::VT_SPARSE_TENSOR, sparse_tensor);
  }
  void add_tp(::flatbuffers::Offset<onnx::TypeProto> tp) {
    fbb_.AddOffset(AttributeProto::VT_TP, tp);
  }
  void add_floats(::flatbuffers::Offset<::flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(AttributeProto::VT_FLOATS, floats);
  }
  void add_ints(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> ints) {
    fbb_.AddOffset(AttributeProto::VT_INTS, ints);
  }
  void add_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings) {
    fbb_.AddOffset(AttributeProto::VT_STRINGS, strings);
  }
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>>> tensors) {
    fbb_.AddOffset(AttributeProto::VT_TENSORS, tensors);
  }
  void add_graphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::GraphProto>>> graphs) {
    fbb_.AddOffset(AttributeProto::VT_GRAPHS, graphs);
  }
  void add_sparse_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>>> sparse_tensors) {
    fbb_.AddOffset(AttributeProto::VT_SPARSE_TENSORS, sparse_tensors);
  }
  void add_type_protos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeProto>>> type_protos) {
    fbb_.AddOffset(AttributeProto::VT_TYPE_PROTOS, type_protos);
  }
  explicit AttributeProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AttributeProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AttributeProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AttributeProto> CreateAttributeProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ref_attr_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    onnx::AttributeProto_::AttributeType type = onnx::AttributeProto_::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> s = 0,
    ::flatbuffers::Offset<onnx::TensorProto> t = 0,
    ::flatbuffers::Offset<onnx::GraphProto> g = 0,
    ::flatbuffers::Offset<onnx::SparseTensorProto> sparse_tensor = 0,
    ::flatbuffers::Offset<onnx::TypeProto> tp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> floats = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> ints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::GraphProto>>> graphs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>>> sparse_tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeProto>>> type_protos = 0) {
  AttributeProtoBuilder builder_(_fbb);
  builder_.add_i(i);
  builder_.add_type_protos(type_protos);
  builder_.add_sparse_tensors(sparse_tensors);
  builder_.add_graphs(graphs);
  builder_.add_tensors(tensors);
  builder_.add_strings(strings);
  builder_.add_ints(ints);
  builder_.add_floats(floats);
  builder_.add_tp(tp);
  builder_.add_sparse_tensor(sparse_tensor);
  builder_.add_g(g);
  builder_.add_t(t);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_ref_attr_name(ref_attr_name);
  builder_.add_name(name);
  return builder_.Finish();
}

struct AttributeProto::Traits {
  using type = AttributeProto;
  static auto constexpr Create = CreateAttributeProto;
};

inline ::flatbuffers::Offset<AttributeProto> CreateAttributeProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *ref_attr_name = nullptr,
    const char *doc_string = nullptr,
    onnx::AttributeProto_::AttributeType type = onnx::AttributeProto_::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    const std::vector<uint8_t> *s = nullptr,
    ::flatbuffers::Offset<onnx::TensorProto> t = 0,
    ::flatbuffers::Offset<onnx::GraphProto> g = 0,
    ::flatbuffers::Offset<onnx::SparseTensorProto> sparse_tensor = 0,
    ::flatbuffers::Offset<onnx::TypeProto> tp = 0,
    const std::vector<float> *floats = nullptr,
    const std::vector<int64_t> *ints = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *strings = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TensorProto>> *tensors = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::GraphProto>> *graphs = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *sparse_tensors = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TypeProto>> *type_protos = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto ref_attr_name__ = ref_attr_name ? _fbb.CreateString(ref_attr_name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto s__ = s ? _fbb.CreateVector<uint8_t>(*s) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int64_t>(*ints) : 0;
  auto strings__ = strings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*strings) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TensorProto>>(*tensors) : 0;
  auto graphs__ = graphs ? _fbb.CreateVector<::flatbuffers::Offset<onnx::GraphProto>>(*graphs) : 0;
  auto sparse_tensors__ = sparse_tensors ? _fbb.CreateVector<::flatbuffers::Offset<onnx::SparseTensorProto>>(*sparse_tensors) : 0;
  auto type_protos__ = type_protos ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TypeProto>>(*type_protos) : 0;
  return onnx::CreateAttributeProto(
      _fbb,
      name__,
      ref_attr_name__,
      doc_string__,
      type,
      f,
      i,
      s__,
      t,
      g,
      sparse_tensor,
      tp,
      floats__,
      ints__,
      strings__,
      tensors__,
      graphs__,
      sparse_tensors__,
      type_protos__);
}

struct ValueInfoProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueInfoProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ValueInfoProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.ValueInfoProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DOC_STRING = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const onnx::TypeProto *type() const {
    return GetPointer<const onnx::TypeProto *>(VT_TYPE);
  }
  onnx::TypeProto *mutable_type() {
    return GetPointer<onnx::TypeProto *>(VT_TYPE);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           verifier.EndTable();
  }
};

struct ValueInfoProtoBuilder {
  typedef ValueInfoProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ValueInfoProto::VT_NAME, name);
  }
  void add_type(::flatbuffers::Offset<onnx::TypeProto> type) {
    fbb_.AddOffset(ValueInfoProto::VT_TYPE, type);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(ValueInfoProto::VT_DOC_STRING, doc_string);
  }
  explicit ValueInfoProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueInfoProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueInfoProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueInfoProto> CreateValueInfoProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<onnx::TypeProto> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0) {
  ValueInfoProtoBuilder builder_(_fbb);
  builder_.add_doc_string(doc_string);
  builder_.add_type(type);
  builder_.add_name(name);
  return builder_.Finish();
}

struct ValueInfoProto::Traits {
  using type = ValueInfoProto;
  static auto constexpr Create = CreateValueInfoProto;
};

inline ::flatbuffers::Offset<ValueInfoProto> CreateValueInfoProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<onnx::TypeProto> type = 0,
    const char *doc_string = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  return onnx::CreateValueInfoProto(
      _fbb,
      name__,
      type,
      doc_string__);
}

struct NodeProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodeProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.NodeProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6,
    VT_NAME = 8,
    VT_OP_TYPE = 10,
    VT_DOMAIN = 12,
    VT_ATTRIBUTE = 14,
    VT_DOC_STRING = 16
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *input() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_input() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *output() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_output() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *op_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP_TYPE);
  }
  ::flatbuffers::String *mutable_op_type() {
    return GetPointer<::flatbuffers::String *>(VT_OP_TYPE);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *attribute() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *>(VT_ATTRIBUTE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *mutable_attribute() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *>(VT_ATTRIBUTE);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OP_TYPE) &&
           verifier.VerifyString(op_type()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyOffset(verifier, VT_ATTRIBUTE) &&
           verifier.VerifyVector(attribute()) &&
           verifier.VerifyVectorOfTables(attribute()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           verifier.EndTable();
  }
};

struct NodeProtoBuilder {
  typedef NodeProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input) {
    fbb_.AddOffset(NodeProto::VT_INPUT, input);
  }
  void add_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output) {
    fbb_.AddOffset(NodeProto::VT_OUTPUT, output);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NodeProto::VT_NAME, name);
  }
  void add_op_type(::flatbuffers::Offset<::flatbuffers::String> op_type) {
    fbb_.AddOffset(NodeProto::VT_OP_TYPE, op_type);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(NodeProto::VT_DOMAIN, domain);
  }
  void add_attribute(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>>> attribute) {
    fbb_.AddOffset(NodeProto::VT_ATTRIBUTE, attribute);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(NodeProto::VT_DOC_STRING, doc_string);
  }
  explicit NodeProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeProto> CreateNodeProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> op_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>>> attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0) {
  NodeProtoBuilder builder_(_fbb);
  builder_.add_doc_string(doc_string);
  builder_.add_attribute(attribute);
  builder_.add_domain(domain);
  builder_.add_op_type(op_type);
  builder_.add_name(name);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

struct NodeProto::Traits {
  using type = NodeProto;
  static auto constexpr Create = CreateNodeProto;
};

inline ::flatbuffers::Offset<NodeProto> CreateNodeProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *input = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *output = nullptr,
    const char *name = nullptr,
    const char *op_type = nullptr,
    const char *domain = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::AttributeProto>> *attribute = nullptr,
    const char *doc_string = nullptr) {
  auto input__ = input ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*output) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto op_type__ = op_type ? _fbb.CreateString(op_type) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto attribute__ = attribute ? _fbb.CreateVector<::flatbuffers::Offset<onnx::AttributeProto>>(*attribute) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  return onnx::CreateNodeProto(
      _fbb,
      input__,
      output__,
      name__,
      op_type__,
      domain__,
      attribute__,
      doc_string__);
}

struct TrainingInfoProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrainingInfoProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TrainingInfoProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TrainingInfoProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INITIALIZATION = 4,
    VT_ALGORITHM = 6,
    VT_INITIALIZATION_BINDING = 8,
    VT_UPDATE_BINDING = 10
  };
  const onnx::GraphProto *initialization() const {
    return GetPointer<const onnx::GraphProto *>(VT_INITIALIZATION);
  }
  onnx::GraphProto *mutable_initialization() {
    return GetPointer<onnx::GraphProto *>(VT_INITIALIZATION);
  }
  const onnx::GraphProto *algorithm() const {
    return GetPointer<const onnx::GraphProto *>(VT_ALGORITHM);
  }
  onnx::GraphProto *mutable_algorithm() {
    return GetPointer<onnx::GraphProto *>(VT_ALGORITHM);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *initialization_binding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_INITIALIZATION_BINDING);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *mutable_initialization_binding() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_INITIALIZATION_BINDING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *update_binding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_UPDATE_BINDING);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *mutable_update_binding() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_UPDATE_BINDING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INITIALIZATION) &&
           verifier.VerifyTable(initialization()) &&
           VerifyOffset(verifier, VT_ALGORITHM) &&
           verifier.VerifyTable(algorithm()) &&
           VerifyOffset(verifier, VT_INITIALIZATION_BINDING) &&
           verifier.VerifyVector(initialization_binding()) &&
           verifier.VerifyVectorOfTables(initialization_binding()) &&
           VerifyOffset(verifier, VT_UPDATE_BINDING) &&
           verifier.VerifyVector(update_binding()) &&
           verifier.VerifyVectorOfTables(update_binding()) &&
           verifier.EndTable();
  }
};

struct TrainingInfoProtoBuilder {
  typedef TrainingInfoProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_initialization(::flatbuffers::Offset<onnx::GraphProto> initialization) {
    fbb_.AddOffset(TrainingInfoProto::VT_INITIALIZATION, initialization);
  }
  void add_algorithm(::flatbuffers::Offset<onnx::GraphProto> algorithm) {
    fbb_.AddOffset(TrainingInfoProto::VT_ALGORITHM, algorithm);
  }
  void add_initialization_binding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> initialization_binding) {
    fbb_.AddOffset(TrainingInfoProto::VT_INITIALIZATION_BINDING, initialization_binding);
  }
  void add_update_binding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> update_binding) {
    fbb_.AddOffset(TrainingInfoProto::VT_UPDATE_BINDING, update_binding);
  }
  explicit TrainingInfoProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrainingInfoProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrainingInfoProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrainingInfoProto> CreateTrainingInfoProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::GraphProto> initialization = 0,
    ::flatbuffers::Offset<onnx::GraphProto> algorithm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> initialization_binding = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> update_binding = 0) {
  TrainingInfoProtoBuilder builder_(_fbb);
  builder_.add_update_binding(update_binding);
  builder_.add_initialization_binding(initialization_binding);
  builder_.add_algorithm(algorithm);
  builder_.add_initialization(initialization);
  return builder_.Finish();
}

struct TrainingInfoProto::Traits {
  using type = TrainingInfoProto;
  static auto constexpr Create = CreateTrainingInfoProto;
};

inline ::flatbuffers::Offset<TrainingInfoProto> CreateTrainingInfoProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::GraphProto> initialization = 0,
    ::flatbuffers::Offset<onnx::GraphProto> algorithm = 0,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *initialization_binding = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *update_binding = nullptr) {
  auto initialization_binding__ = initialization_binding ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntryProto>>(*initialization_binding) : 0;
  auto update_binding__ = update_binding ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntryProto>>(*update_binding) : 0;
  return onnx::CreateTrainingInfoProto(
      _fbb,
      initialization,
      algorithm,
      initialization_binding__,
      update_binding__);
}

struct ModelProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.ModelProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IR_VERSION = 4,
    VT_OPSET_IMPORT = 6,
    VT_PRODUCER_NAME = 8,
    VT_PRODUCER_VERSION = 10,
    VT_DOMAIN = 12,
    VT_MODEL_VERSION = 14,
    VT_DOC_STRING = 16,
    VT_GRAPH = 18,
    VT_METADATA_PROPS = 20,
    VT_TRAINING_INFO = 22,
    VT_FUNCTIONS = 24
  };
  int64_t ir_version() const {
    return GetField<int64_t>(VT_IR_VERSION, 0);
  }
  bool mutate_ir_version(int64_t _ir_version = 0) {
    return SetField<int64_t>(VT_IR_VERSION, _ir_version, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *opset_import() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *>(VT_OPSET_IMPORT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *mutable_opset_import() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *>(VT_OPSET_IMPORT);
  }
  const ::flatbuffers::String *producer_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  ::flatbuffers::String *mutable_producer_name() {
    return GetPointer<::flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  const ::flatbuffers::String *producer_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  ::flatbuffers::String *mutable_producer_version() {
    return GetPointer<::flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t model_version() const {
    return GetField<int64_t>(VT_MODEL_VERSION, 0);
  }
  bool mutate_model_version(int64_t _model_version = 0) {
    return SetField<int64_t>(VT_MODEL_VERSION, _model_version, 0);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnx::GraphProto *graph() const {
    return GetPointer<const onnx::GraphProto *>(VT_GRAPH);
  }
  onnx::GraphProto *mutable_graph() {
    return GetPointer<onnx::GraphProto *>(VT_GRAPH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_METADATA_PROPS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfoProto>> *training_info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfoProto>> *>(VT_TRAINING_INFO);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfoProto>> *mutable_training_info() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfoProto>> *>(VT_TRAINING_INFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::FunctionProto>> *functions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::FunctionProto>> *>(VT_FUNCTIONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::FunctionProto>> *mutable_functions() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::FunctionProto>> *>(VT_FUNCTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IR_VERSION, 8) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_PRODUCER_NAME) &&
           verifier.VerifyString(producer_name()) &&
           VerifyOffset(verifier, VT_PRODUCER_VERSION) &&
           verifier.VerifyString(producer_version()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_MODEL_VERSION, 8) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_GRAPH) &&
           verifier.VerifyTable(graph()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           VerifyOffset(verifier, VT_TRAINING_INFO) &&
           verifier.VerifyVector(training_info()) &&
           verifier.VerifyVectorOfTables(training_info()) &&
           VerifyOffset(verifier, VT_FUNCTIONS) &&
           verifier.VerifyVector(functions()) &&
           verifier.VerifyVectorOfTables(functions()) &&
           verifier.EndTable();
  }
};

struct ModelProtoBuilder {
  typedef ModelProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ir_version(int64_t ir_version) {
    fbb_.AddElement<int64_t>(ModelProto::VT_IR_VERSION, ir_version, 0);
  }
  void add_opset_import(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>>> opset_import) {
    fbb_.AddOffset(ModelProto::VT_OPSET_IMPORT, opset_import);
  }
  void add_producer_name(::flatbuffers::Offset<::flatbuffers::String> producer_name) {
    fbb_.AddOffset(ModelProto::VT_PRODUCER_NAME, producer_name);
  }
  void add_producer_version(::flatbuffers::Offset<::flatbuffers::String> producer_version) {
    fbb_.AddOffset(ModelProto::VT_PRODUCER_VERSION, producer_version);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(ModelProto::VT_DOMAIN, domain);
  }
  void add_model_version(int64_t model_version) {
    fbb_.AddElement<int64_t>(ModelProto::VT_MODEL_VERSION, model_version, 0);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(ModelProto::VT_DOC_STRING, doc_string);
  }
  void add_graph(::flatbuffers::Offset<onnx::GraphProto> graph) {
    fbb_.AddOffset(ModelProto::VT_GRAPH, graph);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> metadata_props) {
    fbb_.AddOffset(ModelProto::VT_METADATA_PROPS, metadata_props);
  }
  void add_training_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfoProto>>> training_info) {
    fbb_.AddOffset(ModelProto::VT_TRAINING_INFO, training_info);
  }
  void add_functions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::FunctionProto>>> functions) {
    fbb_.AddOffset(ModelProto::VT_FUNCTIONS, functions);
  }
  explicit ModelProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelProto> CreateModelProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>>> opset_import = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producer_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producer_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int64_t model_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<onnx::GraphProto> graph = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> metadata_props = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfoProto>>> training_info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::FunctionProto>>> functions = 0) {
  ModelProtoBuilder builder_(_fbb);
  builder_.add_model_version(model_version);
  builder_.add_ir_version(ir_version);
  builder_.add_functions(functions);
  builder_.add_training_info(training_info);
  builder_.add_metadata_props(metadata_props);
  builder_.add_graph(graph);
  builder_.add_doc_string(doc_string);
  builder_.add_domain(domain);
  builder_.add_producer_version(producer_version);
  builder_.add_producer_name(producer_name);
  builder_.add_opset_import(opset_import);
  return builder_.Finish();
}

struct ModelProto::Traits {
  using type = ModelProto;
  static auto constexpr Create = CreateModelProto;
};

inline ::flatbuffers::Offset<ModelProto> CreateModelProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    const std::vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *opset_import = nullptr,
    const char *producer_name = nullptr,
    const char *producer_version = nullptr,
    const char *domain = nullptr,
    int64_t model_version = 0,
    const char *doc_string = nullptr,
    ::flatbuffers::Offset<onnx::GraphProto> graph = 0,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *metadata_props = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TrainingInfoProto>> *training_info = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::FunctionProto>> *functions = nullptr) {
  auto opset_import__ = opset_import ? _fbb.CreateVector<::flatbuffers::Offset<onnx::OperatorSetIdProto>>(*opset_import) : 0;
  auto producer_name__ = producer_name ? _fbb.CreateString(producer_name) : 0;
  auto producer_version__ = producer_version ? _fbb.CreateString(producer_version) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntryProto>>(*metadata_props) : 0;
  auto training_info__ = training_info ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TrainingInfoProto>>(*training_info) : 0;
  auto functions__ = functions ? _fbb.CreateVector<::flatbuffers::Offset<onnx::FunctionProto>>(*functions) : 0;
  return onnx::CreateModelProto(
      _fbb,
      ir_version,
      opset_import__,
      producer_name__,
      producer_version__,
      domain__,
      model_version,
      doc_string__,
      graph,
      metadata_props__,
      training_info__,
      functions__);
}

struct StringStringEntryProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringStringEntryProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringStringEntryProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.StringStringEntryProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringStringEntryProtoBuilder {
  typedef StringStringEntryProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(StringStringEntryProto::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringStringEntryProto::VT_VALUE, value);
  }
  explicit StringStringEntryProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringStringEntryProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringStringEntryProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringStringEntryProto> CreateStringStringEntryProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringStringEntryProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct StringStringEntryProto::Traits {
  using type = StringStringEntryProto;
  static auto constexpr Create = CreateStringStringEntryProto;
};

inline ::flatbuffers::Offset<StringStringEntryProto> CreateStringStringEntryProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return onnx::CreateStringStringEntryProto(
      _fbb,
      key__,
      value__);
}

struct TensorAnnotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorAnnotationBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorAnnotationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorAnnotation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR_NAME = 4,
    VT_QUANT_PARAMETER_TENSOR_NAMES = 6
  };
  const ::flatbuffers::String *tensor_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TENSOR_NAME);
  }
  ::flatbuffers::String *mutable_tensor_name() {
    return GetPointer<::flatbuffers::String *>(VT_TENSOR_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *quant_parameter_tensor_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_QUANT_PARAMETER_TENSOR_NAMES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *mutable_quant_parameter_tensor_names() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_QUANT_PARAMETER_TENSOR_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSOR_NAME) &&
           verifier.VerifyString(tensor_name()) &&
           VerifyOffset(verifier, VT_QUANT_PARAMETER_TENSOR_NAMES) &&
           verifier.VerifyVector(quant_parameter_tensor_names()) &&
           verifier.VerifyVectorOfTables(quant_parameter_tensor_names()) &&
           verifier.EndTable();
  }
};

struct TensorAnnotationBuilder {
  typedef TensorAnnotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensor_name(::flatbuffers::Offset<::flatbuffers::String> tensor_name) {
    fbb_.AddOffset(TensorAnnotation::VT_TENSOR_NAME, tensor_name);
  }
  void add_quant_parameter_tensor_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> quant_parameter_tensor_names) {
    fbb_.AddOffset(TensorAnnotation::VT_QUANT_PARAMETER_TENSOR_NAMES, quant_parameter_tensor_names);
  }
  explicit TensorAnnotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorAnnotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorAnnotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorAnnotation> CreateTensorAnnotation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> tensor_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> quant_parameter_tensor_names = 0) {
  TensorAnnotationBuilder builder_(_fbb);
  builder_.add_quant_parameter_tensor_names(quant_parameter_tensor_names);
  builder_.add_tensor_name(tensor_name);
  return builder_.Finish();
}

struct TensorAnnotation::Traits {
  using type = TensorAnnotation;
  static auto constexpr Create = CreateTensorAnnotation;
};

inline ::flatbuffers::Offset<TensorAnnotation> CreateTensorAnnotationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *tensor_name = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *quant_parameter_tensor_names = nullptr) {
  auto tensor_name__ = tensor_name ? _fbb.CreateString(tensor_name) : 0;
  auto quant_parameter_tensor_names__ = quant_parameter_tensor_names ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntryProto>>(*quant_parameter_tensor_names) : 0;
  return onnx::CreateTensorAnnotation(
      _fbb,
      tensor_name__,
      quant_parameter_tensor_names__);
}

struct GraphProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GraphProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.GraphProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE = 4,
    VT_NAME = 6,
    VT_INITIALIZER = 8,
    VT_SPARSE_INITIALIZER = 10,
    VT_DOC_STRING = 12,
    VT_INPUT = 14,
    VT_OUTPUT = 16,
    VT_VALUE_INFO = 18,
    VT_QUANTIZATION_ANNOTATION = 20
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *node() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *>(VT_NODE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *mutable_node() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *>(VT_NODE);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *initializer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *>(VT_INITIALIZER);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *mutable_initializer() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>> *>(VT_INITIALIZER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *sparse_initializer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *>(VT_SPARSE_INITIALIZER);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *mutable_sparse_initializer() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *>(VT_SPARSE_INITIALIZER);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *input() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *>(VT_INPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *mutable_input() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *>(VT_INPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *output() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *>(VT_OUTPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *mutable_output() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *>(VT_OUTPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *value_info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *>(VT_VALUE_INFO);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *mutable_value_info() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *>(VT_VALUE_INFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *quantization_annotation() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *>(VT_QUANTIZATION_ANNOTATION);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *mutable_quantization_annotation() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *>(VT_QUANTIZATION_ANNOTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           verifier.VerifyVectorOfTables(node()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INITIALIZER) &&
           verifier.VerifyVector(initializer()) &&
           verifier.VerifyVectorOfTables(initializer()) &&
           VerifyOffset(verifier, VT_SPARSE_INITIALIZER) &&
           verifier.VerifyVector(sparse_initializer()) &&
           verifier.VerifyVectorOfTables(sparse_initializer()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfTables(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfTables(output()) &&
           VerifyOffset(verifier, VT_VALUE_INFO) &&
           verifier.VerifyVector(value_info()) &&
           verifier.VerifyVectorOfTables(value_info()) &&
           VerifyOffset(verifier, VT_QUANTIZATION_ANNOTATION) &&
           verifier.VerifyVector(quantization_annotation()) &&
           verifier.VerifyVectorOfTables(quantization_annotation()) &&
           verifier.EndTable();
  }
};

struct GraphProtoBuilder {
  typedef GraphProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>>> node) {
    fbb_.AddOffset(GraphProto::VT_NODE, node);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(GraphProto::VT_NAME, name);
  }
  void add_initializer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>>> initializer) {
    fbb_.AddOffset(GraphProto::VT_INITIALIZER, initializer);
  }
  void add_sparse_initializer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>>> sparse_initializer) {
    fbb_.AddOffset(GraphProto::VT_SPARSE_INITIALIZER, sparse_initializer);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(GraphProto::VT_DOC_STRING, doc_string);
  }
  void add_input(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>>> input) {
    fbb_.AddOffset(GraphProto::VT_INPUT, input);
  }
  void add_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>>> output) {
    fbb_.AddOffset(GraphProto::VT_OUTPUT, output);
  }
  void add_value_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>>> value_info) {
    fbb_.AddOffset(GraphProto::VT_VALUE_INFO, value_info);
  }
  void add_quantization_annotation(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>>> quantization_annotation) {
    fbb_.AddOffset(GraphProto::VT_QUANTIZATION_ANNOTATION, quantization_annotation);
  }
  explicit GraphProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GraphProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GraphProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GraphProto> CreateGraphProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>>> node = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorProto>>> initializer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensorProto>>> sparse_initializer = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>>> input = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>>> output = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfoProto>>> value_info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>>> quantization_annotation = 0) {
  GraphProtoBuilder builder_(_fbb);
  builder_.add_quantization_annotation(quantization_annotation);
  builder_.add_value_info(value_info);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_doc_string(doc_string);
  builder_.add_sparse_initializer(sparse_initializer);
  builder_.add_initializer(initializer);
  builder_.add_name(name);
  builder_.add_node(node);
  return builder_.Finish();
}

struct GraphProto::Traits {
  using type = GraphProto;
  static auto constexpr Create = CreateGraphProto;
};

inline ::flatbuffers::Offset<GraphProto> CreateGraphProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<onnx::NodeProto>> *node = nullptr,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TensorProto>> *initializer = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::SparseTensorProto>> *sparse_initializer = nullptr,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *input = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *output = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfoProto>> *value_info = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *quantization_annotation = nullptr) {
  auto node__ = node ? _fbb.CreateVector<::flatbuffers::Offset<onnx::NodeProto>>(*node) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto initializer__ = initializer ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TensorProto>>(*initializer) : 0;
  auto sparse_initializer__ = sparse_initializer ? _fbb.CreateVector<::flatbuffers::Offset<onnx::SparseTensorProto>>(*sparse_initializer) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto input__ = input ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfoProto>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfoProto>>(*output) : 0;
  auto value_info__ = value_info ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfoProto>>(*value_info) : 0;
  auto quantization_annotation__ = quantization_annotation ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TensorAnnotation>>(*quantization_annotation) : 0;
  return onnx::CreateGraphProto(
      _fbb,
      node__,
      name__,
      initializer__,
      sparse_initializer__,
      doc_string__,
      input__,
      output__,
      value_info__,
      quantization_annotation__);
}

struct TensorProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DATA_TYPE = 6,
    VT_SEGMENT = 8,
    VT_FLOAT_DATA = 10,
    VT_INT32_DATA = 12,
    VT_STRING_DATA = 14,
    VT_INT64_DATA = 16,
    VT_NAME = 18,
    VT_DOC_STRING = 20,
    VT_RAW_DATA = 22,
    VT_EXTERNAL_DATA = 24,
    VT_DATA_LOCATION = 26,
    VT_DOUBLE_DATA = 28,
    VT_UINT64_DATA = 30
  };
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  int32_t data_type() const {
    return GetField<int32_t>(VT_DATA_TYPE, 0);
  }
  bool mutate_data_type(int32_t _data_type = 0) {
    return SetField<int32_t>(VT_DATA_TYPE, _data_type, 0);
  }
  const onnx::TensorProto_::Segment *segment() const {
    return GetPointer<const onnx::TensorProto_::Segment *>(VT_SEGMENT);
  }
  onnx::TensorProto_::Segment *mutable_segment() {
    return GetPointer<onnx::TensorProto_::Segment *>(VT_SEGMENT);
  }
  const ::flatbuffers::Vector<float> *float_data() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_FLOAT_DATA);
  }
  ::flatbuffers::Vector<float> *mutable_float_data() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_FLOAT_DATA);
  }
  const ::flatbuffers::Vector<int32_t> *int32_data() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INT32_DATA);
  }
  ::flatbuffers::Vector<int32_t> *mutable_int32_data() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_INT32_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_string_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_DATA);
  }
  const ::flatbuffers::Vector<int64_t> *int64_data() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INT64_DATA);
  }
  ::flatbuffers::Vector<int64_t> *mutable_int64_data() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_INT64_DATA);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_raw_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *external_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_EXTERNAL_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *mutable_external_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *>(VT_EXTERNAL_DATA);
  }
  onnx::TensorProto_::DataLocation data_location() const {
    return static_cast<onnx::TensorProto_::DataLocation>(GetField<int32_t>(VT_DATA_LOCATION, 0));
  }
  bool mutate_data_location(onnx::TensorProto_::DataLocation _data_location = static_cast<onnx::TensorProto_::DataLocation>(0)) {
    return SetField<int32_t>(VT_DATA_LOCATION, static_cast<int32_t>(_data_location), 0);
  }
  const ::flatbuffers::Vector<double> *double_data() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DOUBLE_DATA);
  }
  ::flatbuffers::Vector<double> *mutable_double_data() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_DOUBLE_DATA);
  }
  const ::flatbuffers::Vector<uint64_t> *uint64_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_UINT64_DATA);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_uint64_data() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_UINT64_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE, 4) &&
           VerifyOffset(verifier, VT_SEGMENT) &&
           verifier.VerifyTable(segment()) &&
           VerifyOffset(verifier, VT_FLOAT_DATA) &&
           verifier.VerifyVector(float_data()) &&
           VerifyOffset(verifier, VT_INT32_DATA) &&
           verifier.VerifyVector(int32_data()) &&
           VerifyOffset(verifier, VT_STRING_DATA) &&
           verifier.VerifyVector(string_data()) &&
           verifier.VerifyVectorOfStrings(string_data()) &&
           VerifyOffset(verifier, VT_INT64_DATA) &&
           verifier.VerifyVector(int64_data()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           VerifyOffset(verifier, VT_EXTERNAL_DATA) &&
           verifier.VerifyVector(external_data()) &&
           verifier.VerifyVectorOfTables(external_data()) &&
           VerifyField<int32_t>(verifier, VT_DATA_LOCATION, 4) &&
           VerifyOffset(verifier, VT_DOUBLE_DATA) &&
           verifier.VerifyVector(double_data()) &&
           VerifyOffset(verifier, VT_UINT64_DATA) &&
           verifier.VerifyVector(uint64_data()) &&
           verifier.EndTable();
  }
};

struct TensorProtoBuilder {
  typedef TensorProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(TensorProto::VT_DIMS, dims);
  }
  void add_data_type(int32_t data_type) {
    fbb_.AddElement<int32_t>(TensorProto::VT_DATA_TYPE, data_type, 0);
  }
  void add_segment(::flatbuffers::Offset<onnx::TensorProto_::Segment> segment) {
    fbb_.AddOffset(TensorProto::VT_SEGMENT, segment);
  }
  void add_float_data(::flatbuffers::Offset<::flatbuffers::Vector<float>> float_data) {
    fbb_.AddOffset(TensorProto::VT_FLOAT_DATA, float_data);
  }
  void add_int32_data(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> int32_data) {
    fbb_.AddOffset(TensorProto::VT_INT32_DATA, int32_data);
  }
  void add_string_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_data) {
    fbb_.AddOffset(TensorProto::VT_STRING_DATA, string_data);
  }
  void add_int64_data(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> int64_data) {
    fbb_.AddOffset(TensorProto::VT_INT64_DATA, int64_data);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TensorProto::VT_NAME, name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(TensorProto::VT_DOC_STRING, doc_string);
  }
  void add_raw_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(TensorProto::VT_RAW_DATA, raw_data);
  }
  void add_external_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> external_data) {
    fbb_.AddOffset(TensorProto::VT_EXTERNAL_DATA, external_data);
  }
  void add_data_location(onnx::TensorProto_::DataLocation data_location) {
    fbb_.AddElement<int32_t>(TensorProto::VT_DATA_LOCATION, static_cast<int32_t>(data_location), 0);
  }
  void add_double_data(::flatbuffers::Offset<::flatbuffers::Vector<double>> double_data) {
    fbb_.AddOffset(TensorProto::VT_DOUBLE_DATA, double_data);
  }
  void add_uint64_data(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> uint64_data) {
    fbb_.AddOffset(TensorProto::VT_UINT64_DATA, uint64_data);
  }
  explicit TensorProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorProto> CreateTensorProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0,
    int32_t data_type = 0,
    ::flatbuffers::Offset<onnx::TensorProto_::Segment> segment = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> float_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> int32_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> int64_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntryProto>>> external_data = 0,
    onnx::TensorProto_::DataLocation data_location = onnx::TensorProto_::DataLocation::DEFAULT,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> double_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> uint64_data = 0) {
  TensorProtoBuilder builder_(_fbb);
  builder_.add_uint64_data(uint64_data);
  builder_.add_double_data(double_data);
  builder_.add_data_location(data_location);
  builder_.add_external_data(external_data);
  builder_.add_raw_data(raw_data);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  builder_.add_int64_data(int64_data);
  builder_.add_string_data(string_data);
  builder_.add_int32_data(int32_data);
  builder_.add_float_data(float_data);
  builder_.add_segment(segment);
  builder_.add_data_type(data_type);
  builder_.add_dims(dims);
  return builder_.Finish();
}

struct TensorProto::Traits {
  using type = TensorProto;
  static auto constexpr Create = CreateTensorProto;
};

inline ::flatbuffers::Offset<TensorProto> CreateTensorProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dims = nullptr,
    int32_t data_type = 0,
    ::flatbuffers::Offset<onnx::TensorProto_::Segment> segment = 0,
    const std::vector<float> *float_data = nullptr,
    const std::vector<int32_t> *int32_data = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_data = nullptr,
    const std::vector<int64_t> *int64_data = nullptr,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const std::vector<uint8_t> *raw_data = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntryProto>> *external_data = nullptr,
    onnx::TensorProto_::DataLocation data_location = onnx::TensorProto_::DataLocation::DEFAULT,
    const std::vector<double> *double_data = nullptr,
    const std::vector<uint64_t> *uint64_data = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto float_data__ = float_data ? _fbb.CreateVector<float>(*float_data) : 0;
  auto int32_data__ = int32_data ? _fbb.CreateVector<int32_t>(*int32_data) : 0;
  auto string_data__ = string_data ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_data) : 0;
  auto int64_data__ = int64_data ? _fbb.CreateVector<int64_t>(*int64_data) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  auto external_data__ = external_data ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntryProto>>(*external_data) : 0;
  auto double_data__ = double_data ? _fbb.CreateVector<double>(*double_data) : 0;
  auto uint64_data__ = uint64_data ? _fbb.CreateVector<uint64_t>(*uint64_data) : 0;
  return onnx::CreateTensorProto(
      _fbb,
      dims__,
      data_type,
      segment,
      float_data__,
      int32_data__,
      string_data__,
      int64_data__,
      name__,
      doc_string__,
      raw_data__,
      external_data__,
      data_location,
      double_data__,
      uint64_data__);
}

namespace TensorProto_ {

struct Segment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SegmentBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SegmentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorProto_.Segment";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN = 4,
    VT_END = 6
  };
  int64_t begin() const {
    return GetField<int64_t>(VT_BEGIN, 0);
  }
  bool mutate_begin(int64_t _begin = 0) {
    return SetField<int64_t>(VT_BEGIN, _begin, 0);
  }
  int64_t end() const {
    return GetField<int64_t>(VT_END, 0);
  }
  bool mutate_end(int64_t _end = 0) {
    return SetField<int64_t>(VT_END, _end, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN, 8) &&
           VerifyField<int64_t>(verifier, VT_END, 8) &&
           verifier.EndTable();
  }
};

struct SegmentBuilder {
  typedef Segment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_begin(int64_t begin) {
    fbb_.AddElement<int64_t>(Segment::VT_BEGIN, begin, 0);
  }
  void add_end(int64_t end) {
    fbb_.AddElement<int64_t>(Segment::VT_END, end, 0);
  }
  explicit SegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Segment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Segment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Segment> CreateSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin = 0,
    int64_t end = 0) {
  SegmentBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_begin(begin);
  return builder_.Finish();
}

struct Segment::Traits {
  using type = Segment;
  static auto constexpr Create = CreateSegment;
};

}  // namespace TensorProto_

struct SparseTensorProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparseTensorProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseTensorProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.SparseTensorProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_INDICES = 6,
    VT_DIMS = 8
  };
  const onnx::TensorProto *values() const {
    return GetPointer<const onnx::TensorProto *>(VT_VALUES);
  }
  onnx::TensorProto *mutable_values() {
    return GetPointer<onnx::TensorProto *>(VT_VALUES);
  }
  const onnx::TensorProto *indices() const {
    return GetPointer<const onnx::TensorProto *>(VT_INDICES);
  }
  onnx::TensorProto *mutable_indices() {
    return GetPointer<onnx::TensorProto *>(VT_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyTable(values()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyTable(indices()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct SparseTensorProtoBuilder {
  typedef SparseTensorProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<onnx::TensorProto> values) {
    fbb_.AddOffset(SparseTensorProto::VT_VALUES, values);
  }
  void add_indices(::flatbuffers::Offset<onnx::TensorProto> indices) {
    fbb_.AddOffset(SparseTensorProto::VT_INDICES, indices);
  }
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(SparseTensorProto::VT_DIMS, dims);
  }
  explicit SparseTensorProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseTensorProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseTensorProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseTensorProto> CreateSparseTensorProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TensorProto> values = 0,
    ::flatbuffers::Offset<onnx::TensorProto> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0) {
  SparseTensorProtoBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_indices(indices);
  builder_.add_values(values);
  return builder_.Finish();
}

struct SparseTensorProto::Traits {
  using type = SparseTensorProto;
  static auto constexpr Create = CreateSparseTensorProto;
};

inline ::flatbuffers::Offset<SparseTensorProto> CreateSparseTensorProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TensorProto> values = 0,
    ::flatbuffers::Offset<onnx::TensorProto> indices = 0,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return onnx::CreateSparseTensorProto(
      _fbb,
      values,
      indices,
      dims__);
}

struct TensorShapeProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorShapeProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorShapeProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorShapeProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>> *>(VT_DIM);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>> *mutable_dim() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>> *>(VT_DIM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.VerifyVectorOfTables(dim()) &&
           verifier.EndTable();
  }
};

struct TensorShapeProtoBuilder {
  typedef TensorShapeProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>>> dim) {
    fbb_.AddOffset(TensorShapeProto::VT_DIM, dim);
  }
  explicit TensorShapeProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorShapeProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorShapeProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorShapeProto> CreateTensorShapeProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>>> dim = 0) {
  TensorShapeProtoBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

struct TensorShapeProto::Traits {
  using type = TensorShapeProto;
  static auto constexpr Create = CreateTensorShapeProto;
};

inline ::flatbuffers::Offset<TensorShapeProto> CreateTensorShapeProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>> *dim = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension>>(*dim) : 0;
  return onnx::CreateTensorShapeProto(
      _fbb,
      dim__);
}

namespace TensorShapeProto_ {

struct Dimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DimensionBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimensionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorShapeProto_.Dimension";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DENOTATION = 6
  };
  const onnx::TensorShapeProto_::Dimension_::Anonymous0 *value() const {
    return GetPointer<const onnx::TensorShapeProto_::Dimension_::Anonymous0 *>(VT_VALUE);
  }
  onnx::TensorShapeProto_::Dimension_::Anonymous0 *mutable_value() {
    return GetPointer<onnx::TensorShapeProto_::Dimension_::Anonymous0 *>(VT_VALUE);
  }
  const ::flatbuffers::String *denotation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DENOTATION);
  }
  ::flatbuffers::String *mutable_denotation() {
    return GetPointer<::flatbuffers::String *>(VT_DENOTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
};

struct DimensionBuilder {
  typedef Dimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension_::Anonymous0> value) {
    fbb_.AddOffset(Dimension::VT_VALUE, value);
  }
  void add_denotation(::flatbuffers::Offset<::flatbuffers::String> denotation) {
    fbb_.AddOffset(Dimension::VT_DENOTATION, denotation);
  }
  explicit DimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dimension>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Dimension> CreateDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension_::Anonymous0> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> denotation = 0) {
  DimensionBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Dimension::Traits {
  using type = Dimension;
  static auto constexpr Create = CreateDimension;
};

inline ::flatbuffers::Offset<Dimension> CreateDimensionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TensorShapeProto_::Dimension_::Anonymous0> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnx::TensorShapeProto_::CreateDimension(
      _fbb,
      value,
      denotation__);
}

namespace Dimension_ {

struct Anonymous0 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous0Builder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Anonymous0TypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorShapeProto_.Dimension_.Anonymous0";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM_VALUE = 4,
    VT_DIM_PARAM = 6
  };
  int64_t dim_value() const {
    return GetField<int64_t>(VT_DIM_VALUE, 0);
  }
  bool mutate_dim_value(int64_t _dim_value = 0) {
    return SetField<int64_t>(VT_DIM_VALUE, _dim_value, 0);
  }
  const ::flatbuffers::String *dim_param() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIM_PARAM);
  }
  ::flatbuffers::String *mutable_dim_param() {
    return GetPointer<::flatbuffers::String *>(VT_DIM_PARAM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DIM_VALUE, 8) &&
           VerifyOffset(verifier, VT_DIM_PARAM) &&
           verifier.VerifyString(dim_param()) &&
           verifier.EndTable();
  }
};

struct Anonymous0Builder {
  typedef Anonymous0 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim_value(int64_t dim_value) {
    fbb_.AddElement<int64_t>(Anonymous0::VT_DIM_VALUE, dim_value, 0);
  }
  void add_dim_param(::flatbuffers::Offset<::flatbuffers::String> dim_param) {
    fbb_.AddOffset(Anonymous0::VT_DIM_PARAM, dim_param);
  }
  explicit Anonymous0Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous0> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous0>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous0> CreateAnonymous0(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dim_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dim_param = 0) {
  Anonymous0Builder builder_(_fbb);
  builder_.add_dim_value(dim_value);
  builder_.add_dim_param(dim_param);
  return builder_.Finish();
}

struct Anonymous0::Traits {
  using type = Anonymous0;
  static auto constexpr Create = CreateAnonymous0;
};

inline ::flatbuffers::Offset<Anonymous0> CreateAnonymous0Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dim_value = 0,
    const char *dim_param = nullptr) {
  auto dim_param__ = dim_param ? _fbb.CreateString(dim_param) : 0;
  return onnx::TensorShapeProto_::Dimension_::CreateAnonymous0(
      _fbb,
      dim_value,
      dim_param__);
}

}  // namespace Dimension_
}  // namespace TensorShapeProto_

struct TypeProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TypeProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TypeProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DENOTATION = 6
  };
  const onnx::TypeProto_::Anonymous1 *value() const {
    return GetPointer<const onnx::TypeProto_::Anonymous1 *>(VT_VALUE);
  }
  onnx::TypeProto_::Anonymous1 *mutable_value() {
    return GetPointer<onnx::TypeProto_::Anonymous1 *>(VT_VALUE);
  }
  const ::flatbuffers::String *denotation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DENOTATION);
  }
  ::flatbuffers::String *mutable_denotation() {
    return GetPointer<::flatbuffers::String *>(VT_DENOTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
};

struct TypeProtoBuilder {
  typedef TypeProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<onnx::TypeProto_::Anonymous1> value) {
    fbb_.AddOffset(TypeProto::VT_VALUE, value);
  }
  void add_denotation(::flatbuffers::Offset<::flatbuffers::String> denotation) {
    fbb_.AddOffset(TypeProto::VT_DENOTATION, denotation);
  }
  explicit TypeProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TypeProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TypeProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TypeProto> CreateTypeProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TypeProto_::Anonymous1> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> denotation = 0) {
  TypeProtoBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TypeProto::Traits {
  using type = TypeProto;
  static auto constexpr Create = CreateTypeProto;
};

inline ::flatbuffers::Offset<TypeProto> CreateTypeProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TypeProto_::Anonymous1> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnx::CreateTypeProto(
      _fbb,
      value,
      denotation__);
}

namespace TypeProto_ {

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto_.Tensor";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  int32_t elem_type() const {
    return GetField<int32_t>(VT_ELEM_TYPE, 0);
  }
  bool mutate_elem_type(int32_t _elem_type = 0) {
    return SetField<int32_t>(VT_ELEM_TYPE, _elem_type, 0);
  }
  const onnx::TensorShapeProto *shape() const {
    return GetPointer<const onnx::TensorShapeProto *>(VT_SHAPE);
  }
  onnx::TensorShapeProto *mutable_shape() {
    return GetPointer<onnx::TensorShapeProto *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(int32_t elem_type) {
    fbb_.AddElement<int32_t>(Tensor::VT_ELEM_TYPE, elem_type, 0);
  }
  void add_shape(::flatbuffers::Offset<onnx::TensorShapeProto> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elem_type = 0,
    ::flatbuffers::Offset<onnx::TensorShapeProto> shape = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct Tensor::Traits {
  using type = Tensor;
  static auto constexpr Create = CreateTensor;
};

struct Sequence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SequenceBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SequenceTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto_.Sequence";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4
  };
  const onnx::TypeProto *elem_type() const {
    return GetPointer<const onnx::TypeProto *>(VT_ELEM_TYPE);
  }
  onnx::TypeProto *mutable_elem_type() {
    return GetPointer<onnx::TypeProto *>(VT_ELEM_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           verifier.VerifyTable(elem_type()) &&
           verifier.EndTable();
  }
};

struct SequenceBuilder {
  typedef Sequence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(::flatbuffers::Offset<onnx::TypeProto> elem_type) {
    fbb_.AddOffset(Sequence::VT_ELEM_TYPE, elem_type);
  }
  explicit SequenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sequence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sequence> CreateSequence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TypeProto> elem_type = 0) {
  SequenceBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct Sequence::Traits {
  using type = Sequence;
  static auto constexpr Create = CreateSequence;
};

struct Map FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto_.Map";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY_TYPE = 4,
    VT_VALUE_TYPE = 6
  };
  int32_t key_type() const {
    return GetField<int32_t>(VT_KEY_TYPE, 0);
  }
  bool mutate_key_type(int32_t _key_type = 0) {
    return SetField<int32_t>(VT_KEY_TYPE, _key_type, 0);
  }
  const onnx::TypeProto *value_type() const {
    return GetPointer<const onnx::TypeProto *>(VT_VALUE_TYPE);
  }
  onnx::TypeProto *mutable_value_type() {
    return GetPointer<onnx::TypeProto *>(VT_VALUE_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_TYPE, 4) &&
           VerifyOffset(verifier, VT_VALUE_TYPE) &&
           verifier.VerifyTable(value_type()) &&
           verifier.EndTable();
  }
};

struct MapBuilder {
  typedef Map Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key_type(int32_t key_type) {
    fbb_.AddElement<int32_t>(Map::VT_KEY_TYPE, key_type, 0);
  }
  void add_value_type(::flatbuffers::Offset<onnx::TypeProto> value_type) {
    fbb_.AddOffset(Map::VT_VALUE_TYPE, value_type);
  }
  explicit MapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Map>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Map> CreateMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key_type = 0,
    ::flatbuffers::Offset<onnx::TypeProto> value_type = 0) {
  MapBuilder builder_(_fbb);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  return builder_.Finish();
}

struct Map::Traits {
  using type = Map;
  static auto constexpr Create = CreateMap;
};

struct Optional FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OptionalTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto_.Optional";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4
  };
  const onnx::TypeProto *elem_type() const {
    return GetPointer<const onnx::TypeProto *>(VT_ELEM_TYPE);
  }
  onnx::TypeProto *mutable_elem_type() {
    return GetPointer<onnx::TypeProto *>(VT_ELEM_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           verifier.VerifyTable(elem_type()) &&
           verifier.EndTable();
  }
};

struct OptionalBuilder {
  typedef Optional Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(::flatbuffers::Offset<onnx::TypeProto> elem_type) {
    fbb_.AddOffset(Optional::VT_ELEM_TYPE, elem_type);
  }
  explicit OptionalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Optional> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Optional>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Optional> CreateOptional(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TypeProto> elem_type = 0) {
  OptionalBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct Optional::Traits {
  using type = Optional;
  static auto constexpr Create = CreateOptional;
};

struct SparseTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparseTensorBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseTensorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto_.SparseTensor";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  int32_t elem_type() const {
    return GetField<int32_t>(VT_ELEM_TYPE, 0);
  }
  bool mutate_elem_type(int32_t _elem_type = 0) {
    return SetField<int32_t>(VT_ELEM_TYPE, _elem_type, 0);
  }
  const onnx::TensorShapeProto *shape() const {
    return GetPointer<const onnx::TensorShapeProto *>(VT_SHAPE);
  }
  onnx::TensorShapeProto *mutable_shape() {
    return GetPointer<onnx::TensorShapeProto *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct SparseTensorBuilder {
  typedef SparseTensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(int32_t elem_type) {
    fbb_.AddElement<int32_t>(SparseTensor::VT_ELEM_TYPE, elem_type, 0);
  }
  void add_shape(::flatbuffers::Offset<onnx::TensorShapeProto> shape) {
    fbb_.AddOffset(SparseTensor::VT_SHAPE, shape);
  }
  explicit SparseTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseTensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseTensor> CreateSparseTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elem_type = 0,
    ::flatbuffers::Offset<onnx::TensorShapeProto> shape = 0) {
  SparseTensorBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct SparseTensor::Traits {
  using type = SparseTensor;
  static auto constexpr Create = CreateSparseTensor;
};

struct Anonymous1 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous1Builder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Anonymous1TypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeProto_.Anonymous1";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR_TYPE = 4,
    VT_SEQUENCE_TYPE = 6,
    VT_MAP_TYPE = 8,
    VT_OPTIONAL_TYPE = 10,
    VT_SPARSE_TENSOR_TYPE = 12
  };
  const onnx::TypeProto_::Tensor *tensor_type() const {
    return GetPointer<const onnx::TypeProto_::Tensor *>(VT_TENSOR_TYPE);
  }
  onnx::TypeProto_::Tensor *mutable_tensor_type() {
    return GetPointer<onnx::TypeProto_::Tensor *>(VT_TENSOR_TYPE);
  }
  const onnx::TypeProto_::Sequence *sequence_type() const {
    return GetPointer<const onnx::TypeProto_::Sequence *>(VT_SEQUENCE_TYPE);
  }
  onnx::TypeProto_::Sequence *mutable_sequence_type() {
    return GetPointer<onnx::TypeProto_::Sequence *>(VT_SEQUENCE_TYPE);
  }
  const onnx::TypeProto_::Map *map_type() const {
    return GetPointer<const onnx::TypeProto_::Map *>(VT_MAP_TYPE);
  }
  onnx::TypeProto_::Map *mutable_map_type() {
    return GetPointer<onnx::TypeProto_::Map *>(VT_MAP_TYPE);
  }
  const onnx::TypeProto_::Optional *optional_type() const {
    return GetPointer<const onnx::TypeProto_::Optional *>(VT_OPTIONAL_TYPE);
  }
  onnx::TypeProto_::Optional *mutable_optional_type() {
    return GetPointer<onnx::TypeProto_::Optional *>(VT_OPTIONAL_TYPE);
  }
  const onnx::TypeProto_::SparseTensor *sparse_tensor_type() const {
    return GetPointer<const onnx::TypeProto_::SparseTensor *>(VT_SPARSE_TENSOR_TYPE);
  }
  onnx::TypeProto_::SparseTensor *mutable_sparse_tensor_type() {
    return GetPointer<onnx::TypeProto_::SparseTensor *>(VT_SPARSE_TENSOR_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSOR_TYPE) &&
           verifier.VerifyTable(tensor_type()) &&
           VerifyOffset(verifier, VT_SEQUENCE_TYPE) &&
           verifier.VerifyTable(sequence_type()) &&
           VerifyOffset(verifier, VT_MAP_TYPE) &&
           verifier.VerifyTable(map_type()) &&
           VerifyOffset(verifier, VT_OPTIONAL_TYPE) &&
           verifier.VerifyTable(optional_type()) &&
           VerifyOffset(verifier, VT_SPARSE_TENSOR_TYPE) &&
           verifier.VerifyTable(sparse_tensor_type()) &&
           verifier.EndTable();
  }
};

struct Anonymous1Builder {
  typedef Anonymous1 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensor_type(::flatbuffers::Offset<onnx::TypeProto_::Tensor> tensor_type) {
    fbb_.AddOffset(Anonymous1::VT_TENSOR_TYPE, tensor_type);
  }
  void add_sequence_type(::flatbuffers::Offset<onnx::TypeProto_::Sequence> sequence_type) {
    fbb_.AddOffset(Anonymous1::VT_SEQUENCE_TYPE, sequence_type);
  }
  void add_map_type(::flatbuffers::Offset<onnx::TypeProto_::Map> map_type) {
    fbb_.AddOffset(Anonymous1::VT_MAP_TYPE, map_type);
  }
  void add_optional_type(::flatbuffers::Offset<onnx::TypeProto_::Optional> optional_type) {
    fbb_.AddOffset(Anonymous1::VT_OPTIONAL_TYPE, optional_type);
  }
  void add_sparse_tensor_type(::flatbuffers::Offset<onnx::TypeProto_::SparseTensor> sparse_tensor_type) {
    fbb_.AddOffset(Anonymous1::VT_SPARSE_TENSOR_TYPE, sparse_tensor_type);
  }
  explicit Anonymous1Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous1>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous1> CreateAnonymous1(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::TypeProto_::Tensor> tensor_type = 0,
    ::flatbuffers::Offset<onnx::TypeProto_::Sequence> sequence_type = 0,
    ::flatbuffers::Offset<onnx::TypeProto_::Map> map_type = 0,
    ::flatbuffers::Offset<onnx::TypeProto_::Optional> optional_type = 0,
    ::flatbuffers::Offset<onnx::TypeProto_::SparseTensor> sparse_tensor_type = 0) {
  Anonymous1Builder builder_(_fbb);
  builder_.add_sparse_tensor_type(sparse_tensor_type);
  builder_.add_optional_type(optional_type);
  builder_.add_map_type(map_type);
  builder_.add_sequence_type(sequence_type);
  builder_.add_tensor_type(tensor_type);
  return builder_.Finish();
}

struct Anonymous1::Traits {
  using type = Anonymous1;
  static auto constexpr Create = CreateAnonymous1;
};

}  // namespace TypeProto_

struct OperatorSetIdProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorSetIdProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OperatorSetIdProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.OperatorSetIdProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOMAIN = 4,
    VT_VERSION = 6
  };
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool mutate_version(int64_t _version = 0) {
    return SetField<int64_t>(VT_VERSION, _version, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_VERSION, 8) &&
           verifier.EndTable();
  }
};

struct OperatorSetIdProtoBuilder {
  typedef OperatorSetIdProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(OperatorSetIdProto::VT_DOMAIN, domain);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(OperatorSetIdProto::VT_VERSION, version, 0);
  }
  explicit OperatorSetIdProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OperatorSetIdProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OperatorSetIdProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OperatorSetIdProto> CreateOperatorSetIdProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int64_t version = 0) {
  OperatorSetIdProtoBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_domain(domain);
  return builder_.Finish();
}

struct OperatorSetIdProto::Traits {
  using type = OperatorSetIdProto;
  static auto constexpr Create = CreateOperatorSetIdProto;
};

inline ::flatbuffers::Offset<OperatorSetIdProto> CreateOperatorSetIdProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *domain = nullptr,
    int64_t version = 0) {
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  return onnx::CreateOperatorSetIdProto(
      _fbb,
      domain__,
      version);
}

struct FunctionProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FunctionProtoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FunctionProtoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.FunctionProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUT = 6,
    VT_OUTPUT = 8,
    VT_ATTRIBUTE = 10,
    VT_ATTRIBUTE_PROTO = 12,
    VT_NODE = 14,
    VT_DOC_STRING = 16,
    VT_OPSET_IMPORT = 18,
    VT_DOMAIN = 20
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *input() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_input() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *output() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_output() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *attribute() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ATTRIBUTE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_attribute() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ATTRIBUTE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *attribute_proto() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *>(VT_ATTRIBUTE_PROTO);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *mutable_attribute_proto() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>> *>(VT_ATTRIBUTE_PROTO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *node() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *>(VT_NODE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *mutable_node() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>> *>(VT_NODE);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *opset_import() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *>(VT_OPSET_IMPORT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *mutable_opset_import() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *>(VT_OPSET_IMPORT);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_ATTRIBUTE) &&
           verifier.VerifyVector(attribute()) &&
           verifier.VerifyVectorOfStrings(attribute()) &&
           VerifyOffset(verifier, VT_ATTRIBUTE_PROTO) &&
           verifier.VerifyVector(attribute_proto()) &&
           verifier.VerifyVectorOfTables(attribute_proto()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           verifier.VerifyVectorOfTables(node()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           verifier.EndTable();
  }
};

struct FunctionProtoBuilder {
  typedef FunctionProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FunctionProto::VT_NAME, name);
  }
  void add_input(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input) {
    fbb_.AddOffset(FunctionProto::VT_INPUT, input);
  }
  void add_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output) {
    fbb_.AddOffset(FunctionProto::VT_OUTPUT, output);
  }
  void add_attribute(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> attribute) {
    fbb_.AddOffset(FunctionProto::VT_ATTRIBUTE, attribute);
  }
  void add_attribute_proto(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>>> attribute_proto) {
    fbb_.AddOffset(FunctionProto::VT_ATTRIBUTE_PROTO, attribute_proto);
  }
  void add_node(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>>> node) {
    fbb_.AddOffset(FunctionProto::VT_NODE, node);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(FunctionProto::VT_DOC_STRING, doc_string);
  }
  void add_opset_import(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>>> opset_import) {
    fbb_.AddOffset(FunctionProto::VT_OPSET_IMPORT, opset_import);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(FunctionProto::VT_DOMAIN, domain);
  }
  explicit FunctionProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FunctionProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FunctionProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FunctionProto> CreateFunctionProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::AttributeProto>>> attribute_proto = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeProto>>> node = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>>> opset_import = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0) {
  FunctionProtoBuilder builder_(_fbb);
  builder_.add_domain(domain);
  builder_.add_opset_import(opset_import);
  builder_.add_doc_string(doc_string);
  builder_.add_node(node);
  builder_.add_attribute_proto(attribute_proto);
  builder_.add_attribute(attribute);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_name(name);
  return builder_.Finish();
}

struct FunctionProto::Traits {
  using type = FunctionProto;
  static auto constexpr Create = CreateFunctionProto;
};

inline ::flatbuffers::Offset<FunctionProto> CreateFunctionProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *input = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *output = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *attribute = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::AttributeProto>> *attribute_proto = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::NodeProto>> *node = nullptr,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::OperatorSetIdProto>> *opset_import = nullptr,
    const char *domain = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto input__ = input ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*output) : 0;
  auto attribute__ = attribute ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*attribute) : 0;
  auto attribute_proto__ = attribute_proto ? _fbb.CreateVector<::flatbuffers::Offset<onnx::AttributeProto>>(*attribute_proto) : 0;
  auto node__ = node ? _fbb.CreateVector<::flatbuffers::Offset<onnx::NodeProto>>(*node) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto opset_import__ = opset_import ? _fbb.CreateVector<::flatbuffers::Offset<onnx::OperatorSetIdProto>>(*opset_import) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  return onnx::CreateFunctionProto(
      _fbb,
      name__,
      input__,
      output__,
      attribute__,
      attribute_proto__,
      node__,
      doc_string__,
      opset_import__,
      domain__);
}

namespace TensorProto_ {

}  // namespace TensorProto_

namespace TensorShapeProto_ {

namespace Dimension_ {

}  // namespace Dimension_
}  // namespace TensorShapeProto_

namespace TypeProto_ {

}  // namespace TypeProto_

inline const ::flatbuffers::TypeTable *VersionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::VersionTypeTable
  };
  static const char * const names[] = {
    "_START_VERSION",
    "IR_VERSION_2017_10_10",
    "IR_VERSION_2017_10_30",
    "IR_VERSION_2017_11_3",
    "IR_VERSION_2019_1_22",
    "IR_VERSION_2019_3_18",
    "IR_VERSION_2019_9_19",
    "IR_VERSION_2020_5_8",
    "IR_VERSION_2021_7_30",
    "IR_VERSION"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace AttributeProto_ {

inline const ::flatbuffers::TypeTable *AttributeTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeProto_::AttributeTypeTypeTable
  };
  static const char * const names[] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    "TYPE_PROTO",
    "TYPE_PROTOS"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace AttributeProto_

namespace TensorProto_ {

inline const ::flatbuffers::TypeTable *DataTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorProto_::DataTypeTypeTable
  };
  static const char * const names[] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 21, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DataLocationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorProto_::DataLocationTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "EXTERNAL"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace TensorProto_

inline const ::flatbuffers::TypeTable *OperatorStatusTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::OperatorStatusTypeTable
  };
  static const char * const names[] = {
    "EXPERIMENTAL",
    "STABLE"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AttributeProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeProto_::AttributeTypeTypeTable,
    onnx::TensorProtoTypeTable,
    onnx::GraphProtoTypeTable,
    onnx::SparseTensorProtoTypeTable,
    onnx::TypeProtoTypeTable
  };
  static const char * const names[] = {
    "name",
    "ref_attr_name",
    "doc_string",
    "type",
    "f",
    "i",
    "s",
    "t",
    "g",
    "sparse_tensor",
    "tp",
    "floats",
    "ints",
    "strings",
    "tensors",
    "graphs",
    "sparse_tensors",
    "type_protos"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 18, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ValueInfoProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeProtoTypeTable
  };
  static const char * const names[] = {
    "name",
    "type",
    "doc_string"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodeProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeProtoTypeTable
  };
  static const char * const names[] = {
    "input",
    "output",
    "name",
    "op_type",
    "domain",
    "attribute",
    "doc_string"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TrainingInfoProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::GraphProtoTypeTable,
    onnx::StringStringEntryProtoTypeTable
  };
  static const char * const names[] = {
    "initialization",
    "algorithm",
    "initialization_binding",
    "update_binding"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ModelProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::OperatorSetIdProtoTypeTable,
    onnx::GraphProtoTypeTable,
    onnx::StringStringEntryProtoTypeTable,
    onnx::TrainingInfoProtoTypeTable,
    onnx::FunctionProtoTypeTable
  };
  static const char * const names[] = {
    "ir_version",
    "opset_import",
    "producer_name",
    "producer_version",
    "domain",
    "model_version",
    "doc_string",
    "graph",
    "metadata_props",
    "training_info",
    "functions"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StringStringEntryProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorAnnotationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::StringStringEntryProtoTypeTable
  };
  static const char * const names[] = {
    "tensor_name",
    "quant_parameter_tensor_names"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GraphProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::NodeProtoTypeTable,
    onnx::TensorProtoTypeTable,
    onnx::SparseTensorProtoTypeTable,
    onnx::ValueInfoProtoTypeTable,
    onnx::TensorAnnotationTypeTable
  };
  static const char * const names[] = {
    "node",
    "name",
    "initializer",
    "sparse_initializer",
    "doc_string",
    "input",
    "output",
    "value_info",
    "quantization_annotation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_INT, 0, 2 },
    { ::flatbuffers::ET_DOUBLE, 1, -1 },
    { ::flatbuffers::ET_ULONG, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorProto_::SegmentTypeTable,
    onnx::StringStringEntryProtoTypeTable,
    onnx::TensorProto_::DataLocationTypeTable
  };
  static const char * const names[] = {
    "dims",
    "data_type",
    "segment",
    "float_data",
    "int32_data",
    "string_data",
    "int64_data",
    "name",
    "doc_string",
    "raw_data",
    "external_data",
    "data_location",
    "double_data",
    "uint64_data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace TensorProto_ {

inline const ::flatbuffers::TypeTable *SegmentTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "begin",
    "end"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace TensorProto_

inline const ::flatbuffers::TypeTable *SparseTensorProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_LONG, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorProtoTypeTable
  };
  static const char * const names[] = {
    "values",
    "indices",
    "dims"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorShapeProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorShapeProto_::DimensionTypeTable
  };
  static const char * const names[] = {
    "dim"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace TensorShapeProto_ {

inline const ::flatbuffers::TypeTable *DimensionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorShapeProto_::Dimension_::Anonymous0TypeTable
  };
  static const char * const names[] = {
    "value",
    "denotation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace Dimension_ {

inline const ::flatbuffers::TypeTable *Anonymous0TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "dim_value",
    "dim_param"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace Dimension_
}  // namespace TensorShapeProto_

inline const ::flatbuffers::TypeTable *TypeProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeProto_::Anonymous1TypeTable
  };
  static const char * const names[] = {
    "value",
    "denotation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace TypeProto_ {

inline const ::flatbuffers::TypeTable *TensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorShapeProtoTypeTable
  };
  static const char * const names[] = {
    "elem_type",
    "shape"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SequenceTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeProtoTypeTable
  };
  static const char * const names[] = {
    "elem_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MapTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeProtoTypeTable
  };
  static const char * const names[] = {
    "key_type",
    "value_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OptionalTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeProtoTypeTable
  };
  static const char * const names[] = {
    "elem_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SparseTensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorShapeProtoTypeTable
  };
  static const char * const names[] = {
    "elem_type",
    "shape"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Anonymous1TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeProto_::TensorTypeTable,
    onnx::TypeProto_::SequenceTypeTable,
    onnx::TypeProto_::MapTypeTable,
    onnx::TypeProto_::OptionalTypeTable,
    onnx::TypeProto_::SparseTensorTypeTable
  };
  static const char * const names[] = {
    "tensor_type",
    "sequence_type",
    "map_type",
    "optional_type",
    "sparse_tensor_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace TypeProto_

inline const ::flatbuffers::TypeTable *OperatorSetIdProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "domain",
    "version"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FunctionProtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeProtoTypeTable,
    onnx::NodeProtoTypeTable,
    onnx::OperatorSetIdProtoTypeTable
  };
  static const char * const names[] = {
    "name",
    "input",
    "output",
    "attribute",
    "attribute_proto",
    "node",
    "doc_string",
    "opset_import",
    "domain"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace onnx

#endif  // FLATBUFFERS_GENERATED_ONNX_ONNX_H_
