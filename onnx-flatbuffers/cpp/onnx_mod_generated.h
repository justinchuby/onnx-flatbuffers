// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ONNXMOD_ONNX_H_
#define FLATBUFFERS_GENERATED_ONNXMOD_ONNX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace onnx {

struct Attribute;
struct AttributeBuilder;

struct IntIntListEntry;
struct IntIntListEntryBuilder;

struct NodeDeviceConfiguration;
struct NodeDeviceConfigurationBuilder;

struct ShardingSpec;
struct ShardingSpecBuilder;

struct ShardedDim;
struct ShardedDimBuilder;

struct SimpleShardedDim;
struct SimpleShardedDimBuilder;

struct TrainingInfo;
struct TrainingInfoBuilder;

struct DeviceConfiguration;
struct DeviceConfigurationBuilder;

struct StringStringEntry;
struct StringStringEntryBuilder;

struct TensorAnnotation;
struct TensorAnnotationBuilder;

struct Tensor;
struct TensorBuilder;

struct TensorSegment;
struct TensorSegmentBuilder;

struct SparseTensor;
struct SparseTensorBuilder;

struct Shape;
struct ShapeBuilder;

struct Dimension;
struct DimensionBuilder;

struct DimensionValue;
struct DimensionValueBuilder;

struct TypeInfo;
struct TypeInfoBuilder;

struct TensorType;
struct TensorTypeBuilder;

struct SequenceType;
struct SequenceTypeBuilder;

struct MapType;
struct MapTypeBuilder;

struct OptionalType;
struct OptionalTypeBuilder;

struct SparseTensorType;
struct SparseTensorTypeBuilder;

struct OperatorSetId;
struct OperatorSetIdBuilder;

struct ValueInfo;
struct ValueInfoBuilder;

struct Node;
struct NodeBuilder;

struct Graph;
struct GraphBuilder;

struct Function;
struct FunctionBuilder;

struct Model;
struct ModelBuilder;

inline const ::flatbuffers::TypeTable *AttributeTypeTable();

inline const ::flatbuffers::TypeTable *IntIntListEntryTypeTable();

inline const ::flatbuffers::TypeTable *NodeDeviceConfigurationTypeTable();

inline const ::flatbuffers::TypeTable *ShardingSpecTypeTable();

inline const ::flatbuffers::TypeTable *ShardedDimTypeTable();

inline const ::flatbuffers::TypeTable *SimpleShardedDimTypeTable();

inline const ::flatbuffers::TypeTable *TrainingInfoTypeTable();

inline const ::flatbuffers::TypeTable *DeviceConfigurationTypeTable();

inline const ::flatbuffers::TypeTable *StringStringEntryTypeTable();

inline const ::flatbuffers::TypeTable *TensorAnnotationTypeTable();

inline const ::flatbuffers::TypeTable *TensorTypeTable();

inline const ::flatbuffers::TypeTable *TensorSegmentTypeTable();

inline const ::flatbuffers::TypeTable *SparseTensorTypeTable();

inline const ::flatbuffers::TypeTable *ShapeTypeTable();

inline const ::flatbuffers::TypeTable *DimensionTypeTable();

inline const ::flatbuffers::TypeTable *DimensionValueTypeTable();

inline const ::flatbuffers::TypeTable *TypeInfoTypeTable();

inline const ::flatbuffers::TypeTable *TensorTypeTypeTable();

inline const ::flatbuffers::TypeTable *SequenceTypeTypeTable();

inline const ::flatbuffers::TypeTable *MapTypeTypeTable();

inline const ::flatbuffers::TypeTable *OptionalTypeTypeTable();

inline const ::flatbuffers::TypeTable *SparseTensorTypeTypeTable();

inline const ::flatbuffers::TypeTable *OperatorSetIdTypeTable();

inline const ::flatbuffers::TypeTable *ValueInfoTypeTable();

inline const ::flatbuffers::TypeTable *NodeTypeTable();

inline const ::flatbuffers::TypeTable *GraphTypeTable();

inline const ::flatbuffers::TypeTable *FunctionTypeTable();

inline const ::flatbuffers::TypeTable *ModelTypeTable();

enum class Version : int32_t {
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION_2017_11_3 = 3,
  IR_VERSION_2019_1_22 = 4,
  IR_VERSION_2019_3_18 = 5,
  IR_VERSION_2019_9_19 = 6,
  IR_VERSION_2020_5_8 = 7,
  IR_VERSION_2021_7_30 = 8,
  IR_VERSION_2023_5_5 = 9,
  IR_VERSION_2024_3_25 = 10,
  IR_VERSION_2025_05_12 = 11,
  IR_VERSION = 12,
  MIN = _START_VERSION,
  MAX = IR_VERSION
};

inline const Version (&EnumValuesVersion())[13] {
  static const Version values[] = {
    Version::_START_VERSION,
    Version::IR_VERSION_2017_10_10,
    Version::IR_VERSION_2017_10_30,
    Version::IR_VERSION_2017_11_3,
    Version::IR_VERSION_2019_1_22,
    Version::IR_VERSION_2019_3_18,
    Version::IR_VERSION_2019_9_19,
    Version::IR_VERSION_2020_5_8,
    Version::IR_VERSION_2021_7_30,
    Version::IR_VERSION_2023_5_5,
    Version::IR_VERSION_2024_3_25,
    Version::IR_VERSION_2025_05_12,
    Version::IR_VERSION
  };
  return values;
}

inline const char * const *EnumNamesVersion() {
  static const char * const names[14] = {
    "_START_VERSION",
    "IR_VERSION_2017_10_10",
    "IR_VERSION_2017_10_30",
    "IR_VERSION_2017_11_3",
    "IR_VERSION_2019_1_22",
    "IR_VERSION_2019_3_18",
    "IR_VERSION_2019_9_19",
    "IR_VERSION_2020_5_8",
    "IR_VERSION_2021_7_30",
    "IR_VERSION_2023_5_5",
    "IR_VERSION_2024_3_25",
    "IR_VERSION_2025_05_12",
    "IR_VERSION",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersion(Version e) {
  if (::flatbuffers::IsOutRange(e, Version::_START_VERSION, Version::IR_VERSION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVersion()[index];
}

enum class AttributeType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSOR = 11,
  SPARSE_TENSORS = 12,
  TYPE_PROTO = 13,
  TYPE_PROTOS = 14,
  MIN = UNDEFINED,
  MAX = TYPE_PROTOS
};

inline const AttributeType (&EnumValuesAttributeType())[15] {
  static const AttributeType values[] = {
    AttributeType::UNDEFINED,
    AttributeType::FLOAT,
    AttributeType::INT,
    AttributeType::STRING,
    AttributeType::TENSOR,
    AttributeType::GRAPH,
    AttributeType::FLOATS,
    AttributeType::INTS,
    AttributeType::STRINGS,
    AttributeType::TENSORS,
    AttributeType::GRAPHS,
    AttributeType::SPARSE_TENSOR,
    AttributeType::SPARSE_TENSORS,
    AttributeType::TYPE_PROTO,
    AttributeType::TYPE_PROTOS
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[16] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    "TYPE_PROTO",
    "TYPE_PROTOS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType::UNDEFINED, AttributeType::TYPE_PROTOS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum class DataType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  INT32 = 6,
  INT64 = 7,
  STRING = 8,
  BOOL = 9,
  FLOAT16 = 10,
  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,
  COMPLEX128 = 15,
  BFLOAT16 = 16,
  FLOAT8E4M3FN = 17,
  FLOAT8E4M3FNUZ = 18,
  FLOAT8E5M2 = 19,
  FLOAT8E5M2FNUZ = 20,
  UINT4 = 21,
  INT4 = 22,
  FLOAT4E2M1 = 23,
  FLOAT8E8M0 = 24,
  MIN = UNDEFINED,
  MAX = FLOAT8E8M0
};

inline const DataType (&EnumValuesDataType())[25] {
  static const DataType values[] = {
    DataType::UNDEFINED,
    DataType::FLOAT,
    DataType::UINT8,
    DataType::INT8,
    DataType::UINT16,
    DataType::INT16,
    DataType::INT32,
    DataType::INT64,
    DataType::STRING,
    DataType::BOOL,
    DataType::FLOAT16,
    DataType::DOUBLE,
    DataType::UINT32,
    DataType::UINT64,
    DataType::COMPLEX64,
    DataType::COMPLEX128,
    DataType::BFLOAT16,
    DataType::FLOAT8E4M3FN,
    DataType::FLOAT8E4M3FNUZ,
    DataType::FLOAT8E5M2,
    DataType::FLOAT8E5M2FNUZ,
    DataType::UINT4,
    DataType::INT4,
    DataType::FLOAT4E2M1,
    DataType::FLOAT8E8M0
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[26] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ",
    "UINT4",
    "INT4",
    "FLOAT4E2M1",
    "FLOAT8E8M0",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType::UNDEFINED, DataType::FLOAT8E8M0)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class TensorDataLocation : uint8_t {
  DEFAULT = 0,
  EXTERNAL = 1,
  MIN = DEFAULT,
  MAX = EXTERNAL
};

inline const TensorDataLocation (&EnumValuesTensorDataLocation())[2] {
  static const TensorDataLocation values[] = {
    TensorDataLocation::DEFAULT,
    TensorDataLocation::EXTERNAL
  };
  return values;
}

inline const char * const *EnumNamesTensorDataLocation() {
  static const char * const names[3] = {
    "DEFAULT",
    "EXTERNAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorDataLocation(TensorDataLocation e) {
  if (::flatbuffers::IsOutRange(e, TensorDataLocation::DEFAULT, TensorDataLocation::EXTERNAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorDataLocation()[index];
}

enum class OperatorStatus : uint8_t {
  EXPERIMENTAL = 0,
  STABLE = 1,
  MIN = EXPERIMENTAL,
  MAX = STABLE
};

inline const OperatorStatus (&EnumValuesOperatorStatus())[2] {
  static const OperatorStatus values[] = {
    OperatorStatus::EXPERIMENTAL,
    OperatorStatus::STABLE
  };
  return values;
}

inline const char * const *EnumNamesOperatorStatus() {
  static const char * const names[3] = {
    "EXPERIMENTAL",
    "STABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperatorStatus(OperatorStatus e) {
  if (::flatbuffers::IsOutRange(e, OperatorStatus::EXPERIMENTAL, OperatorStatus::STABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperatorStatus()[index];
}

enum class DimensionValueType : int8_t {
  UNKNOWN = 0,
  VALUE = 1,
  PARAM = 2,
  MIN = UNKNOWN,
  MAX = PARAM
};

inline const DimensionValueType (&EnumValuesDimensionValueType())[3] {
  static const DimensionValueType values[] = {
    DimensionValueType::UNKNOWN,
    DimensionValueType::VALUE,
    DimensionValueType::PARAM
  };
  return values;
}

inline const char * const *EnumNamesDimensionValueType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "VALUE",
    "PARAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionValueType(DimensionValueType e) {
  if (::flatbuffers::IsOutRange(e, DimensionValueType::UNKNOWN, DimensionValueType::PARAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionValueType()[index];
}

enum class ValueType : uint8_t {
  NONE = 0,
  tensor_type = 1,
  sequence_type = 2,
  map_type = 3,
  optional_type = 4,
  sparse_tensor_type = 5,
  MIN = NONE,
  MAX = sparse_tensor_type
};

inline const ValueType (&EnumValuesValueType())[6] {
  static const ValueType values[] = {
    ValueType::NONE,
    ValueType::tensor_type,
    ValueType::sequence_type,
    ValueType::map_type,
    ValueType::optional_type,
    ValueType::sparse_tensor_type
  };
  return values;
}

inline const char * const *EnumNamesValueType() {
  static const char * const names[7] = {
    "NONE",
    "tensor_type",
    "sequence_type",
    "map_type",
    "optional_type",
    "sparse_tensor_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueType(ValueType e) {
  if (::flatbuffers::IsOutRange(e, ValueType::NONE, ValueType::sparse_tensor_type)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueType()[index];
}

template<typename T> struct ValueTypeTraits {
  static const ValueType enum_value = ValueType::NONE;
};

template<> struct ValueTypeTraits<onnx::TensorType> {
  static const ValueType enum_value = ValueType::tensor_type;
};

template<> struct ValueTypeTraits<onnx::SequenceType> {
  static const ValueType enum_value = ValueType::sequence_type;
};

template<> struct ValueTypeTraits<onnx::MapType> {
  static const ValueType enum_value = ValueType::map_type;
};

template<> struct ValueTypeTraits<onnx::OptionalType> {
  static const ValueType enum_value = ValueType::optional_type;
};

template<> struct ValueTypeTraits<onnx::SparseTensorType> {
  static const ValueType enum_value = ValueType::sparse_tensor_type;
};

bool VerifyValueType(::flatbuffers::Verifier &verifier, const void *obj, ValueType type);
bool VerifyValueTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueType> *types);

struct Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttributeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Attribute";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_REF_ATTR_NAME = 6,
    VT_DOC_STRING = 8,
    VT_TYPE = 10,
    VT_F = 12,
    VT_I = 14,
    VT_S = 16,
    VT_T = 18,
    VT_G = 20,
    VT_SPARSE_TENSOR = 22,
    VT_TP = 24,
    VT_FLOATS = 26,
    VT_INTS = 28,
    VT_STRINGS = 30,
    VT_TENSORS = 32,
    VT_GRAPHS = 34,
    VT_SPARSE_TENSORS = 36,
    VT_TYPES = 38
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *ref_attr_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_ATTR_NAME);
  }
  ::flatbuffers::String *mutable_ref_attr_name() {
    return GetPointer<::flatbuffers::String *>(VT_REF_ATTR_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  onnx::AttributeType type() const {
    return static_cast<onnx::AttributeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool mutate_type(onnx::AttributeType _type = static_cast<onnx::AttributeType>(0)) {
    return SetField<int32_t>(VT_TYPE, static_cast<int32_t>(_type), 0);
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  bool mutate_f(float _f = 0.0f) {
    return SetField<float>(VT_F, _f, 0.0f);
  }
  int64_t i() const {
    return GetField<int64_t>(VT_I, 0);
  }
  bool mutate_i(int64_t _i = 0) {
    return SetField<int64_t>(VT_I, _i, 0);
  }
  const ::flatbuffers::String *s() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S);
  }
  ::flatbuffers::String *mutable_s() {
    return GetPointer<::flatbuffers::String *>(VT_S);
  }
  const onnx::Tensor *t() const {
    return GetPointer<const onnx::Tensor *>(VT_T);
  }
  onnx::Tensor *mutable_t() {
    return GetPointer<onnx::Tensor *>(VT_T);
  }
  const onnx::Graph *g() const {
    return GetPointer<const onnx::Graph *>(VT_G);
  }
  onnx::Graph *mutable_g() {
    return GetPointer<onnx::Graph *>(VT_G);
  }
  const onnx::SparseTensor *sparse_tensor() const {
    return GetPointer<const onnx::SparseTensor *>(VT_SPARSE_TENSOR);
  }
  onnx::SparseTensor *mutable_sparse_tensor() {
    return GetPointer<onnx::SparseTensor *>(VT_SPARSE_TENSOR);
  }
  const onnx::TypeInfo *tp() const {
    return GetPointer<const onnx::TypeInfo *>(VT_TP);
  }
  onnx::TypeInfo *mutable_tp() {
    return GetPointer<onnx::TypeInfo *>(VT_TP);
  }
  const ::flatbuffers::Vector<float> *floats() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  ::flatbuffers::Vector<float> *mutable_floats() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const ::flatbuffers::Vector<int64_t> *ints() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_ints() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_strings() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *>(VT_TENSORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *mutable_tensors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Graph>> *graphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Graph>> *>(VT_GRAPHS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Graph>> *mutable_graphs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Graph>> *>(VT_GRAPHS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *sparse_tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *>(VT_SPARSE_TENSORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *mutable_sparse_tensors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *>(VT_SPARSE_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeInfo>> *types() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeInfo>> *>(VT_TYPES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeInfo>> *mutable_types() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeInfo>> *>(VT_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REF_ATTR_NAME) &&
           verifier.VerifyString(ref_attr_name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<float>(verifier, VT_F, 4) &&
           VerifyField<int64_t>(verifier, VT_I, 8) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyTable(t()) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyTable(g()) &&
           VerifyOffset(verifier, VT_SPARSE_TENSOR) &&
           verifier.VerifyTable(sparse_tensor()) &&
           VerifyOffset(verifier, VT_TP) &&
           verifier.VerifyTable(tp()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_GRAPHS) &&
           verifier.VerifyVector(graphs()) &&
           verifier.VerifyVectorOfTables(graphs()) &&
           VerifyOffset(verifier, VT_SPARSE_TENSORS) &&
           verifier.VerifyVector(sparse_tensors()) &&
           verifier.VerifyVectorOfTables(sparse_tensors()) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           verifier.VerifyVectorOfTables(types()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_ref_attr_name(::flatbuffers::Offset<::flatbuffers::String> ref_attr_name) {
    fbb_.AddOffset(Attribute::VT_REF_ATTR_NAME, ref_attr_name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Attribute::VT_DOC_STRING, doc_string);
  }
  void add_type(onnx::AttributeType type) {
    fbb_.AddElement<int32_t>(Attribute::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attribute::VT_F, f, 0.0f);
  }
  void add_i(int64_t i) {
    fbb_.AddElement<int64_t>(Attribute::VT_I, i, 0);
  }
  void add_s(::flatbuffers::Offset<::flatbuffers::String> s) {
    fbb_.AddOffset(Attribute::VT_S, s);
  }
  void add_t(::flatbuffers::Offset<onnx::Tensor> t) {
    fbb_.AddOffset(Attribute::VT_T, t);
  }
  void add_g(::flatbuffers::Offset<onnx::Graph> g) {
    fbb_.AddOffset(Attribute::VT_G, g);
  }
  void add_sparse_tensor(::flatbuffers::Offset<onnx::SparseTensor> sparse_tensor) {
    fbb_.AddOffset(Attribute::VT_SPARSE_TENSOR, sparse_tensor);
  }
  void add_tp(::flatbuffers::Offset<onnx::TypeInfo> tp) {
    fbb_.AddOffset(Attribute::VT_TP, tp);
  }
  void add_floats(::flatbuffers::Offset<::flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attribute::VT_FLOATS, floats);
  }
  void add_ints(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> ints) {
    fbb_.AddOffset(Attribute::VT_INTS, ints);
  }
  void add_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attribute::VT_STRINGS, strings);
  }
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>>> tensors) {
    fbb_.AddOffset(Attribute::VT_TENSORS, tensors);
  }
  void add_graphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Graph>>> graphs) {
    fbb_.AddOffset(Attribute::VT_GRAPHS, graphs);
  }
  void add_sparse_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>>> sparse_tensors) {
    fbb_.AddOffset(Attribute::VT_SPARSE_TENSORS, sparse_tensors);
  }
  void add_types(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeInfo>>> types) {
    fbb_.AddOffset(Attribute::VT_TYPES, types);
  }
  explicit AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Attribute> CreateAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ref_attr_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    onnx::AttributeType type = onnx::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    ::flatbuffers::Offset<::flatbuffers::String> s = 0,
    ::flatbuffers::Offset<onnx::Tensor> t = 0,
    ::flatbuffers::Offset<onnx::Graph> g = 0,
    ::flatbuffers::Offset<onnx::SparseTensor> sparse_tensor = 0,
    ::flatbuffers::Offset<onnx::TypeInfo> tp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> floats = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> ints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Graph>>> graphs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>>> sparse_tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TypeInfo>>> types = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_i(i);
  builder_.add_types(types);
  builder_.add_sparse_tensors(sparse_tensors);
  builder_.add_graphs(graphs);
  builder_.add_tensors(tensors);
  builder_.add_strings(strings);
  builder_.add_ints(ints);
  builder_.add_floats(floats);
  builder_.add_tp(tp);
  builder_.add_sparse_tensor(sparse_tensor);
  builder_.add_g(g);
  builder_.add_t(t);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_ref_attr_name(ref_attr_name);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Attribute::Traits {
  using type = Attribute;
  static auto constexpr Create = CreateAttribute;
};

inline ::flatbuffers::Offset<Attribute> CreateAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *ref_attr_name = nullptr,
    const char *doc_string = nullptr,
    onnx::AttributeType type = onnx::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    const char *s = nullptr,
    ::flatbuffers::Offset<onnx::Tensor> t = 0,
    ::flatbuffers::Offset<onnx::Graph> g = 0,
    ::flatbuffers::Offset<onnx::SparseTensor> sparse_tensor = 0,
    ::flatbuffers::Offset<onnx::TypeInfo> tp = 0,
    const std::vector<float> *floats = nullptr,
    const std::vector<int64_t> *ints = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *strings = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Tensor>> *tensors = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Graph>> *graphs = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::SparseTensor>> *sparse_tensors = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TypeInfo>> *types = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto ref_attr_name__ = ref_attr_name ? _fbb.CreateString(ref_attr_name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int64_t>(*ints) : 0;
  auto strings__ = strings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*strings) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Tensor>>(*tensors) : 0;
  auto graphs__ = graphs ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Graph>>(*graphs) : 0;
  auto sparse_tensors__ = sparse_tensors ? _fbb.CreateVector<::flatbuffers::Offset<onnx::SparseTensor>>(*sparse_tensors) : 0;
  auto types__ = types ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TypeInfo>>(*types) : 0;
  return onnx::CreateAttribute(
      _fbb,
      name__,
      ref_attr_name__,
      doc_string__,
      type,
      f,
      i,
      s__,
      t,
      g,
      sparse_tensor,
      tp,
      floats__,
      ints__,
      strings__,
      tensors__,
      graphs__,
      sparse_tensors__,
      types__);
}

struct IntIntListEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntIntListEntryBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntIntListEntryTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.IntIntListEntry";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key = 0) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  const ::flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<int64_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY, 8) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct IntIntListEntryBuilder {
  typedef IntIntListEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(IntIntListEntry::VT_KEY, key, 0);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(IntIntListEntry::VT_VALUE, value);
  }
  explicit IntIntListEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntIntListEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntIntListEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntIntListEntry> CreateIntIntListEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> value = 0) {
  IntIntListEntryBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntIntListEntry::Traits {
  using type = IntIntListEntry;
  static auto constexpr Create = CreateIntIntListEntry;
};

inline ::flatbuffers::Offset<IntIntListEntry> CreateIntIntListEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    const std::vector<int64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int64_t>(*value) : 0;
  return onnx::CreateIntIntListEntry(
      _fbb,
      key,
      value__);
}

struct NodeDeviceConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeDeviceConfigurationBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodeDeviceConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.NodeDeviceConfiguration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIGURATION_ID = 4,
    VT_SHARDING_SPEC = 6,
    VT_PIPELINE_STAGE = 8
  };
  const ::flatbuffers::String *configuration_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONFIGURATION_ID);
  }
  ::flatbuffers::String *mutable_configuration_id() {
    return GetPointer<::flatbuffers::String *>(VT_CONFIGURATION_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardingSpec>> *sharding_spec() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardingSpec>> *>(VT_SHARDING_SPEC);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardingSpec>> *mutable_sharding_spec() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardingSpec>> *>(VT_SHARDING_SPEC);
  }
  int32_t pipeline_stage() const {
    return GetField<int32_t>(VT_PIPELINE_STAGE, 0);
  }
  bool mutate_pipeline_stage(int32_t _pipeline_stage = 0) {
    return SetField<int32_t>(VT_PIPELINE_STAGE, _pipeline_stage, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIGURATION_ID) &&
           verifier.VerifyString(configuration_id()) &&
           VerifyOffset(verifier, VT_SHARDING_SPEC) &&
           verifier.VerifyVector(sharding_spec()) &&
           verifier.VerifyVectorOfTables(sharding_spec()) &&
           VerifyField<int32_t>(verifier, VT_PIPELINE_STAGE, 4) &&
           verifier.EndTable();
  }
};

struct NodeDeviceConfigurationBuilder {
  typedef NodeDeviceConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_configuration_id(::flatbuffers::Offset<::flatbuffers::String> configuration_id) {
    fbb_.AddOffset(NodeDeviceConfiguration::VT_CONFIGURATION_ID, configuration_id);
  }
  void add_sharding_spec(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardingSpec>>> sharding_spec) {
    fbb_.AddOffset(NodeDeviceConfiguration::VT_SHARDING_SPEC, sharding_spec);
  }
  void add_pipeline_stage(int32_t pipeline_stage) {
    fbb_.AddElement<int32_t>(NodeDeviceConfiguration::VT_PIPELINE_STAGE, pipeline_stage, 0);
  }
  explicit NodeDeviceConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeDeviceConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeDeviceConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeDeviceConfiguration> CreateNodeDeviceConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> configuration_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardingSpec>>> sharding_spec = 0,
    int32_t pipeline_stage = 0) {
  NodeDeviceConfigurationBuilder builder_(_fbb);
  builder_.add_pipeline_stage(pipeline_stage);
  builder_.add_sharding_spec(sharding_spec);
  builder_.add_configuration_id(configuration_id);
  return builder_.Finish();
}

struct NodeDeviceConfiguration::Traits {
  using type = NodeDeviceConfiguration;
  static auto constexpr Create = CreateNodeDeviceConfiguration;
};

inline ::flatbuffers::Offset<NodeDeviceConfiguration> CreateNodeDeviceConfigurationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *configuration_id = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ShardingSpec>> *sharding_spec = nullptr,
    int32_t pipeline_stage = 0) {
  auto configuration_id__ = configuration_id ? _fbb.CreateString(configuration_id) : 0;
  auto sharding_spec__ = sharding_spec ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ShardingSpec>>(*sharding_spec) : 0;
  return onnx::CreateNodeDeviceConfiguration(
      _fbb,
      configuration_id__,
      sharding_spec__,
      pipeline_stage);
}

struct ShardingSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShardingSpecBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShardingSpecTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.ShardingSpec";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR_NAME = 4,
    VT_DEVICE = 6,
    VT_INDEX_TO_DEVICE_GROUP_MAP = 8,
    VT_SHARDED_DIM = 10
  };
  const ::flatbuffers::String *tensor_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TENSOR_NAME);
  }
  ::flatbuffers::String *mutable_tensor_name() {
    return GetPointer<::flatbuffers::String *>(VT_TENSOR_NAME);
  }
  const ::flatbuffers::Vector<int64_t> *device() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DEVICE);
  }
  ::flatbuffers::Vector<int64_t> *mutable_device() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DEVICE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::IntIntListEntry>> *index_to_device_group_map() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::IntIntListEntry>> *>(VT_INDEX_TO_DEVICE_GROUP_MAP);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::IntIntListEntry>> *mutable_index_to_device_group_map() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::IntIntListEntry>> *>(VT_INDEX_TO_DEVICE_GROUP_MAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardedDim>> *sharded_dim() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardedDim>> *>(VT_SHARDED_DIM);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardedDim>> *mutable_sharded_dim() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardedDim>> *>(VT_SHARDED_DIM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSOR_NAME) &&
           verifier.VerifyString(tensor_name()) &&
           VerifyOffset(verifier, VT_DEVICE) &&
           verifier.VerifyVector(device()) &&
           VerifyOffset(verifier, VT_INDEX_TO_DEVICE_GROUP_MAP) &&
           verifier.VerifyVector(index_to_device_group_map()) &&
           verifier.VerifyVectorOfTables(index_to_device_group_map()) &&
           VerifyOffset(verifier, VT_SHARDED_DIM) &&
           verifier.VerifyVector(sharded_dim()) &&
           verifier.VerifyVectorOfTables(sharded_dim()) &&
           verifier.EndTable();
  }
};

struct ShardingSpecBuilder {
  typedef ShardingSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensor_name(::flatbuffers::Offset<::flatbuffers::String> tensor_name) {
    fbb_.AddOffset(ShardingSpec::VT_TENSOR_NAME, tensor_name);
  }
  void add_device(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> device) {
    fbb_.AddOffset(ShardingSpec::VT_DEVICE, device);
  }
  void add_index_to_device_group_map(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::IntIntListEntry>>> index_to_device_group_map) {
    fbb_.AddOffset(ShardingSpec::VT_INDEX_TO_DEVICE_GROUP_MAP, index_to_device_group_map);
  }
  void add_sharded_dim(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardedDim>>> sharded_dim) {
    fbb_.AddOffset(ShardingSpec::VT_SHARDED_DIM, sharded_dim);
  }
  explicit ShardingSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShardingSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShardingSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShardingSpec> CreateShardingSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> tensor_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> device = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::IntIntListEntry>>> index_to_device_group_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ShardedDim>>> sharded_dim = 0) {
  ShardingSpecBuilder builder_(_fbb);
  builder_.add_sharded_dim(sharded_dim);
  builder_.add_index_to_device_group_map(index_to_device_group_map);
  builder_.add_device(device);
  builder_.add_tensor_name(tensor_name);
  return builder_.Finish();
}

struct ShardingSpec::Traits {
  using type = ShardingSpec;
  static auto constexpr Create = CreateShardingSpec;
};

inline ::flatbuffers::Offset<ShardingSpec> CreateShardingSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *tensor_name = nullptr,
    const std::vector<int64_t> *device = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::IntIntListEntry>> *index_to_device_group_map = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ShardedDim>> *sharded_dim = nullptr) {
  auto tensor_name__ = tensor_name ? _fbb.CreateString(tensor_name) : 0;
  auto device__ = device ? _fbb.CreateVector<int64_t>(*device) : 0;
  auto index_to_device_group_map__ = index_to_device_group_map ? _fbb.CreateVector<::flatbuffers::Offset<onnx::IntIntListEntry>>(*index_to_device_group_map) : 0;
  auto sharded_dim__ = sharded_dim ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ShardedDim>>(*sharded_dim) : 0;
  return onnx::CreateShardingSpec(
      _fbb,
      tensor_name__,
      device__,
      index_to_device_group_map__,
      sharded_dim__);
}

struct ShardedDim FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShardedDimBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShardedDimTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.ShardedDim";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SIMPLE_SHARDING = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis = 0) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SimpleShardedDim>> *simple_sharding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SimpleShardedDim>> *>(VT_SIMPLE_SHARDING);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SimpleShardedDim>> *mutable_simple_sharding() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SimpleShardedDim>> *>(VT_SIMPLE_SHARDING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyOffset(verifier, VT_SIMPLE_SHARDING) &&
           verifier.VerifyVector(simple_sharding()) &&
           verifier.VerifyVectorOfTables(simple_sharding()) &&
           verifier.EndTable();
  }
};

struct ShardedDimBuilder {
  typedef ShardedDim Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ShardedDim::VT_AXIS, axis, 0);
  }
  void add_simple_sharding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SimpleShardedDim>>> simple_sharding) {
    fbb_.AddOffset(ShardedDim::VT_SIMPLE_SHARDING, simple_sharding);
  }
  explicit ShardedDimBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShardedDim> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShardedDim>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShardedDim> CreateShardedDim(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SimpleShardedDim>>> simple_sharding = 0) {
  ShardedDimBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_simple_sharding(simple_sharding);
  return builder_.Finish();
}

struct ShardedDim::Traits {
  using type = ShardedDim;
  static auto constexpr Create = CreateShardedDim;
};

inline ::flatbuffers::Offset<ShardedDim> CreateShardedDimDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<::flatbuffers::Offset<onnx::SimpleShardedDim>> *simple_sharding = nullptr) {
  auto simple_sharding__ = simple_sharding ? _fbb.CreateVector<::flatbuffers::Offset<onnx::SimpleShardedDim>>(*simple_sharding) : 0;
  return onnx::CreateShardedDim(
      _fbb,
      axis,
      simple_sharding__);
}

struct SimpleShardedDim FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SimpleShardedDimBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SimpleShardedDimTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.SimpleShardedDim";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_NUM_SHARDS = 6
  };
  const onnx::DimensionValue *dim() const {
    return GetPointer<const onnx::DimensionValue *>(VT_DIM);
  }
  onnx::DimensionValue *mutable_dim() {
    return GetPointer<onnx::DimensionValue *>(VT_DIM);
  }
  int64_t num_shards() const {
    return GetField<int64_t>(VT_NUM_SHARDS, 0);
  }
  bool mutate_num_shards(int64_t _num_shards = 0) {
    return SetField<int64_t>(VT_NUM_SHARDS, _num_shards, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyTable(dim()) &&
           VerifyField<int64_t>(verifier, VT_NUM_SHARDS, 8) &&
           verifier.EndTable();
  }
};

struct SimpleShardedDimBuilder {
  typedef SimpleShardedDim Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<onnx::DimensionValue> dim) {
    fbb_.AddOffset(SimpleShardedDim::VT_DIM, dim);
  }
  void add_num_shards(int64_t num_shards) {
    fbb_.AddElement<int64_t>(SimpleShardedDim::VT_NUM_SHARDS, num_shards, 0);
  }
  explicit SimpleShardedDimBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SimpleShardedDim> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SimpleShardedDim>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SimpleShardedDim> CreateSimpleShardedDim(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::DimensionValue> dim = 0,
    int64_t num_shards = 0) {
  SimpleShardedDimBuilder builder_(_fbb);
  builder_.add_num_shards(num_shards);
  builder_.add_dim(dim);
  return builder_.Finish();
}

struct SimpleShardedDim::Traits {
  using type = SimpleShardedDim;
  static auto constexpr Create = CreateSimpleShardedDim;
};

struct TrainingInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrainingInfoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TrainingInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TrainingInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INITIALIZATION = 4,
    VT_ALGORITHM = 6,
    VT_INITIALIZATION_BINDING = 8,
    VT_UPDATE_BINDING = 10
  };
  const onnx::Graph *initialization() const {
    return GetPointer<const onnx::Graph *>(VT_INITIALIZATION);
  }
  onnx::Graph *mutable_initialization() {
    return GetPointer<onnx::Graph *>(VT_INITIALIZATION);
  }
  const onnx::Graph *algorithm() const {
    return GetPointer<const onnx::Graph *>(VT_ALGORITHM);
  }
  onnx::Graph *mutable_algorithm() {
    return GetPointer<onnx::Graph *>(VT_ALGORITHM);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *initialization_binding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_INITIALIZATION_BINDING);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_initialization_binding() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_INITIALIZATION_BINDING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *update_binding() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_UPDATE_BINDING);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_update_binding() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_UPDATE_BINDING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INITIALIZATION) &&
           verifier.VerifyTable(initialization()) &&
           VerifyOffset(verifier, VT_ALGORITHM) &&
           verifier.VerifyTable(algorithm()) &&
           VerifyOffset(verifier, VT_INITIALIZATION_BINDING) &&
           verifier.VerifyVector(initialization_binding()) &&
           verifier.VerifyVectorOfTables(initialization_binding()) &&
           VerifyOffset(verifier, VT_UPDATE_BINDING) &&
           verifier.VerifyVector(update_binding()) &&
           verifier.VerifyVectorOfTables(update_binding()) &&
           verifier.EndTable();
  }
};

struct TrainingInfoBuilder {
  typedef TrainingInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_initialization(::flatbuffers::Offset<onnx::Graph> initialization) {
    fbb_.AddOffset(TrainingInfo::VT_INITIALIZATION, initialization);
  }
  void add_algorithm(::flatbuffers::Offset<onnx::Graph> algorithm) {
    fbb_.AddOffset(TrainingInfo::VT_ALGORITHM, algorithm);
  }
  void add_initialization_binding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> initialization_binding) {
    fbb_.AddOffset(TrainingInfo::VT_INITIALIZATION_BINDING, initialization_binding);
  }
  void add_update_binding(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> update_binding) {
    fbb_.AddOffset(TrainingInfo::VT_UPDATE_BINDING, update_binding);
  }
  explicit TrainingInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrainingInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrainingInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrainingInfo> CreateTrainingInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::Graph> initialization = 0,
    ::flatbuffers::Offset<onnx::Graph> algorithm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> initialization_binding = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> update_binding = 0) {
  TrainingInfoBuilder builder_(_fbb);
  builder_.add_update_binding(update_binding);
  builder_.add_initialization_binding(initialization_binding);
  builder_.add_algorithm(algorithm);
  builder_.add_initialization(initialization);
  return builder_.Finish();
}

struct TrainingInfo::Traits {
  using type = TrainingInfo;
  static auto constexpr Create = CreateTrainingInfo;
};

inline ::flatbuffers::Offset<TrainingInfo> CreateTrainingInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::Graph> initialization = 0,
    ::flatbuffers::Offset<onnx::Graph> algorithm = 0,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *initialization_binding = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *update_binding = nullptr) {
  auto initialization_binding__ = initialization_binding ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*initialization_binding) : 0;
  auto update_binding__ = update_binding ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*update_binding) : 0;
  return onnx::CreateTrainingInfo(
      _fbb,
      initialization,
      algorithm,
      initialization_binding__,
      update_binding__);
}

struct DeviceConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceConfigurationBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeviceConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.DeviceConfiguration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NUM_DEVICES = 6,
    VT_DEVICE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  int32_t num_devices() const {
    return GetField<int32_t>(VT_NUM_DEVICES, 0);
  }
  bool mutate_num_devices(int32_t _num_devices = 0) {
    return SetField<int32_t>(VT_NUM_DEVICES, _num_devices, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *device() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DEVICE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_device() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DEVICE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NUM_DEVICES, 4) &&
           VerifyOffset(verifier, VT_DEVICE) &&
           verifier.VerifyVector(device()) &&
           verifier.VerifyVectorOfStrings(device()) &&
           verifier.EndTable();
  }
};

struct DeviceConfigurationBuilder {
  typedef DeviceConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DeviceConfiguration::VT_NAME, name);
  }
  void add_num_devices(int32_t num_devices) {
    fbb_.AddElement<int32_t>(DeviceConfiguration::VT_NUM_DEVICES, num_devices, 0);
  }
  void add_device(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> device) {
    fbb_.AddOffset(DeviceConfiguration::VT_DEVICE, device);
  }
  explicit DeviceConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceConfiguration> CreateDeviceConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t num_devices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> device = 0) {
  DeviceConfigurationBuilder builder_(_fbb);
  builder_.add_device(device);
  builder_.add_num_devices(num_devices);
  builder_.add_name(name);
  return builder_.Finish();
}

struct DeviceConfiguration::Traits {
  using type = DeviceConfiguration;
  static auto constexpr Create = CreateDeviceConfiguration;
};

inline ::flatbuffers::Offset<DeviceConfiguration> CreateDeviceConfigurationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t num_devices = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *device = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto device__ = device ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*device) : 0;
  return onnx::CreateDeviceConfiguration(
      _fbb,
      name__,
      num_devices,
      device__);
}

struct StringStringEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringStringEntryBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringStringEntryTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.StringStringEntry";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringStringEntryBuilder {
  typedef StringStringEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(StringStringEntry::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringStringEntry::VT_VALUE, value);
  }
  explicit StringStringEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringStringEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringStringEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringStringEntry> CreateStringStringEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringStringEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct StringStringEntry::Traits {
  using type = StringStringEntry;
  static auto constexpr Create = CreateStringStringEntry;
};

inline ::flatbuffers::Offset<StringStringEntry> CreateStringStringEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return onnx::CreateStringStringEntry(
      _fbb,
      key__,
      value__);
}

struct TensorAnnotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorAnnotationBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorAnnotationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorAnnotation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR_NAME = 4,
    VT_QUANT_PARAMETER_TENSOR_NAMES = 6
  };
  const ::flatbuffers::String *tensor_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TENSOR_NAME);
  }
  ::flatbuffers::String *mutable_tensor_name() {
    return GetPointer<::flatbuffers::String *>(VT_TENSOR_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *quant_parameter_tensor_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_QUANT_PARAMETER_TENSOR_NAMES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_quant_parameter_tensor_names() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_QUANT_PARAMETER_TENSOR_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSOR_NAME) &&
           verifier.VerifyString(tensor_name()) &&
           VerifyOffset(verifier, VT_QUANT_PARAMETER_TENSOR_NAMES) &&
           verifier.VerifyVector(quant_parameter_tensor_names()) &&
           verifier.VerifyVectorOfTables(quant_parameter_tensor_names()) &&
           verifier.EndTable();
  }
};

struct TensorAnnotationBuilder {
  typedef TensorAnnotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensor_name(::flatbuffers::Offset<::flatbuffers::String> tensor_name) {
    fbb_.AddOffset(TensorAnnotation::VT_TENSOR_NAME, tensor_name);
  }
  void add_quant_parameter_tensor_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> quant_parameter_tensor_names) {
    fbb_.AddOffset(TensorAnnotation::VT_QUANT_PARAMETER_TENSOR_NAMES, quant_parameter_tensor_names);
  }
  explicit TensorAnnotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorAnnotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorAnnotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorAnnotation> CreateTensorAnnotation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> tensor_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> quant_parameter_tensor_names = 0) {
  TensorAnnotationBuilder builder_(_fbb);
  builder_.add_quant_parameter_tensor_names(quant_parameter_tensor_names);
  builder_.add_tensor_name(tensor_name);
  return builder_.Finish();
}

struct TensorAnnotation::Traits {
  using type = TensorAnnotation;
  static auto constexpr Create = CreateTensorAnnotation;
};

inline ::flatbuffers::Offset<TensorAnnotation> CreateTensorAnnotationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *tensor_name = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *quant_parameter_tensor_names = nullptr) {
  auto tensor_name__ = tensor_name ? _fbb.CreateString(tensor_name) : 0;
  auto quant_parameter_tensor_names__ = quant_parameter_tensor_names ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*quant_parameter_tensor_names) : 0;
  return onnx::CreateTensorAnnotation(
      _fbb,
      tensor_name__,
      quant_parameter_tensor_names__);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Tensor";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DIMS = 8,
    VT_DATA_TYPE = 10,
    VT_RAW_DATA = 12,
    VT_STRING_DATA = 14,
    VT_EXTERNAL_DATA = 16,
    VT_DATA_LOCATION = 18,
    VT_METADATA_PROPS = 20
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  onnx::DataType data_type() const {
    return static_cast<onnx::DataType>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  bool mutate_data_type(onnx::DataType _data_type = static_cast<onnx::DataType>(0)) {
    return SetField<int32_t>(VT_DATA_TYPE, static_cast<int32_t>(_data_type), 0);
  }
  const ::flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_raw_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_string_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *external_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_EXTERNAL_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_external_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_EXTERNAL_DATA);
  }
  onnx::TensorDataLocation data_location() const {
    return static_cast<onnx::TensorDataLocation>(GetField<uint8_t>(VT_DATA_LOCATION, 0));
  }
  bool mutate_data_location(onnx::TensorDataLocation _data_location = static_cast<onnx::TensorDataLocation>(0)) {
    return SetField<uint8_t>(VT_DATA_LOCATION, static_cast<uint8_t>(_data_location), 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE, 4) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           VerifyOffset(verifier, VT_STRING_DATA) &&
           verifier.VerifyVector(string_data()) &&
           verifier.VerifyVectorOfStrings(string_data()) &&
           VerifyOffset(verifier, VT_EXTERNAL_DATA) &&
           verifier.VerifyVector(external_data()) &&
           verifier.VerifyVectorOfTables(external_data()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_LOCATION, 1) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Tensor::VT_DOC_STRING, doc_string);
  }
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_data_type(onnx::DataType data_type) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_raw_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(Tensor::VT_RAW_DATA, raw_data);
  }
  void add_string_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_data) {
    fbb_.AddOffset(Tensor::VT_STRING_DATA, string_data);
  }
  void add_external_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> external_data) {
    fbb_.AddOffset(Tensor::VT_EXTERNAL_DATA, external_data);
  }
  void add_data_location(onnx::TensorDataLocation data_location) {
    fbb_.AddElement<uint8_t>(Tensor::VT_DATA_LOCATION, static_cast<uint8_t>(data_location), 0);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Tensor::VT_METADATA_PROPS, metadata_props);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0,
    onnx::DataType data_type = onnx::DataType::UNDEFINED,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> external_data = 0,
    onnx::TensorDataLocation data_location = onnx::TensorDataLocation::DEFAULT,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_metadata_props(metadata_props);
  builder_.add_external_data(external_data);
  builder_.add_string_data(string_data);
  builder_.add_raw_data(raw_data);
  builder_.add_data_type(data_type);
  builder_.add_dims(dims);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  builder_.add_data_location(data_location);
  return builder_.Finish();
}

struct Tensor::Traits {
  using type = Tensor;
  static auto constexpr Create = CreateTensor;
};

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const std::vector<int64_t> *dims = nullptr,
    onnx::DataType data_type = onnx::DataType::UNDEFINED,
    const std::vector<uint8_t> *raw_data = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_data = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *external_data = nullptr,
    onnx::TensorDataLocation data_location = onnx::TensorDataLocation::DEFAULT,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  auto string_data__ = string_data ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_data) : 0;
  auto external_data__ = external_data ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*external_data) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*metadata_props) : 0;
  return onnx::CreateTensor(
      _fbb,
      name__,
      doc_string__,
      dims__,
      data_type,
      raw_data__,
      string_data__,
      external_data__,
      data_location,
      metadata_props__);
}

struct TensorSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorSegmentBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorSegmentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorSegment";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN = 4,
    VT_END = 6
  };
  int64_t begin() const {
    return GetField<int64_t>(VT_BEGIN, 0);
  }
  bool mutate_begin(int64_t _begin = 0) {
    return SetField<int64_t>(VT_BEGIN, _begin, 0);
  }
  int64_t end() const {
    return GetField<int64_t>(VT_END, 0);
  }
  bool mutate_end(int64_t _end = 0) {
    return SetField<int64_t>(VT_END, _end, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN, 8) &&
           VerifyField<int64_t>(verifier, VT_END, 8) &&
           verifier.EndTable();
  }
};

struct TensorSegmentBuilder {
  typedef TensorSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_begin(int64_t begin) {
    fbb_.AddElement<int64_t>(TensorSegment::VT_BEGIN, begin, 0);
  }
  void add_end(int64_t end) {
    fbb_.AddElement<int64_t>(TensorSegment::VT_END, end, 0);
  }
  explicit TensorSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorSegment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorSegment> CreateTensorSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin = 0,
    int64_t end = 0) {
  TensorSegmentBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_begin(begin);
  return builder_.Finish();
}

struct TensorSegment::Traits {
  using type = TensorSegment;
  static auto constexpr Create = CreateTensorSegment;
};

struct SparseTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparseTensorBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseTensorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.SparseTensor";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_INDICES = 6,
    VT_DIMS = 8
  };
  const onnx::Tensor *values() const {
    return GetPointer<const onnx::Tensor *>(VT_VALUES);
  }
  onnx::Tensor *mutable_values() {
    return GetPointer<onnx::Tensor *>(VT_VALUES);
  }
  const onnx::Tensor *indices() const {
    return GetPointer<const onnx::Tensor *>(VT_INDICES);
  }
  onnx::Tensor *mutable_indices() {
    return GetPointer<onnx::Tensor *>(VT_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyTable(values()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyTable(indices()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct SparseTensorBuilder {
  typedef SparseTensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<onnx::Tensor> values) {
    fbb_.AddOffset(SparseTensor::VT_VALUES, values);
  }
  void add_indices(::flatbuffers::Offset<onnx::Tensor> indices) {
    fbb_.AddOffset(SparseTensor::VT_INDICES, indices);
  }
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(SparseTensor::VT_DIMS, dims);
  }
  explicit SparseTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseTensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseTensor> CreateSparseTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::Tensor> values = 0,
    ::flatbuffers::Offset<onnx::Tensor> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0) {
  SparseTensorBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_indices(indices);
  builder_.add_values(values);
  return builder_.Finish();
}

struct SparseTensor::Traits {
  using type = SparseTensor;
  static auto constexpr Create = CreateSparseTensor;
};

inline ::flatbuffers::Offset<SparseTensor> CreateSparseTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::Tensor> values = 0,
    ::flatbuffers::Offset<onnx::Tensor> indices = 0,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return onnx::CreateSparseTensor(
      _fbb,
      values,
      indices,
      dims__);
}

struct Shape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShapeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Shape";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Dimension>> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Dimension>> *>(VT_DIM);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Dimension>> *mutable_dim() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Dimension>> *>(VT_DIM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.VerifyVectorOfTables(dim()) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  typedef Shape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Dimension>>> dim) {
    fbb_.AddOffset(Shape::VT_DIM, dim);
  }
  explicit ShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Shape> CreateShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Dimension>>> dim = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

struct Shape::Traits {
  using type = Shape;
  static auto constexpr Create = CreateShape;
};

inline ::flatbuffers::Offset<Shape> CreateShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<onnx::Dimension>> *dim = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Dimension>>(*dim) : 0;
  return onnx::CreateShape(
      _fbb,
      dim__);
}

struct Dimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DimensionBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimensionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Dimension";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DENOTATION = 6
  };
  const onnx::DimensionValue *value() const {
    return GetPointer<const onnx::DimensionValue *>(VT_VALUE);
  }
  onnx::DimensionValue *mutable_value() {
    return GetPointer<onnx::DimensionValue *>(VT_VALUE);
  }
  const ::flatbuffers::String *denotation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DENOTATION);
  }
  ::flatbuffers::String *mutable_denotation() {
    return GetPointer<::flatbuffers::String *>(VT_DENOTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
};

struct DimensionBuilder {
  typedef Dimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<onnx::DimensionValue> value) {
    fbb_.AddOffset(Dimension::VT_VALUE, value);
  }
  void add_denotation(::flatbuffers::Offset<::flatbuffers::String> denotation) {
    fbb_.AddOffset(Dimension::VT_DENOTATION, denotation);
  }
  explicit DimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dimension>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Dimension> CreateDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::DimensionValue> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> denotation = 0) {
  DimensionBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Dimension::Traits {
  using type = Dimension;
  static auto constexpr Create = CreateDimension;
};

inline ::flatbuffers::Offset<Dimension> CreateDimensionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnx::DimensionValue> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnx::CreateDimension(
      _fbb,
      value,
      denotation__);
}

struct DimensionValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DimensionValueBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimensionValueTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.DimensionValue";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM_TYPE = 4,
    VT_DIM_VALUE = 6,
    VT_DIM_PARAM = 8
  };
  onnx::DimensionValueType dim_type() const {
    return static_cast<onnx::DimensionValueType>(GetField<int8_t>(VT_DIM_TYPE, 0));
  }
  bool mutate_dim_type(onnx::DimensionValueType _dim_type = static_cast<onnx::DimensionValueType>(0)) {
    return SetField<int8_t>(VT_DIM_TYPE, static_cast<int8_t>(_dim_type), 0);
  }
  int64_t dim_value() const {
    return GetField<int64_t>(VT_DIM_VALUE, 0);
  }
  bool mutate_dim_value(int64_t _dim_value = 0) {
    return SetField<int64_t>(VT_DIM_VALUE, _dim_value, 0);
  }
  const ::flatbuffers::String *dim_param() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIM_PARAM);
  }
  ::flatbuffers::String *mutable_dim_param() {
    return GetPointer<::flatbuffers::String *>(VT_DIM_PARAM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DIM_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_DIM_VALUE, 8) &&
           VerifyOffset(verifier, VT_DIM_PARAM) &&
           verifier.VerifyString(dim_param()) &&
           verifier.EndTable();
  }
};

struct DimensionValueBuilder {
  typedef DimensionValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim_type(onnx::DimensionValueType dim_type) {
    fbb_.AddElement<int8_t>(DimensionValue::VT_DIM_TYPE, static_cast<int8_t>(dim_type), 0);
  }
  void add_dim_value(int64_t dim_value) {
    fbb_.AddElement<int64_t>(DimensionValue::VT_DIM_VALUE, dim_value, 0);
  }
  void add_dim_param(::flatbuffers::Offset<::flatbuffers::String> dim_param) {
    fbb_.AddOffset(DimensionValue::VT_DIM_PARAM, dim_param);
  }
  explicit DimensionValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DimensionValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DimensionValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DimensionValue> CreateDimensionValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::DimensionValueType dim_type = onnx::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dim_param = 0) {
  DimensionValueBuilder builder_(_fbb);
  builder_.add_dim_value(dim_value);
  builder_.add_dim_param(dim_param);
  builder_.add_dim_type(dim_type);
  return builder_.Finish();
}

struct DimensionValue::Traits {
  using type = DimensionValue;
  static auto constexpr Create = CreateDimensionValue;
};

inline ::flatbuffers::Offset<DimensionValue> CreateDimensionValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::DimensionValueType dim_type = onnx::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    const char *dim_param = nullptr) {
  auto dim_param__ = dim_param ? _fbb.CreateString(dim_param) : 0;
  return onnx::CreateDimensionValue(
      _fbb,
      dim_type,
      dim_value,
      dim_param__);
}

struct TypeInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TypeInfoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TypeInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TypeInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6,
    VT_DENOTATION = 8
  };
  onnx::ValueType value_type() const {
    return static_cast<onnx::ValueType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const onnx::TensorType *value_as_tensor_type() const {
    return value_type() == onnx::ValueType::tensor_type ? static_cast<const onnx::TensorType *>(value()) : nullptr;
  }
  const onnx::SequenceType *value_as_sequence_type() const {
    return value_type() == onnx::ValueType::sequence_type ? static_cast<const onnx::SequenceType *>(value()) : nullptr;
  }
  const onnx::MapType *value_as_map_type() const {
    return value_type() == onnx::ValueType::map_type ? static_cast<const onnx::MapType *>(value()) : nullptr;
  }
  const onnx::OptionalType *value_as_optional_type() const {
    return value_type() == onnx::ValueType::optional_type ? static_cast<const onnx::OptionalType *>(value()) : nullptr;
  }
  const onnx::SparseTensorType *value_as_sparse_tensor_type() const {
    return value_type() == onnx::ValueType::sparse_tensor_type ? static_cast<const onnx::SparseTensorType *>(value()) : nullptr;
  }
  void *mutable_value() {
    return GetPointer<void *>(VT_VALUE);
  }
  const ::flatbuffers::String *denotation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DENOTATION);
  }
  ::flatbuffers::String *mutable_denotation() {
    return GetPointer<::flatbuffers::String *>(VT_DENOTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueType(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
};

template<> inline const onnx::TensorType *TypeInfo::value_as<onnx::TensorType>() const {
  return value_as_tensor_type();
}

template<> inline const onnx::SequenceType *TypeInfo::value_as<onnx::SequenceType>() const {
  return value_as_sequence_type();
}

template<> inline const onnx::MapType *TypeInfo::value_as<onnx::MapType>() const {
  return value_as_map_type();
}

template<> inline const onnx::OptionalType *TypeInfo::value_as<onnx::OptionalType>() const {
  return value_as_optional_type();
}

template<> inline const onnx::SparseTensorType *TypeInfo::value_as<onnx::SparseTensorType>() const {
  return value_as_sparse_tensor_type();
}

struct TypeInfoBuilder {
  typedef TypeInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(onnx::ValueType value_type) {
    fbb_.AddElement<uint8_t>(TypeInfo::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TypeInfo::VT_VALUE, value);
  }
  void add_denotation(::flatbuffers::Offset<::flatbuffers::String> denotation) {
    fbb_.AddOffset(TypeInfo::VT_DENOTATION, denotation);
  }
  explicit TypeInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TypeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TypeInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TypeInfo> CreateTypeInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::ValueType value_type = onnx::ValueType::NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> denotation = 0) {
  TypeInfoBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct TypeInfo::Traits {
  using type = TypeInfo;
  static auto constexpr Create = CreateTypeInfo;
};

inline ::flatbuffers::Offset<TypeInfo> CreateTypeInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::ValueType value_type = onnx::ValueType::NONE,
    ::flatbuffers::Offset<void> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnx::CreateTypeInfo(
      _fbb,
      value_type,
      value,
      denotation__);
}

struct TensorType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.TensorType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  onnx::DataType elem_type() const {
    return static_cast<onnx::DataType>(GetField<int32_t>(VT_ELEM_TYPE, 0));
  }
  bool mutate_elem_type(onnx::DataType _elem_type = static_cast<onnx::DataType>(0)) {
    return SetField<int32_t>(VT_ELEM_TYPE, static_cast<int32_t>(_elem_type), 0);
  }
  const onnx::Shape *shape() const {
    return GetPointer<const onnx::Shape *>(VT_SHAPE);
  }
  onnx::Shape *mutable_shape() {
    return GetPointer<onnx::Shape *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct TensorTypeBuilder {
  typedef TensorType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(onnx::DataType elem_type) {
    fbb_.AddElement<int32_t>(TensorType::VT_ELEM_TYPE, static_cast<int32_t>(elem_type), 0);
  }
  void add_shape(::flatbuffers::Offset<onnx::Shape> shape) {
    fbb_.AddOffset(TensorType::VT_SHAPE, shape);
  }
  explicit TensorTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorType> CreateTensorType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::DataType elem_type = onnx::DataType::UNDEFINED,
    ::flatbuffers::Offset<onnx::Shape> shape = 0) {
  TensorTypeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct TensorType::Traits {
  using type = TensorType;
  static auto constexpr Create = CreateTensorType;
};

struct SequenceType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SequenceTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SequenceTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.SequenceType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE_TYPE = 4,
    VT_ELEM_TYPE = 6
  };
  onnx::ValueType elem_type_type() const {
    return static_cast<onnx::ValueType>(GetField<uint8_t>(VT_ELEM_TYPE_TYPE, 0));
  }
  const void *elem_type() const {
    return GetPointer<const void *>(VT_ELEM_TYPE);
  }
  template<typename T> const T *elem_type_as() const;
  const onnx::TensorType *elem_type_as_tensor_type() const {
    return elem_type_type() == onnx::ValueType::tensor_type ? static_cast<const onnx::TensorType *>(elem_type()) : nullptr;
  }
  const onnx::SequenceType *elem_type_as_sequence_type() const {
    return elem_type_type() == onnx::ValueType::sequence_type ? static_cast<const onnx::SequenceType *>(elem_type()) : nullptr;
  }
  const onnx::MapType *elem_type_as_map_type() const {
    return elem_type_type() == onnx::ValueType::map_type ? static_cast<const onnx::MapType *>(elem_type()) : nullptr;
  }
  const onnx::OptionalType *elem_type_as_optional_type() const {
    return elem_type_type() == onnx::ValueType::optional_type ? static_cast<const onnx::OptionalType *>(elem_type()) : nullptr;
  }
  const onnx::SparseTensorType *elem_type_as_sparse_tensor_type() const {
    return elem_type_type() == onnx::ValueType::sparse_tensor_type ? static_cast<const onnx::SparseTensorType *>(elem_type()) : nullptr;
  }
  void *mutable_elem_type() {
    return GetPointer<void *>(VT_ELEM_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ELEM_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           VerifyValueType(verifier, elem_type(), elem_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const onnx::TensorType *SequenceType::elem_type_as<onnx::TensorType>() const {
  return elem_type_as_tensor_type();
}

template<> inline const onnx::SequenceType *SequenceType::elem_type_as<onnx::SequenceType>() const {
  return elem_type_as_sequence_type();
}

template<> inline const onnx::MapType *SequenceType::elem_type_as<onnx::MapType>() const {
  return elem_type_as_map_type();
}

template<> inline const onnx::OptionalType *SequenceType::elem_type_as<onnx::OptionalType>() const {
  return elem_type_as_optional_type();
}

template<> inline const onnx::SparseTensorType *SequenceType::elem_type_as<onnx::SparseTensorType>() const {
  return elem_type_as_sparse_tensor_type();
}

struct SequenceTypeBuilder {
  typedef SequenceType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type_type(onnx::ValueType elem_type_type) {
    fbb_.AddElement<uint8_t>(SequenceType::VT_ELEM_TYPE_TYPE, static_cast<uint8_t>(elem_type_type), 0);
  }
  void add_elem_type(::flatbuffers::Offset<void> elem_type) {
    fbb_.AddOffset(SequenceType::VT_ELEM_TYPE, elem_type);
  }
  explicit SequenceTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SequenceType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SequenceType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SequenceType> CreateSequenceType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::ValueType elem_type_type = onnx::ValueType::NONE,
    ::flatbuffers::Offset<void> elem_type = 0) {
  SequenceTypeBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  builder_.add_elem_type_type(elem_type_type);
  return builder_.Finish();
}

struct SequenceType::Traits {
  using type = SequenceType;
  static auto constexpr Create = CreateSequenceType;
};

struct MapType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.MapType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY_TYPE = 4,
    VT_VALUE_TYPE_TYPE = 6,
    VT_VALUE_TYPE = 8
  };
  onnx::DataType key_type() const {
    return static_cast<onnx::DataType>(GetField<int32_t>(VT_KEY_TYPE, 0));
  }
  bool mutate_key_type(onnx::DataType _key_type = static_cast<onnx::DataType>(0)) {
    return SetField<int32_t>(VT_KEY_TYPE, static_cast<int32_t>(_key_type), 0);
  }
  onnx::ValueType value_type_type() const {
    return static_cast<onnx::ValueType>(GetField<uint8_t>(VT_VALUE_TYPE_TYPE, 0));
  }
  const void *value_type() const {
    return GetPointer<const void *>(VT_VALUE_TYPE);
  }
  template<typename T> const T *value_type_as() const;
  const onnx::TensorType *value_type_as_tensor_type() const {
    return value_type_type() == onnx::ValueType::tensor_type ? static_cast<const onnx::TensorType *>(value_type()) : nullptr;
  }
  const onnx::SequenceType *value_type_as_sequence_type() const {
    return value_type_type() == onnx::ValueType::sequence_type ? static_cast<const onnx::SequenceType *>(value_type()) : nullptr;
  }
  const onnx::MapType *value_type_as_map_type() const {
    return value_type_type() == onnx::ValueType::map_type ? static_cast<const onnx::MapType *>(value_type()) : nullptr;
  }
  const onnx::OptionalType *value_type_as_optional_type() const {
    return value_type_type() == onnx::ValueType::optional_type ? static_cast<const onnx::OptionalType *>(value_type()) : nullptr;
  }
  const onnx::SparseTensorType *value_type_as_sparse_tensor_type() const {
    return value_type_type() == onnx::ValueType::sparse_tensor_type ? static_cast<const onnx::SparseTensorType *>(value_type()) : nullptr;
  }
  void *mutable_value_type() {
    return GetPointer<void *>(VT_VALUE_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE_TYPE) &&
           VerifyValueType(verifier, value_type(), value_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const onnx::TensorType *MapType::value_type_as<onnx::TensorType>() const {
  return value_type_as_tensor_type();
}

template<> inline const onnx::SequenceType *MapType::value_type_as<onnx::SequenceType>() const {
  return value_type_as_sequence_type();
}

template<> inline const onnx::MapType *MapType::value_type_as<onnx::MapType>() const {
  return value_type_as_map_type();
}

template<> inline const onnx::OptionalType *MapType::value_type_as<onnx::OptionalType>() const {
  return value_type_as_optional_type();
}

template<> inline const onnx::SparseTensorType *MapType::value_type_as<onnx::SparseTensorType>() const {
  return value_type_as_sparse_tensor_type();
}

struct MapTypeBuilder {
  typedef MapType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key_type(onnx::DataType key_type) {
    fbb_.AddElement<int32_t>(MapType::VT_KEY_TYPE, static_cast<int32_t>(key_type), 0);
  }
  void add_value_type_type(onnx::ValueType value_type_type) {
    fbb_.AddElement<uint8_t>(MapType::VT_VALUE_TYPE_TYPE, static_cast<uint8_t>(value_type_type), 0);
  }
  void add_value_type(::flatbuffers::Offset<void> value_type) {
    fbb_.AddOffset(MapType::VT_VALUE_TYPE, value_type);
  }
  explicit MapTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MapType> CreateMapType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::DataType key_type = onnx::DataType::UNDEFINED,
    onnx::ValueType value_type_type = onnx::ValueType::NONE,
    ::flatbuffers::Offset<void> value_type = 0) {
  MapTypeBuilder builder_(_fbb);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  builder_.add_value_type_type(value_type_type);
  return builder_.Finish();
}

struct MapType::Traits {
  using type = MapType;
  static auto constexpr Create = CreateMapType;
};

struct OptionalType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OptionalTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.OptionalType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE_TYPE = 4,
    VT_ELEM_TYPE = 6
  };
  onnx::ValueType elem_type_type() const {
    return static_cast<onnx::ValueType>(GetField<uint8_t>(VT_ELEM_TYPE_TYPE, 0));
  }
  const void *elem_type() const {
    return GetPointer<const void *>(VT_ELEM_TYPE);
  }
  template<typename T> const T *elem_type_as() const;
  const onnx::TensorType *elem_type_as_tensor_type() const {
    return elem_type_type() == onnx::ValueType::tensor_type ? static_cast<const onnx::TensorType *>(elem_type()) : nullptr;
  }
  const onnx::SequenceType *elem_type_as_sequence_type() const {
    return elem_type_type() == onnx::ValueType::sequence_type ? static_cast<const onnx::SequenceType *>(elem_type()) : nullptr;
  }
  const onnx::MapType *elem_type_as_map_type() const {
    return elem_type_type() == onnx::ValueType::map_type ? static_cast<const onnx::MapType *>(elem_type()) : nullptr;
  }
  const onnx::OptionalType *elem_type_as_optional_type() const {
    return elem_type_type() == onnx::ValueType::optional_type ? static_cast<const onnx::OptionalType *>(elem_type()) : nullptr;
  }
  const onnx::SparseTensorType *elem_type_as_sparse_tensor_type() const {
    return elem_type_type() == onnx::ValueType::sparse_tensor_type ? static_cast<const onnx::SparseTensorType *>(elem_type()) : nullptr;
  }
  void *mutable_elem_type() {
    return GetPointer<void *>(VT_ELEM_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ELEM_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           VerifyValueType(verifier, elem_type(), elem_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const onnx::TensorType *OptionalType::elem_type_as<onnx::TensorType>() const {
  return elem_type_as_tensor_type();
}

template<> inline const onnx::SequenceType *OptionalType::elem_type_as<onnx::SequenceType>() const {
  return elem_type_as_sequence_type();
}

template<> inline const onnx::MapType *OptionalType::elem_type_as<onnx::MapType>() const {
  return elem_type_as_map_type();
}

template<> inline const onnx::OptionalType *OptionalType::elem_type_as<onnx::OptionalType>() const {
  return elem_type_as_optional_type();
}

template<> inline const onnx::SparseTensorType *OptionalType::elem_type_as<onnx::SparseTensorType>() const {
  return elem_type_as_sparse_tensor_type();
}

struct OptionalTypeBuilder {
  typedef OptionalType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type_type(onnx::ValueType elem_type_type) {
    fbb_.AddElement<uint8_t>(OptionalType::VT_ELEM_TYPE_TYPE, static_cast<uint8_t>(elem_type_type), 0);
  }
  void add_elem_type(::flatbuffers::Offset<void> elem_type) {
    fbb_.AddOffset(OptionalType::VT_ELEM_TYPE, elem_type);
  }
  explicit OptionalTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalType> CreateOptionalType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::ValueType elem_type_type = onnx::ValueType::NONE,
    ::flatbuffers::Offset<void> elem_type = 0) {
  OptionalTypeBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  builder_.add_elem_type_type(elem_type_type);
  return builder_.Finish();
}

struct OptionalType::Traits {
  using type = OptionalType;
  static auto constexpr Create = CreateOptionalType;
};

struct SparseTensorType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparseTensorTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseTensorTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.SparseTensorType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  onnx::DataType elem_type() const {
    return static_cast<onnx::DataType>(GetField<int32_t>(VT_ELEM_TYPE, 0));
  }
  bool mutate_elem_type(onnx::DataType _elem_type = static_cast<onnx::DataType>(0)) {
    return SetField<int32_t>(VT_ELEM_TYPE, static_cast<int32_t>(_elem_type), 0);
  }
  const onnx::Shape *shape() const {
    return GetPointer<const onnx::Shape *>(VT_SHAPE);
  }
  onnx::Shape *mutable_shape() {
    return GetPointer<onnx::Shape *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct SparseTensorTypeBuilder {
  typedef SparseTensorType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(onnx::DataType elem_type) {
    fbb_.AddElement<int32_t>(SparseTensorType::VT_ELEM_TYPE, static_cast<int32_t>(elem_type), 0);
  }
  void add_shape(::flatbuffers::Offset<onnx::Shape> shape) {
    fbb_.AddOffset(SparseTensorType::VT_SHAPE, shape);
  }
  explicit SparseTensorTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseTensorType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseTensorType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseTensorType> CreateSparseTensorType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnx::DataType elem_type = onnx::DataType::UNDEFINED,
    ::flatbuffers::Offset<onnx::Shape> shape = 0) {
  SparseTensorTypeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct SparseTensorType::Traits {
  using type = SparseTensorType;
  static auto constexpr Create = CreateSparseTensorType;
};

struct OperatorSetId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorSetIdBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OperatorSetIdTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.OperatorSetId";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOMAIN = 4,
    VT_VERSION = 6
  };
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool mutate_version(int64_t _version = 0) {
    return SetField<int64_t>(VT_VERSION, _version, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_VERSION, 8) &&
           verifier.EndTable();
  }
};

struct OperatorSetIdBuilder {
  typedef OperatorSetId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(OperatorSetId::VT_DOMAIN, domain);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(OperatorSetId::VT_VERSION, version, 0);
  }
  explicit OperatorSetIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OperatorSetId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OperatorSetId>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OperatorSetId> CreateOperatorSetId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int64_t version = 0) {
  OperatorSetIdBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_domain(domain);
  return builder_.Finish();
}

struct OperatorSetId::Traits {
  using type = OperatorSetId;
  static auto constexpr Create = CreateOperatorSetId;
};

inline ::flatbuffers::Offset<OperatorSetId> CreateOperatorSetIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *domain = nullptr,
    int64_t version = 0) {
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  return onnx::CreateOperatorSetId(
      _fbb,
      domain__,
      version);
}

struct ValueInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueInfoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ValueInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.ValueInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DOC_STRING = 8,
    VT_METADATA_PROPS = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const onnx::TypeInfo *type() const {
    return GetPointer<const onnx::TypeInfo *>(VT_TYPE);
  }
  onnx::TypeInfo *mutable_type() {
    return GetPointer<onnx::TypeInfo *>(VT_TYPE);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct ValueInfoBuilder {
  typedef ValueInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ValueInfo::VT_NAME, name);
  }
  void add_type(::flatbuffers::Offset<onnx::TypeInfo> type) {
    fbb_.AddOffset(ValueInfo::VT_TYPE, type);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(ValueInfo::VT_DOC_STRING, doc_string);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(ValueInfo::VT_METADATA_PROPS, metadata_props);
  }
  explicit ValueInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueInfo> CreateValueInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<onnx::TypeInfo> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props = 0) {
  ValueInfoBuilder builder_(_fbb);
  builder_.add_metadata_props(metadata_props);
  builder_.add_doc_string(doc_string);
  builder_.add_type(type);
  builder_.add_name(name);
  return builder_.Finish();
}

struct ValueInfo::Traits {
  using type = ValueInfo;
  static auto constexpr Create = CreateValueInfo;
};

inline ::flatbuffers::Offset<ValueInfo> CreateValueInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<onnx::TypeInfo> type = 0,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*metadata_props) : 0;
  return onnx::CreateValueInfo(
      _fbb,
      name__,
      type,
      doc_string__,
      metadata_props__);
}

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Node";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OP_TYPE = 6,
    VT_DOMAIN = 8,
    VT_OVERLOAD = 10,
    VT_INPUT = 12,
    VT_OUTPUT = 14,
    VT_ATTRIBUTE = 16,
    VT_DEVICE_CONFIGURATIONS = 18,
    VT_DOC_STRING = 20,
    VT_METADATA_PROPS = 22
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *op_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP_TYPE);
  }
  ::flatbuffers::String *mutable_op_type() {
    return GetPointer<::flatbuffers::String *>(VT_OP_TYPE);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  const ::flatbuffers::String *overload() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OVERLOAD);
  }
  ::flatbuffers::String *mutable_overload() {
    return GetPointer<::flatbuffers::String *>(VT_OVERLOAD);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *input() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_input() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *output() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_output() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *attribute() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *>(VT_ATTRIBUTE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *mutable_attribute() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *>(VT_ATTRIBUTE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>> *device_configurations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>> *>(VT_DEVICE_CONFIGURATIONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>> *mutable_device_configurations() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>> *>(VT_DEVICE_CONFIGURATIONS);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OP_TYPE) &&
           verifier.VerifyString(op_type()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyOffset(verifier, VT_OVERLOAD) &&
           verifier.VerifyString(overload()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_ATTRIBUTE) &&
           verifier.VerifyVector(attribute()) &&
           verifier.VerifyVectorOfTables(attribute()) &&
           VerifyOffset(verifier, VT_DEVICE_CONFIGURATIONS) &&
           verifier.VerifyVector(device_configurations()) &&
           verifier.VerifyVectorOfTables(device_configurations()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_op_type(::flatbuffers::Offset<::flatbuffers::String> op_type) {
    fbb_.AddOffset(Node::VT_OP_TYPE, op_type);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(Node::VT_DOMAIN, domain);
  }
  void add_overload(::flatbuffers::Offset<::flatbuffers::String> overload) {
    fbb_.AddOffset(Node::VT_OVERLOAD, overload);
  }
  void add_input(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input) {
    fbb_.AddOffset(Node::VT_INPUT, input);
  }
  void add_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output) {
    fbb_.AddOffset(Node::VT_OUTPUT, output);
  }
  void add_attribute(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>>> attribute) {
    fbb_.AddOffset(Node::VT_ATTRIBUTE, attribute);
  }
  void add_device_configurations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>>> device_configurations) {
    fbb_.AddOffset(Node::VT_DEVICE_CONFIGURATIONS, device_configurations);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Node::VT_DOC_STRING, doc_string);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Node::VT_METADATA_PROPS, metadata_props);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> op_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    ::flatbuffers::Offset<::flatbuffers::String> overload = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>>> attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>>> device_configurations = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_metadata_props(metadata_props);
  builder_.add_doc_string(doc_string);
  builder_.add_device_configurations(device_configurations);
  builder_.add_attribute(attribute);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_overload(overload);
  builder_.add_domain(domain);
  builder_.add_op_type(op_type);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
};

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *op_type = nullptr,
    const char *domain = nullptr,
    const char *overload = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *input = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *output = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Attribute>> *attribute = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>> *device_configurations = nullptr,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto op_type__ = op_type ? _fbb.CreateString(op_type) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto overload__ = overload ? _fbb.CreateString(overload) : 0;
  auto input__ = input ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*output) : 0;
  auto attribute__ = attribute ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Attribute>>(*attribute) : 0;
  auto device_configurations__ = device_configurations ? _fbb.CreateVector<::flatbuffers::Offset<onnx::NodeDeviceConfiguration>>(*device_configurations) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*metadata_props) : 0;
  return onnx::CreateNode(
      _fbb,
      name__,
      op_type__,
      domain__,
      overload__,
      input__,
      output__,
      attribute__,
      device_configurations__,
      doc_string__,
      metadata_props__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GraphTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Graph";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODE = 6,
    VT_INITIALIZER = 8,
    VT_SPARSE_INITIALIZER = 10,
    VT_INPUT = 12,
    VT_OUTPUT = 14,
    VT_VALUE_INFO = 16,
    VT_QUANTIZATION_ANNOTATION = 18,
    VT_DOC_STRING = 20,
    VT_METADATA_PROPS = 22
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *node() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *>(VT_NODE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *mutable_node() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *>(VT_NODE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *initializer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *>(VT_INITIALIZER);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *mutable_initializer() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>> *>(VT_INITIALIZER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *sparse_initializer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *>(VT_SPARSE_INITIALIZER);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *mutable_sparse_initializer() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>> *>(VT_SPARSE_INITIALIZER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *input() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_INPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *mutable_input() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_INPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *output() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_OUTPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *mutable_output() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_OUTPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *value_info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_VALUE_INFO);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *mutable_value_info() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_VALUE_INFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *quantization_annotation() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *>(VT_QUANTIZATION_ANNOTATION);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *mutable_quantization_annotation() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *>(VT_QUANTIZATION_ANNOTATION);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           verifier.VerifyVectorOfTables(node()) &&
           VerifyOffset(verifier, VT_INITIALIZER) &&
           verifier.VerifyVector(initializer()) &&
           verifier.VerifyVectorOfTables(initializer()) &&
           VerifyOffset(verifier, VT_SPARSE_INITIALIZER) &&
           verifier.VerifyVector(sparse_initializer()) &&
           verifier.VerifyVectorOfTables(sparse_initializer()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfTables(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfTables(output()) &&
           VerifyOffset(verifier, VT_VALUE_INFO) &&
           verifier.VerifyVector(value_info()) &&
           verifier.VerifyVectorOfTables(value_info()) &&
           VerifyOffset(verifier, VT_QUANTIZATION_ANNOTATION) &&
           verifier.VerifyVector(quantization_annotation()) &&
           verifier.VerifyVectorOfTables(quantization_annotation()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Graph::VT_NAME, name);
  }
  void add_node(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>>> node) {
    fbb_.AddOffset(Graph::VT_NODE, node);
  }
  void add_initializer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>>> initializer) {
    fbb_.AddOffset(Graph::VT_INITIALIZER, initializer);
  }
  void add_sparse_initializer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>>> sparse_initializer) {
    fbb_.AddOffset(Graph::VT_SPARSE_INITIALIZER, sparse_initializer);
  }
  void add_input(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> input) {
    fbb_.AddOffset(Graph::VT_INPUT, input);
  }
  void add_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> output) {
    fbb_.AddOffset(Graph::VT_OUTPUT, output);
  }
  void add_value_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> value_info) {
    fbb_.AddOffset(Graph::VT_VALUE_INFO, value_info);
  }
  void add_quantization_annotation(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>>> quantization_annotation) {
    fbb_.AddOffset(Graph::VT_QUANTIZATION_ANNOTATION, quantization_annotation);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Graph::VT_DOC_STRING, doc_string);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Graph::VT_METADATA_PROPS, metadata_props);
  }
  explicit GraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Graph> CreateGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>>> node = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Tensor>>> initializer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::SparseTensor>>> sparse_initializer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> input = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> output = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> value_info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TensorAnnotation>>> quantization_annotation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_metadata_props(metadata_props);
  builder_.add_doc_string(doc_string);
  builder_.add_quantization_annotation(quantization_annotation);
  builder_.add_value_info(value_info);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_sparse_initializer(sparse_initializer);
  builder_.add_initializer(initializer);
  builder_.add_node(node);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Graph::Traits {
  using type = Graph;
  static auto constexpr Create = CreateGraph;
};

inline ::flatbuffers::Offset<Graph> CreateGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Node>> *node = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Tensor>> *initializer = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::SparseTensor>> *sparse_initializer = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfo>> *input = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfo>> *output = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfo>> *value_info = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TensorAnnotation>> *quantization_annotation = nullptr,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto node__ = node ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Node>>(*node) : 0;
  auto initializer__ = initializer ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Tensor>>(*initializer) : 0;
  auto sparse_initializer__ = sparse_initializer ? _fbb.CreateVector<::flatbuffers::Offset<onnx::SparseTensor>>(*sparse_initializer) : 0;
  auto input__ = input ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfo>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfo>>(*output) : 0;
  auto value_info__ = value_info ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfo>>(*value_info) : 0;
  auto quantization_annotation__ = quantization_annotation ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TensorAnnotation>>(*quantization_annotation) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*metadata_props) : 0;
  return onnx::CreateGraph(
      _fbb,
      name__,
      node__,
      initializer__,
      sparse_initializer__,
      input__,
      output__,
      value_info__,
      quantization_annotation__,
      doc_string__,
      metadata_props__);
}

struct Function FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FunctionBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FunctionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Function";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOMAIN = 6,
    VT_OVERLOAD = 8,
    VT_OPSET_IMPORT = 10,
    VT_INPUT = 12,
    VT_OUTPUT = 14,
    VT_ATTRIBUTE = 16,
    VT_NODE = 18,
    VT_VALUE_INFO = 20,
    VT_DOC_STRING = 22,
    VT_METADATA_PROPS = 24
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  const ::flatbuffers::String *overload() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OVERLOAD);
  }
  ::flatbuffers::String *mutable_overload() {
    return GetPointer<::flatbuffers::String *>(VT_OVERLOAD);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *opset_import() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *mutable_opset_import() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *input() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_input() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *output() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_output() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *attribute() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *>(VT_ATTRIBUTE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *mutable_attribute() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>> *>(VT_ATTRIBUTE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *node() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *>(VT_NODE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *mutable_node() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>> *>(VT_NODE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *value_info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_VALUE_INFO);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *mutable_value_info() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>> *>(VT_VALUE_INFO);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyOffset(verifier, VT_OVERLOAD) &&
           verifier.VerifyString(overload()) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyVector(input()) &&
           verifier.VerifyVectorOfStrings(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           verifier.VerifyVectorOfStrings(output()) &&
           VerifyOffset(verifier, VT_ATTRIBUTE) &&
           verifier.VerifyVector(attribute()) &&
           verifier.VerifyVectorOfTables(attribute()) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyVector(node()) &&
           verifier.VerifyVectorOfTables(node()) &&
           VerifyOffset(verifier, VT_VALUE_INFO) &&
           verifier.VerifyVector(value_info()) &&
           verifier.VerifyVectorOfTables(value_info()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  typedef Function Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Function::VT_NAME, name);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(Function::VT_DOMAIN, domain);
  }
  void add_overload(::flatbuffers::Offset<::flatbuffers::String> overload) {
    fbb_.AddOffset(Function::VT_OVERLOAD, overload);
  }
  void add_opset_import(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>>> opset_import) {
    fbb_.AddOffset(Function::VT_OPSET_IMPORT, opset_import);
  }
  void add_input(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input) {
    fbb_.AddOffset(Function::VT_INPUT, input);
  }
  void add_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output) {
    fbb_.AddOffset(Function::VT_OUTPUT, output);
  }
  void add_attribute(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>>> attribute) {
    fbb_.AddOffset(Function::VT_ATTRIBUTE, attribute);
  }
  void add_node(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>>> node) {
    fbb_.AddOffset(Function::VT_NODE, node);
  }
  void add_value_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> value_info) {
    fbb_.AddOffset(Function::VT_VALUE_INFO, value_info);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Function::VT_DOC_STRING, doc_string);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Function::VT_METADATA_PROPS, metadata_props);
  }
  explicit FunctionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Function> CreateFunction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    ::flatbuffers::Offset<::flatbuffers::String> overload = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>>> opset_import = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Attribute>>> attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Node>>> node = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::ValueInfo>>> value_info = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_metadata_props(metadata_props);
  builder_.add_doc_string(doc_string);
  builder_.add_value_info(value_info);
  builder_.add_node(node);
  builder_.add_attribute(attribute);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_opset_import(opset_import);
  builder_.add_overload(overload);
  builder_.add_domain(domain);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Function::Traits {
  using type = Function;
  static auto constexpr Create = CreateFunction;
};

inline ::flatbuffers::Offset<Function> CreateFunctionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *domain = nullptr,
    const char *overload = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::OperatorSetId>> *opset_import = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *input = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *output = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Attribute>> *attribute = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::Node>> *node = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::ValueInfo>> *value_info = nullptr,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto overload__ = overload ? _fbb.CreateString(overload) : 0;
  auto opset_import__ = opset_import ? _fbb.CreateVector<::flatbuffers::Offset<onnx::OperatorSetId>>(*opset_import) : 0;
  auto input__ = input ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*input) : 0;
  auto output__ = output ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*output) : 0;
  auto attribute__ = attribute ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Attribute>>(*attribute) : 0;
  auto node__ = node ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Node>>(*node) : 0;
  auto value_info__ = value_info ? _fbb.CreateVector<::flatbuffers::Offset<onnx::ValueInfo>>(*value_info) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*metadata_props) : 0;
  return onnx::CreateFunction(
      _fbb,
      name__,
      domain__,
      overload__,
      opset_import__,
      input__,
      output__,
      attribute__,
      node__,
      value_info__,
      doc_string__,
      metadata_props__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnx.Model";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IR_VERSION = 4,
    VT_OPSET_IMPORT = 6,
    VT_PRODUCER_NAME = 8,
    VT_PRODUCER_VERSION = 10,
    VT_DOMAIN = 12,
    VT_MODEL_VERSION = 14,
    VT_GRAPH = 16,
    VT_FUNCTIONS = 18,
    VT_TRAINING_INFO = 20,
    VT_CONFIGURATION = 22,
    VT_DOC_STRING = 24,
    VT_METADATA_PROPS = 26
  };
  int64_t ir_version() const {
    return GetField<int64_t>(VT_IR_VERSION, 0);
  }
  bool mutate_ir_version(int64_t _ir_version = 0) {
    return SetField<int64_t>(VT_IR_VERSION, _ir_version, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *opset_import() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *mutable_opset_import() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  const ::flatbuffers::String *producer_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  ::flatbuffers::String *mutable_producer_name() {
    return GetPointer<::flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  const ::flatbuffers::String *producer_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  ::flatbuffers::String *mutable_producer_version() {
    return GetPointer<::flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t model_version() const {
    return GetField<int64_t>(VT_MODEL_VERSION, 0);
  }
  bool mutate_model_version(int64_t _model_version = 0) {
    return SetField<int64_t>(VT_MODEL_VERSION, _model_version, 0);
  }
  const onnx::Graph *graph() const {
    return GetPointer<const onnx::Graph *>(VT_GRAPH);
  }
  onnx::Graph *mutable_graph() {
    return GetPointer<onnx::Graph *>(VT_GRAPH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Function>> *functions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Function>> *>(VT_FUNCTIONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::Function>> *mutable_functions() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Function>> *>(VT_FUNCTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfo>> *training_info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfo>> *>(VT_TRAINING_INFO);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfo>> *mutable_training_info() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfo>> *>(VT_TRAINING_INFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::DeviceConfiguration>> *configuration() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::DeviceConfiguration>> *>(VT_CONFIGURATION);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::DeviceConfiguration>> *mutable_configuration() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::DeviceConfiguration>> *>(VT_CONFIGURATION);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IR_VERSION, 8) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_PRODUCER_NAME) &&
           verifier.VerifyString(producer_name()) &&
           VerifyOffset(verifier, VT_PRODUCER_VERSION) &&
           verifier.VerifyString(producer_version()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_MODEL_VERSION, 8) &&
           VerifyOffset(verifier, VT_GRAPH) &&
           verifier.VerifyTable(graph()) &&
           VerifyOffset(verifier, VT_FUNCTIONS) &&
           verifier.VerifyVector(functions()) &&
           verifier.VerifyVectorOfTables(functions()) &&
           VerifyOffset(verifier, VT_TRAINING_INFO) &&
           verifier.VerifyVector(training_info()) &&
           verifier.VerifyVectorOfTables(training_info()) &&
           VerifyOffset(verifier, VT_CONFIGURATION) &&
           verifier.VerifyVector(configuration()) &&
           verifier.VerifyVectorOfTables(configuration()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ir_version(int64_t ir_version) {
    fbb_.AddElement<int64_t>(Model::VT_IR_VERSION, ir_version, 0);
  }
  void add_opset_import(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>>> opset_import) {
    fbb_.AddOffset(Model::VT_OPSET_IMPORT, opset_import);
  }
  void add_producer_name(::flatbuffers::Offset<::flatbuffers::String> producer_name) {
    fbb_.AddOffset(Model::VT_PRODUCER_NAME, producer_name);
  }
  void add_producer_version(::flatbuffers::Offset<::flatbuffers::String> producer_version) {
    fbb_.AddOffset(Model::VT_PRODUCER_VERSION, producer_version);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(Model::VT_DOMAIN, domain);
  }
  void add_model_version(int64_t model_version) {
    fbb_.AddElement<int64_t>(Model::VT_MODEL_VERSION, model_version, 0);
  }
  void add_graph(::flatbuffers::Offset<onnx::Graph> graph) {
    fbb_.AddOffset(Model::VT_GRAPH, graph);
  }
  void add_functions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Function>>> functions) {
    fbb_.AddOffset(Model::VT_FUNCTIONS, functions);
  }
  void add_training_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfo>>> training_info) {
    fbb_.AddOffset(Model::VT_TRAINING_INFO, training_info);
  }
  void add_configuration(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::DeviceConfiguration>>> configuration) {
    fbb_.AddOffset(Model::VT_CONFIGURATION, configuration);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Model::VT_DOC_STRING, doc_string);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Model::VT_METADATA_PROPS, metadata_props);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::OperatorSetId>>> opset_import = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producer_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producer_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int64_t model_version = 0,
    ::flatbuffers::Offset<onnx::Graph> graph = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::Function>>> functions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::TrainingInfo>>> training_info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::DeviceConfiguration>>> configuration = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnx::StringStringEntry>>> metadata_props = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_model_version(model_version);
  builder_.add_ir_version(ir_version);
  builder_.add_metadata_props(metadata_props);
  builder_.add_doc_string(doc_string);
  builder_.add_configuration(configuration);
  builder_.add_training_info(training_info);
  builder_.add_functions(functions);
  builder_.add_graph(graph);
  builder_.add_domain(domain);
  builder_.add_producer_version(producer_version);
  builder_.add_producer_name(producer_name);
  builder_.add_opset_import(opset_import);
  return builder_.Finish();
}

struct Model::Traits {
  using type = Model;
  static auto constexpr Create = CreateModel;
};

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    const std::vector<::flatbuffers::Offset<onnx::OperatorSetId>> *opset_import = nullptr,
    const char *producer_name = nullptr,
    const char *producer_version = nullptr,
    const char *domain = nullptr,
    int64_t model_version = 0,
    ::flatbuffers::Offset<onnx::Graph> graph = 0,
    const std::vector<::flatbuffers::Offset<onnx::Function>> *functions = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::TrainingInfo>> *training_info = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::DeviceConfiguration>> *configuration = nullptr,
    const char *doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnx::StringStringEntry>> *metadata_props = nullptr) {
  auto opset_import__ = opset_import ? _fbb.CreateVector<::flatbuffers::Offset<onnx::OperatorSetId>>(*opset_import) : 0;
  auto producer_name__ = producer_name ? _fbb.CreateString(producer_name) : 0;
  auto producer_version__ = producer_version ? _fbb.CreateString(producer_version) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto functions__ = functions ? _fbb.CreateVector<::flatbuffers::Offset<onnx::Function>>(*functions) : 0;
  auto training_info__ = training_info ? _fbb.CreateVector<::flatbuffers::Offset<onnx::TrainingInfo>>(*training_info) : 0;
  auto configuration__ = configuration ? _fbb.CreateVector<::flatbuffers::Offset<onnx::DeviceConfiguration>>(*configuration) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnx::StringStringEntry>>(*metadata_props) : 0;
  return onnx::CreateModel(
      _fbb,
      ir_version,
      opset_import__,
      producer_name__,
      producer_version__,
      domain__,
      model_version,
      graph,
      functions__,
      training_info__,
      configuration__,
      doc_string__,
      metadata_props__);
}

inline bool VerifyValueType(::flatbuffers::Verifier &verifier, const void *obj, ValueType type) {
  switch (type) {
    case ValueType::NONE: {
      return true;
    }
    case ValueType::tensor_type: {
      auto ptr = reinterpret_cast<const onnx::TensorType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueType::sequence_type: {
      auto ptr = reinterpret_cast<const onnx::SequenceType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueType::map_type: {
      auto ptr = reinterpret_cast<const onnx::MapType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueType::optional_type: {
      auto ptr = reinterpret_cast<const onnx::OptionalType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueType::sparse_tensor_type: {
      auto ptr = reinterpret_cast<const onnx::SparseTensorType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueType> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueType(
        verifier,  values->Get(i), types->GetEnum<ValueType>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *VersionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::VersionTypeTable
  };
  static const char * const names[] = {
    "_START_VERSION",
    "IR_VERSION_2017_10_10",
    "IR_VERSION_2017_10_30",
    "IR_VERSION_2017_11_3",
    "IR_VERSION_2019_1_22",
    "IR_VERSION_2019_3_18",
    "IR_VERSION_2019_9_19",
    "IR_VERSION_2020_5_8",
    "IR_VERSION_2021_7_30",
    "IR_VERSION_2023_5_5",
    "IR_VERSION_2024_3_25",
    "IR_VERSION_2025_05_12",
    "IR_VERSION"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AttributeTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeTypeTypeTable
  };
  static const char * const names[] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    "TYPE_PROTO",
    "TYPE_PROTOS"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DataTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DataTypeTypeTable
  };
  static const char * const names[] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ",
    "UINT4",
    "INT4",
    "FLOAT4E2M1",
    "FLOAT8E8M0"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 25, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorDataLocationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorDataLocationTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "EXTERNAL"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OperatorStatusTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::OperatorStatusTypeTable
  };
  static const char * const names[] = {
    "EXPERIMENTAL",
    "STABLE"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DimensionValueTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DimensionValueTypeTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "VALUE",
    "PARAM"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ValueTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorTypeTypeTable,
    onnx::SequenceTypeTypeTable,
    onnx::MapTypeTypeTable,
    onnx::OptionalTypeTypeTable,
    onnx::SparseTensorTypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "tensor_type",
    "sequence_type",
    "map_type",
    "optional_type",
    "sparse_tensor_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AttributeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeTypeTypeTable,
    onnx::TensorTypeTable,
    onnx::GraphTypeTable,
    onnx::SparseTensorTypeTable,
    onnx::TypeInfoTypeTable
  };
  static const char * const names[] = {
    "name",
    "ref_attr_name",
    "doc_string",
    "type",
    "f",
    "i",
    "s",
    "t",
    "g",
    "sparse_tensor",
    "tp",
    "floats",
    "ints",
    "strings",
    "tensors",
    "graphs",
    "sparse_tensors",
    "types"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 18, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IntIntListEntryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodeDeviceConfigurationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::ShardingSpecTypeTable
  };
  static const char * const names[] = {
    "configuration_id",
    "sharding_spec",
    "pipeline_stage"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ShardingSpecTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::IntIntListEntryTypeTable,
    onnx::ShardedDimTypeTable
  };
  static const char * const names[] = {
    "tensor_name",
    "device",
    "index_to_device_group_map",
    "sharded_dim"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ShardedDimTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::SimpleShardedDimTypeTable
  };
  static const char * const names[] = {
    "axis",
    "simple_sharding"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SimpleShardedDimTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DimensionValueTypeTable
  };
  static const char * const names[] = {
    "dim",
    "num_shards"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TrainingInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::GraphTypeTable,
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "initialization",
    "algorithm",
    "initialization_binding",
    "update_binding"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DeviceConfigurationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "name",
    "num_devices",
    "device"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StringStringEntryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorAnnotationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "tensor_name",
    "quant_parameter_tensor_names"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DataTypeTypeTable,
    onnx::StringStringEntryTypeTable,
    onnx::TensorDataLocationTypeTable
  };
  static const char * const names[] = {
    "name",
    "doc_string",
    "dims",
    "data_type",
    "raw_data",
    "string_data",
    "external_data",
    "data_location",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorSegmentTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "begin",
    "end"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SparseTensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_LONG, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TensorTypeTable
  };
  static const char * const names[] = {
    "values",
    "indices",
    "dims"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ShapeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DimensionTypeTable
  };
  static const char * const names[] = {
    "dim"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DimensionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DimensionValueTypeTable
  };
  static const char * const names[] = {
    "value",
    "denotation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DimensionValueTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DimensionValueTypeTypeTable
  };
  static const char * const names[] = {
    "dim_type",
    "dim_value",
    "dim_param"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TypeInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::ValueTypeTypeTable
  };
  static const char * const names[] = {
    "value_type",
    "value",
    "denotation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DataTypeTypeTable,
    onnx::ShapeTypeTable
  };
  static const char * const names[] = {
    "elem_type",
    "shape"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SequenceTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::ValueTypeTypeTable
  };
  static const char * const names[] = {
    "elem_type_type",
    "elem_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MapTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_UTYPE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DataTypeTypeTable,
    onnx::ValueTypeTypeTable
  };
  static const char * const names[] = {
    "key_type",
    "value_type_type",
    "value_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OptionalTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::ValueTypeTypeTable
  };
  static const char * const names[] = {
    "elem_type_type",
    "elem_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SparseTensorTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::DataTypeTypeTable,
    onnx::ShapeTypeTable
  };
  static const char * const names[] = {
    "elem_type",
    "shape"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OperatorSetIdTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "domain",
    "version"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ValueInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::TypeInfoTypeTable,
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "name",
    "type",
    "doc_string",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::AttributeTypeTable,
    onnx::NodeDeviceConfigurationTypeTable,
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "name",
    "op_type",
    "domain",
    "overload",
    "input",
    "output",
    "attribute",
    "device_configurations",
    "doc_string",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GraphTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 5 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::NodeTypeTable,
    onnx::TensorTypeTable,
    onnx::SparseTensorTypeTable,
    onnx::ValueInfoTypeTable,
    onnx::TensorAnnotationTypeTable,
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "name",
    "node",
    "initializer",
    "sparse_initializer",
    "input",
    "output",
    "value_info",
    "quantization_annotation",
    "doc_string",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FunctionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::OperatorSetIdTypeTable,
    onnx::AttributeTypeTable,
    onnx::NodeTypeTable,
    onnx::ValueInfoTypeTable,
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "name",
    "domain",
    "overload",
    "opset_import",
    "input",
    "output",
    "attribute",
    "node",
    "value_info",
    "doc_string",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ModelTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 5 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnx::OperatorSetIdTypeTable,
    onnx::GraphTypeTable,
    onnx::FunctionTypeTable,
    onnx::TrainingInfoTypeTable,
    onnx::DeviceConfigurationTypeTable,
    onnx::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "ir_version",
    "opset_import",
    "producer_name",
    "producer_version",
    "domain",
    "model_version",
    "graph",
    "functions",
    "training_info",
    "configuration",
    "doc_string",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace onnx

#endif  // FLATBUFFERS_GENERATED_ONNXMOD_ONNX_H_
