// Generated from proto
// Design decisions:
// 1. Simplified raw_data in Tensor
// 2. Maintain field names as in onnx.proto as much as possible (keep plurality)
// 3. Renamed table names to remove "Proto" suffix
// 4. Flat namespaces to avoid deep nesting (or create a namespace for DeviceConfiguration?)
// 5. Some names are simplified: TensorShape -> Shape, type_protos -> types

namespace onnx;

enum Version : int32 {
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION_2017_11_3 = 3,
  IR_VERSION_2019_1_22 = 4,
  IR_VERSION_2019_3_18 = 5,
  IR_VERSION_2019_9_19 = 6,
  IR_VERSION_2020_5_8 = 7,
  IR_VERSION_2021_7_30 = 8,
  IR_VERSION_2023_5_5 = 9,
  IR_VERSION_2024_3_25 = 10,
  IR_VERSION_2025_05_12 = 11,
  IR_VERSION = 12,
}

enum AttributeType : int32 {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSOR = 11,
  SPARSE_TENSORS = 12,
  TYPE_PROTO = 13,
  TYPE_PROTOS = 14,
}

enum DataType : int32 {
  UNDEFINED = 0,
  FLOAT = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  INT32 = 6,
  INT64 = 7,
  STRING = 8,
  BOOL = 9,
  FLOAT16 = 10,
  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,
  COMPLEX128 = 15,
  BFLOAT16 = 16,
  FLOAT8E4M3FN = 17,
  FLOAT8E4M3FNUZ = 18,
  FLOAT8E5M2 = 19,
  FLOAT8E5M2FNUZ = 20,
  UINT4 = 21,
  INT4 = 22,
  FLOAT4E2M1 = 23,
  FLOAT8E8M0 = 24,
}

enum TensorDataLocation : uint8 {
  DEFAULT = 0,
  EXTERNAL = 1,
}

enum OperatorStatus : uint8 {
  EXPERIMENTAL = 0,
  STABLE = 1,
}

table Attribute {
  name:string;
  ref_attr_name:string;

  doc_string:string;

  type:AttributeType;

  f:float;
  i:int64;
  // s is different from that in onnx.proto which is bytes
  s:string;
  t:Tensor;
  g:Graph;
  sparse_tensor:SparseTensor;
  tp:TypeInfo;

  floats:[float32];
  ints:[int64];
  strings:[string];
  tensors:[Tensor];
  graphs:[Graph];
  sparse_tensors:[SparseTensor];
  types:[TypeInfo];
}

table IntIntListEntry {
  key:int64;
  value:[int64];
}

table NodeDeviceConfiguration {
  configuration_id:string;
  sharding_spec:[ShardingSpec];
  pipeline_stage:int;
}

table ShardingSpec {
  tensor_name:string;
  device:[int64];
  index_to_device_group_map:[IntIntListEntry];
  sharded_dim:[ShardedDim];
}

table ShardedDim {
  axis:int64;
  simple_sharding:[SimpleShardedDim];
}

table SimpleShardedDim {
  dim:DimensionValue;
  num_shards:int64;
}

table TrainingInfo {
  initialization:Graph;
  algorithm:Graph;
  initialization_binding:[StringStringEntry];
  update_binding:[StringStringEntry];
}

table DeviceConfiguration {
  name:string;
  num_devices:int;
  device:[string];
}

table StringStringEntry {
  key:string;
  value:string;
}

table TensorAnnotation {
  tensor_name:string;
  quant_parameter_tensor_names:[StringStringEntry];
}

// For simplicity, we will have only two data fields
// - string_data for string
// - raw_data for all other types
table Tensor {
  name:string;
  doc_string:string;

  dims:[int64];
  data_type:int;

  raw_data:[ubyte];
  string_data:[string];

  external_data:[StringStringEntry];
  data_location:TensorDataLocation;

  metadata_props:[StringStringEntry];
}

table TensorSegment {
  begin:int64;
  end:int64;
}

table SparseTensor {
  values:Tensor;
  indices:Tensor;
  dims:[int64];
}

// pb:TensorShapeProto
table Shape {
  dim:[Dimension];
}

// pb:TensorShapeProto.Dimension
table Dimension {
  value:DimensionValue;
  denotation:string;
}

// Use an enum instead of union to represent the oneof field because union
// does not support int types
enum DimensionValueType : int8 {
  UNKNOWN = 0,
  VALUE = 1,
  PARAM = 2,
}

table DimensionValue {
  dim_type:DimensionValueType;
  dim_value:int64;
  dim_param:string;
}

union ValueType {
  tensor_type:TensorType,
  sequence_type:SequenceType,
  map_type:MapType,
  optional_type:OptionalType,
  sparse_tensor_type:SparseTensorType
}

// pb:TypeProto
table TypeInfo {
  value:ValueType;
  denotation:string;
}

// pb:TypeProto.Tensor
table TensorType {
  elem_type:DataType;
  shape:Shape;
}

// pb:TypeProto.Sequence
table SequenceType {
  elem_type:ValueType;
}

// pb:TypeProto.Map
table MapType {
  key_type:DataType;
  value_type:ValueType;
}

// pb:TypeProto.Optional
table OptionalType {
  elem_type:ValueType;
}

// pb:TypeProto.SparseTensor
table SparseTensorType {
  elem_type:DataType;
  shape:Shape;
}

// pb:OperatorSetIdProto
table OperatorSetId {
  domain:string;
  version:int64;
}

// pb:ValueInfoProto
table ValueInfo {
  name:string;
  type:TypeInfo;

  doc_string:string;
  metadata_props:[StringStringEntry];
}

// pb:NodeProto
table Node {
  name:string;

  op_type:string;
  domain:string;
  overload:string;

  input:[string];
  output:[string];
  attribute:[Attribute];

  device_configurations:[NodeDeviceConfiguration];

  doc_string:string;
  metadata_props:[StringStringEntry];
}

// pb:GraphProto
table Graph {
  name:string;

  node:[Node];
  initializer:[Tensor];
  sparse_initializer:[SparseTensor];

  input:[ValueInfo];
  output:[ValueInfo];

  value_info:[ValueInfo];
  quantization_annotation:[TensorAnnotation];

  doc_string:string;
  metadata_props:[StringStringEntry];
}

// pb:FunctionProto
table Function {
  name:string;
  domain:string;
  overload:string;

  opset_import:[OperatorSetId];

  input:[string];
  output:[string];

  // NOTE: attribute:string is removed
  attribute:[Attribute];

  node:[Node];
  value_info:[ValueInfo];

  doc_string:string;
  metadata_props:[StringStringEntry];
}

// pb:ModelProto
table Model {
  ir_version:int64;
  opset_import:[OperatorSetId];
  producer_name:string;
  producer_version:string;
  domain:string;
  model_version:int64;

  graph:Graph;
  functions:[Function];

  training_info:[TrainingInfo];
  configuration:[DeviceConfiguration];

  doc_string:string;
  metadata_props:[StringStringEntry];
}
