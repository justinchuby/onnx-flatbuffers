# automatically generated by the FlatBuffers compiler, do not modify

# namespace: onnx

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Attribute(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Attribute()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAttribute(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Attribute
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Attribute
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def RefAttrName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def DocString(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Attribute
    def F(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Attribute
    def I(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Attribute
    def S(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def T(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from onnx.Tensor import Tensor
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def G(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from onnx.Graph import Graph
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def SparseTensor(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from onnx.SparseTensor import SparseTensor
            obj = SparseTensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def Tp(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from onnx.TypeInfo import TypeInfo
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def Floats(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Attribute
    def FloatsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Attribute
    def FloatsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def FloatsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # Attribute
    def Ints(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # Attribute
    def IntsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # Attribute
    def IntsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def IntsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

    # Attribute
    def Strings(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Attribute
    def StringsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def StringsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        return o == 0

    # Attribute
    def Tensors(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from onnx.Tensor import Tensor
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def TensorsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def TensorsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return o == 0

    # Attribute
    def Graphs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from onnx.Graph import Graph
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def GraphsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def GraphsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        return o == 0

    # Attribute
    def SparseTensors(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from onnx.SparseTensor import SparseTensor
            obj = SparseTensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def SparseTensorsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def SparseTensorsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        return o == 0

    # Attribute
    def Types(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from onnx.TypeInfo import TypeInfo
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def TypesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def TypesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        return o == 0

def AttributeStart(builder):
    builder.StartObject(18)

def Start(builder):
    AttributeStart(builder)

def AttributeAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AddName(builder, name):
    AttributeAddName(builder, name)

def AttributeAddRefAttrName(builder, refAttrName):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(refAttrName), 0)

def AddRefAttrName(builder, refAttrName):
    AttributeAddRefAttrName(builder, refAttrName)

def AttributeAddDocString(builder, docString):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def AddDocString(builder, docString):
    AttributeAddDocString(builder, docString)

def AttributeAddType(builder, type):
    builder.PrependInt32Slot(3, type, 0)

def AddType(builder, type):
    AttributeAddType(builder, type)

def AttributeAddF(builder, f):
    builder.PrependFloat32Slot(4, f, 0.0)

def AddF(builder, f):
    AttributeAddF(builder, f)

def AttributeAddI(builder, i):
    builder.PrependInt64Slot(5, i, 0)

def AddI(builder, i):
    AttributeAddI(builder, i)

def AttributeAddS(builder, s):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(s), 0)

def AddS(builder, s):
    AttributeAddS(builder, s)

def AttributeAddT(builder, t):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(t), 0)

def AddT(builder, t):
    AttributeAddT(builder, t)

def AttributeAddG(builder, g):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(g), 0)

def AddG(builder, g):
    AttributeAddG(builder, g)

def AttributeAddSparseTensor(builder, sparseTensor):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(sparseTensor), 0)

def AddSparseTensor(builder, sparseTensor):
    AttributeAddSparseTensor(builder, sparseTensor)

def AttributeAddTp(builder, tp):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(tp), 0)

def AddTp(builder, tp):
    AttributeAddTp(builder, tp)

def AttributeAddFloats(builder, floats):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(floats), 0)

def AddFloats(builder, floats):
    AttributeAddFloats(builder, floats)

def AttributeStartFloatsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartFloatsVector(builder, numElems):
    return AttributeStartFloatsVector(builder, numElems)

def AttributeAddInts(builder, ints):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(ints), 0)

def AddInts(builder, ints):
    AttributeAddInts(builder, ints)

def AttributeStartIntsVector(builder, numElems):
    return builder.StartVector(8, numElems, 8)

def StartIntsVector(builder, numElems):
    return AttributeStartIntsVector(builder, numElems)

def AttributeAddStrings(builder, strings):
    builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(strings), 0)

def AddStrings(builder, strings):
    AttributeAddStrings(builder, strings)

def AttributeStartStringsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartStringsVector(builder, numElems):
    return AttributeStartStringsVector(builder, numElems)

def AttributeAddTensors(builder, tensors):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(tensors), 0)

def AddTensors(builder, tensors):
    AttributeAddTensors(builder, tensors)

def AttributeStartTensorsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTensorsVector(builder, numElems):
    return AttributeStartTensorsVector(builder, numElems)

def AttributeAddGraphs(builder, graphs):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(graphs), 0)

def AddGraphs(builder, graphs):
    AttributeAddGraphs(builder, graphs)

def AttributeStartGraphsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartGraphsVector(builder, numElems):
    return AttributeStartGraphsVector(builder, numElems)

def AttributeAddSparseTensors(builder, sparseTensors):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(sparseTensors), 0)

def AddSparseTensors(builder, sparseTensors):
    AttributeAddSparseTensors(builder, sparseTensors)

def AttributeStartSparseTensorsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSparseTensorsVector(builder, numElems):
    return AttributeStartSparseTensorsVector(builder, numElems)

def AttributeAddTypes(builder, types):
    builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(types), 0)

def AddTypes(builder, types):
    AttributeAddTypes(builder, types)

def AttributeStartTypesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTypesVector(builder, numElems):
    return AttributeStartTypesVector(builder, numElems)

def AttributeEnd(builder):
    return builder.EndObject()

def End(builder):
    return AttributeEnd(builder)

import onnx.Graph
import onnx.SparseTensor
import onnx.Tensor
import onnx.TypeInfo
try:
    from typing import List, Optional
except:
    pass

class AttributeT(object):

    # AttributeT
    def __init__(self):
        self.name = None  # type: str
        self.refAttrName = None  # type: str
        self.docString = None  # type: str
        self.type = 0  # type: int
        self.f = 0.0  # type: float
        self.i = 0  # type: int
        self.s = None  # type: str
        self.t = None  # type: Optional[onnx.Tensor.TensorT]
        self.g = None  # type: Optional[onnx.Graph.GraphT]
        self.sparseTensor = None  # type: Optional[onnx.SparseTensor.SparseTensorT]
        self.tp = None  # type: Optional[onnx.TypeInfo.TypeInfoT]
        self.floats = None  # type: List[float]
        self.ints = None  # type: List[int]
        self.strings = None  # type: List[str]
        self.tensors = None  # type: List[onnx.Tensor.TensorT]
        self.graphs = None  # type: List[onnx.Graph.GraphT]
        self.sparseTensors = None  # type: List[onnx.SparseTensor.SparseTensorT]
        self.types = None  # type: List[onnx.TypeInfo.TypeInfoT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        attribute = Attribute()
        attribute.Init(buf, pos)
        return cls.InitFromObj(attribute)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, attribute):
        x = AttributeT()
        x._UnPack(attribute)
        return x

    # AttributeT
    def _UnPack(self, attribute):
        if attribute is None:
            return
        self.name = attribute.Name()
        self.refAttrName = attribute.RefAttrName()
        self.docString = attribute.DocString()
        self.type = attribute.Type()
        self.f = attribute.F()
        self.i = attribute.I()
        self.s = attribute.S()
        if attribute.T() is not None:
            self.t = onnx.Tensor.TensorT.InitFromObj(attribute.T())
        if attribute.G() is not None:
            self.g = onnx.Graph.GraphT.InitFromObj(attribute.G())
        if attribute.SparseTensor() is not None:
            self.sparseTensor = onnx.SparseTensor.SparseTensorT.InitFromObj(attribute.SparseTensor())
        if attribute.Tp() is not None:
            self.tp = onnx.TypeInfo.TypeInfoT.InitFromObj(attribute.Tp())
        if not attribute.FloatsIsNone():
            if np is None:
                self.floats = []
                for i in range(attribute.FloatsLength()):
                    self.floats.append(attribute.Floats(i))
            else:
                self.floats = attribute.FloatsAsNumpy()
        if not attribute.IntsIsNone():
            if np is None:
                self.ints = []
                for i in range(attribute.IntsLength()):
                    self.ints.append(attribute.Ints(i))
            else:
                self.ints = attribute.IntsAsNumpy()
        if not attribute.StringsIsNone():
            self.strings = []
            for i in range(attribute.StringsLength()):
                self.strings.append(attribute.Strings(i))
        if not attribute.TensorsIsNone():
            self.tensors = []
            for i in range(attribute.TensorsLength()):
                if attribute.Tensors(i) is None:
                    self.tensors.append(None)
                else:
                    tensor_ = onnx.Tensor.TensorT.InitFromObj(attribute.Tensors(i))
                    self.tensors.append(tensor_)
        if not attribute.GraphsIsNone():
            self.graphs = []
            for i in range(attribute.GraphsLength()):
                if attribute.Graphs(i) is None:
                    self.graphs.append(None)
                else:
                    graph_ = onnx.Graph.GraphT.InitFromObj(attribute.Graphs(i))
                    self.graphs.append(graph_)
        if not attribute.SparseTensorsIsNone():
            self.sparseTensors = []
            for i in range(attribute.SparseTensorsLength()):
                if attribute.SparseTensors(i) is None:
                    self.sparseTensors.append(None)
                else:
                    sparseTensor_ = onnx.SparseTensor.SparseTensorT.InitFromObj(attribute.SparseTensors(i))
                    self.sparseTensors.append(sparseTensor_)
        if not attribute.TypesIsNone():
            self.types = []
            for i in range(attribute.TypesLength()):
                if attribute.Types(i) is None:
                    self.types.append(None)
                else:
                    typeInfo_ = onnx.TypeInfo.TypeInfoT.InitFromObj(attribute.Types(i))
                    self.types.append(typeInfo_)

    # AttributeT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.refAttrName is not None:
            refAttrName = builder.CreateString(self.refAttrName)
        if self.docString is not None:
            docString = builder.CreateString(self.docString)
        if self.s is not None:
            s = builder.CreateString(self.s)
        if self.t is not None:
            t = self.t.Pack(builder)
        if self.g is not None:
            g = self.g.Pack(builder)
        if self.sparseTensor is not None:
            sparseTensor = self.sparseTensor.Pack(builder)
        if self.tp is not None:
            tp = self.tp.Pack(builder)
        if self.floats is not None:
            if np is not None and type(self.floats) is np.ndarray:
                floats = builder.CreateNumpyVector(self.floats)
            else:
                AttributeStartFloatsVector(builder, len(self.floats))
                for i in reversed(range(len(self.floats))):
                    builder.PrependFloat32(self.floats[i])
                floats = builder.EndVector()
        if self.ints is not None:
            if np is not None and type(self.ints) is np.ndarray:
                ints = builder.CreateNumpyVector(self.ints)
            else:
                AttributeStartIntsVector(builder, len(self.ints))
                for i in reversed(range(len(self.ints))):
                    builder.PrependInt64(self.ints[i])
                ints = builder.EndVector()
        if self.strings is not None:
            stringslist = []
            for i in range(len(self.strings)):
                stringslist.append(builder.CreateString(self.strings[i]))
            AttributeStartStringsVector(builder, len(self.strings))
            for i in reversed(range(len(self.strings))):
                builder.PrependUOffsetTRelative(stringslist[i])
            strings = builder.EndVector()
        if self.tensors is not None:
            tensorslist = []
            for i in range(len(self.tensors)):
                tensorslist.append(self.tensors[i].Pack(builder))
            AttributeStartTensorsVector(builder, len(self.tensors))
            for i in reversed(range(len(self.tensors))):
                builder.PrependUOffsetTRelative(tensorslist[i])
            tensors = builder.EndVector()
        if self.graphs is not None:
            graphslist = []
            for i in range(len(self.graphs)):
                graphslist.append(self.graphs[i].Pack(builder))
            AttributeStartGraphsVector(builder, len(self.graphs))
            for i in reversed(range(len(self.graphs))):
                builder.PrependUOffsetTRelative(graphslist[i])
            graphs = builder.EndVector()
        if self.sparseTensors is not None:
            sparseTensorslist = []
            for i in range(len(self.sparseTensors)):
                sparseTensorslist.append(self.sparseTensors[i].Pack(builder))
            AttributeStartSparseTensorsVector(builder, len(self.sparseTensors))
            for i in reversed(range(len(self.sparseTensors))):
                builder.PrependUOffsetTRelative(sparseTensorslist[i])
            sparseTensors = builder.EndVector()
        if self.types is not None:
            typeslist = []
            for i in range(len(self.types)):
                typeslist.append(self.types[i].Pack(builder))
            AttributeStartTypesVector(builder, len(self.types))
            for i in reversed(range(len(self.types))):
                builder.PrependUOffsetTRelative(typeslist[i])
            types = builder.EndVector()
        AttributeStart(builder)
        if self.name is not None:
            AttributeAddName(builder, name)
        if self.refAttrName is not None:
            AttributeAddRefAttrName(builder, refAttrName)
        if self.docString is not None:
            AttributeAddDocString(builder, docString)
        AttributeAddType(builder, self.type)
        AttributeAddF(builder, self.f)
        AttributeAddI(builder, self.i)
        if self.s is not None:
            AttributeAddS(builder, s)
        if self.t is not None:
            AttributeAddT(builder, t)
        if self.g is not None:
            AttributeAddG(builder, g)
        if self.sparseTensor is not None:
            AttributeAddSparseTensor(builder, sparseTensor)
        if self.tp is not None:
            AttributeAddTp(builder, tp)
        if self.floats is not None:
            AttributeAddFloats(builder, floats)
        if self.ints is not None:
            AttributeAddInts(builder, ints)
        if self.strings is not None:
            AttributeAddStrings(builder, strings)
        if self.tensors is not None:
            AttributeAddTensors(builder, tensors)
        if self.graphs is not None:
            AttributeAddGraphs(builder, graphs)
        if self.sparseTensors is not None:
            AttributeAddSparseTensors(builder, sparseTensors)
        if self.types is not None:
            AttributeAddTypes(builder, types)
        attribute = AttributeEnd(builder)
        return attribute
