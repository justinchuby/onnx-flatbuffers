// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod onnx {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VERSION: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VERSION: i32 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VERSION: [Version; 13] = [
  Version::_START_VERSION,
  Version::IR_VERSION_2017_10_10,
  Version::IR_VERSION_2017_10_30,
  Version::IR_VERSION_2017_11_3,
  Version::IR_VERSION_2019_1_22,
  Version::IR_VERSION_2019_3_18,
  Version::IR_VERSION_2019_9_19,
  Version::IR_VERSION_2020_5_8,
  Version::IR_VERSION_2021_7_30,
  Version::IR_VERSION_2023_5_5,
  Version::IR_VERSION_2024_3_25,
  Version::IR_VERSION_2025_05_12,
  Version::IR_VERSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Version(pub i32);
#[allow(non_upper_case_globals)]
impl Version {
  pub const _START_VERSION: Self = Self(0);
  pub const IR_VERSION_2017_10_10: Self = Self(1);
  pub const IR_VERSION_2017_10_30: Self = Self(2);
  pub const IR_VERSION_2017_11_3: Self = Self(3);
  pub const IR_VERSION_2019_1_22: Self = Self(4);
  pub const IR_VERSION_2019_3_18: Self = Self(5);
  pub const IR_VERSION_2019_9_19: Self = Self(6);
  pub const IR_VERSION_2020_5_8: Self = Self(7);
  pub const IR_VERSION_2021_7_30: Self = Self(8);
  pub const IR_VERSION_2023_5_5: Self = Self(9);
  pub const IR_VERSION_2024_3_25: Self = Self(10);
  pub const IR_VERSION_2025_05_12: Self = Self(11);
  pub const IR_VERSION: Self = Self(12);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::_START_VERSION,
    Self::IR_VERSION_2017_10_10,
    Self::IR_VERSION_2017_10_30,
    Self::IR_VERSION_2017_11_3,
    Self::IR_VERSION_2019_1_22,
    Self::IR_VERSION_2019_3_18,
    Self::IR_VERSION_2019_9_19,
    Self::IR_VERSION_2020_5_8,
    Self::IR_VERSION_2021_7_30,
    Self::IR_VERSION_2023_5_5,
    Self::IR_VERSION_2024_3_25,
    Self::IR_VERSION_2025_05_12,
    Self::IR_VERSION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::_START_VERSION => Some("_START_VERSION"),
      Self::IR_VERSION_2017_10_10 => Some("IR_VERSION_2017_10_10"),
      Self::IR_VERSION_2017_10_30 => Some("IR_VERSION_2017_10_30"),
      Self::IR_VERSION_2017_11_3 => Some("IR_VERSION_2017_11_3"),
      Self::IR_VERSION_2019_1_22 => Some("IR_VERSION_2019_1_22"),
      Self::IR_VERSION_2019_3_18 => Some("IR_VERSION_2019_3_18"),
      Self::IR_VERSION_2019_9_19 => Some("IR_VERSION_2019_9_19"),
      Self::IR_VERSION_2020_5_8 => Some("IR_VERSION_2020_5_8"),
      Self::IR_VERSION_2021_7_30 => Some("IR_VERSION_2021_7_30"),
      Self::IR_VERSION_2023_5_5 => Some("IR_VERSION_2023_5_5"),
      Self::IR_VERSION_2024_3_25 => Some("IR_VERSION_2024_3_25"),
      Self::IR_VERSION_2025_05_12 => Some("IR_VERSION_2025_05_12"),
      Self::IR_VERSION => Some("IR_VERSION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Version {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Version {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Version {
    type Output = Version;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Version {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Version {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Version {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ATTRIBUTE_TYPE: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ATTRIBUTE_TYPE: i32 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ATTRIBUTE_TYPE: [AttributeType; 15] = [
  AttributeType::UNDEFINED,
  AttributeType::FLOAT,
  AttributeType::INT,
  AttributeType::STRING,
  AttributeType::TENSOR,
  AttributeType::GRAPH,
  AttributeType::FLOATS,
  AttributeType::INTS,
  AttributeType::STRINGS,
  AttributeType::TENSORS,
  AttributeType::GRAPHS,
  AttributeType::SPARSE_TENSOR,
  AttributeType::SPARSE_TENSORS,
  AttributeType::TYPE_PROTO,
  AttributeType::TYPE_PROTOS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AttributeType(pub i32);
#[allow(non_upper_case_globals)]
impl AttributeType {
  pub const UNDEFINED: Self = Self(0);
  pub const FLOAT: Self = Self(1);
  pub const INT: Self = Self(2);
  pub const STRING: Self = Self(3);
  pub const TENSOR: Self = Self(4);
  pub const GRAPH: Self = Self(5);
  pub const FLOATS: Self = Self(6);
  pub const INTS: Self = Self(7);
  pub const STRINGS: Self = Self(8);
  pub const TENSORS: Self = Self(9);
  pub const GRAPHS: Self = Self(10);
  pub const SPARSE_TENSOR: Self = Self(11);
  pub const SPARSE_TENSORS: Self = Self(12);
  pub const TYPE_PROTO: Self = Self(13);
  pub const TYPE_PROTOS: Self = Self(14);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNDEFINED,
    Self::FLOAT,
    Self::INT,
    Self::STRING,
    Self::TENSOR,
    Self::GRAPH,
    Self::FLOATS,
    Self::INTS,
    Self::STRINGS,
    Self::TENSORS,
    Self::GRAPHS,
    Self::SPARSE_TENSOR,
    Self::SPARSE_TENSORS,
    Self::TYPE_PROTO,
    Self::TYPE_PROTOS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNDEFINED => Some("UNDEFINED"),
      Self::FLOAT => Some("FLOAT"),
      Self::INT => Some("INT"),
      Self::STRING => Some("STRING"),
      Self::TENSOR => Some("TENSOR"),
      Self::GRAPH => Some("GRAPH"),
      Self::FLOATS => Some("FLOATS"),
      Self::INTS => Some("INTS"),
      Self::STRINGS => Some("STRINGS"),
      Self::TENSORS => Some("TENSORS"),
      Self::GRAPHS => Some("GRAPHS"),
      Self::SPARSE_TENSOR => Some("SPARSE_TENSOR"),
      Self::SPARSE_TENSORS => Some("SPARSE_TENSORS"),
      Self::TYPE_PROTO => Some("TYPE_PROTO"),
      Self::TYPE_PROTOS => Some("TYPE_PROTOS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AttributeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AttributeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AttributeType {
    type Output = AttributeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AttributeType {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AttributeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AttributeType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_TYPE: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_TYPE: i32 = 24;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 25] = [
  DataType::UNDEFINED,
  DataType::FLOAT,
  DataType::UINT8,
  DataType::INT8,
  DataType::UINT16,
  DataType::INT16,
  DataType::INT32,
  DataType::INT64,
  DataType::STRING,
  DataType::BOOL,
  DataType::FLOAT16,
  DataType::DOUBLE,
  DataType::UINT32,
  DataType::UINT64,
  DataType::COMPLEX64,
  DataType::COMPLEX128,
  DataType::BFLOAT16,
  DataType::FLOAT8E4M3FN,
  DataType::FLOAT8E4M3FNUZ,
  DataType::FLOAT8E5M2,
  DataType::FLOAT8E5M2FNUZ,
  DataType::UINT4,
  DataType::INT4,
  DataType::FLOAT4E2M1,
  DataType::FLOAT8E8M0,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub i32);
#[allow(non_upper_case_globals)]
impl DataType {
  pub const UNDEFINED: Self = Self(0);
  pub const FLOAT: Self = Self(1);
  pub const UINT8: Self = Self(2);
  pub const INT8: Self = Self(3);
  pub const UINT16: Self = Self(4);
  pub const INT16: Self = Self(5);
  pub const INT32: Self = Self(6);
  pub const INT64: Self = Self(7);
  pub const STRING: Self = Self(8);
  pub const BOOL: Self = Self(9);
  pub const FLOAT16: Self = Self(10);
  pub const DOUBLE: Self = Self(11);
  pub const UINT32: Self = Self(12);
  pub const UINT64: Self = Self(13);
  pub const COMPLEX64: Self = Self(14);
  pub const COMPLEX128: Self = Self(15);
  pub const BFLOAT16: Self = Self(16);
  pub const FLOAT8E4M3FN: Self = Self(17);
  pub const FLOAT8E4M3FNUZ: Self = Self(18);
  pub const FLOAT8E5M2: Self = Self(19);
  pub const FLOAT8E5M2FNUZ: Self = Self(20);
  pub const UINT4: Self = Self(21);
  pub const INT4: Self = Self(22);
  pub const FLOAT4E2M1: Self = Self(23);
  pub const FLOAT8E8M0: Self = Self(24);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 24;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNDEFINED,
    Self::FLOAT,
    Self::UINT8,
    Self::INT8,
    Self::UINT16,
    Self::INT16,
    Self::INT32,
    Self::INT64,
    Self::STRING,
    Self::BOOL,
    Self::FLOAT16,
    Self::DOUBLE,
    Self::UINT32,
    Self::UINT64,
    Self::COMPLEX64,
    Self::COMPLEX128,
    Self::BFLOAT16,
    Self::FLOAT8E4M3FN,
    Self::FLOAT8E4M3FNUZ,
    Self::FLOAT8E5M2,
    Self::FLOAT8E5M2FNUZ,
    Self::UINT4,
    Self::INT4,
    Self::FLOAT4E2M1,
    Self::FLOAT8E8M0,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNDEFINED => Some("UNDEFINED"),
      Self::FLOAT => Some("FLOAT"),
      Self::UINT8 => Some("UINT8"),
      Self::INT8 => Some("INT8"),
      Self::UINT16 => Some("UINT16"),
      Self::INT16 => Some("INT16"),
      Self::INT32 => Some("INT32"),
      Self::INT64 => Some("INT64"),
      Self::STRING => Some("STRING"),
      Self::BOOL => Some("BOOL"),
      Self::FLOAT16 => Some("FLOAT16"),
      Self::DOUBLE => Some("DOUBLE"),
      Self::UINT32 => Some("UINT32"),
      Self::UINT64 => Some("UINT64"),
      Self::COMPLEX64 => Some("COMPLEX64"),
      Self::COMPLEX128 => Some("COMPLEX128"),
      Self::BFLOAT16 => Some("BFLOAT16"),
      Self::FLOAT8E4M3FN => Some("FLOAT8E4M3FN"),
      Self::FLOAT8E4M3FNUZ => Some("FLOAT8E4M3FNUZ"),
      Self::FLOAT8E5M2 => Some("FLOAT8E5M2"),
      Self::FLOAT8E5M2FNUZ => Some("FLOAT8E5M2FNUZ"),
      Self::UINT4 => Some("UINT4"),
      Self::INT4 => Some("INT4"),
      Self::FLOAT4E2M1 => Some("FLOAT4E2M1"),
      Self::FLOAT8E8M0 => Some("FLOAT8E8M0"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataType {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TENSOR_DATA_LOCATION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TENSOR_DATA_LOCATION: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TENSOR_DATA_LOCATION: [TensorDataLocation; 2] = [
  TensorDataLocation::DEFAULT,
  TensorDataLocation::EXTERNAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TensorDataLocation(pub u8);
#[allow(non_upper_case_globals)]
impl TensorDataLocation {
  pub const DEFAULT: Self = Self(0);
  pub const EXTERNAL: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::EXTERNAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DEFAULT => Some("DEFAULT"),
      Self::EXTERNAL => Some("EXTERNAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TensorDataLocation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TensorDataLocation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TensorDataLocation {
    type Output = TensorDataLocation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TensorDataLocation {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TensorDataLocation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TensorDataLocation {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OPERATOR_STATUS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OPERATOR_STATUS: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_STATUS: [OperatorStatus; 2] = [
  OperatorStatus::EXPERIMENTAL,
  OperatorStatus::STABLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorStatus(pub u8);
#[allow(non_upper_case_globals)]
impl OperatorStatus {
  pub const EXPERIMENTAL: Self = Self(0);
  pub const STABLE: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EXPERIMENTAL,
    Self::STABLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EXPERIMENTAL => Some("EXPERIMENTAL"),
      Self::STABLE => Some("STABLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OperatorStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OperatorStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OperatorStatus {
    type Output = OperatorStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OperatorStatus {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OperatorStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_VALUE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_VALUE_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_VALUE_TYPE: [DimensionValueType; 3] = [
  DimensionValueType::UNKNOWN,
  DimensionValueType::VALUE,
  DimensionValueType::PARAM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DimensionValueType(pub i8);
#[allow(non_upper_case_globals)]
impl DimensionValueType {
  pub const UNKNOWN: Self = Self(0);
  pub const VALUE: Self = Self(1);
  pub const PARAM: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::VALUE,
    Self::PARAM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::VALUE => Some("VALUE"),
      Self::PARAM => Some("PARAM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DimensionValueType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DimensionValueType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DimensionValueType {
    type Output = DimensionValueType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DimensionValueType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DimensionValueType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DimensionValueType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALUE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALUE_TYPE: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE_TYPE: [ValueType; 6] = [
  ValueType::NONE,
  ValueType::tensor_type,
  ValueType::sequence_type,
  ValueType::map_type,
  ValueType::optional_type,
  ValueType::sparse_tensor_type,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ValueType(pub u8);
#[allow(non_upper_case_globals)]
impl ValueType {
  pub const NONE: Self = Self(0);
  pub const tensor_type: Self = Self(1);
  pub const sequence_type: Self = Self(2);
  pub const map_type: Self = Self(3);
  pub const optional_type: Self = Self(4);
  pub const sparse_tensor_type: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::tensor_type,
    Self::sequence_type,
    Self::map_type,
    Self::optional_type,
    Self::sparse_tensor_type,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::tensor_type => Some("tensor_type"),
      Self::sequence_type => Some("sequence_type"),
      Self::map_type => Some("map_type"),
      Self::optional_type => Some("optional_type"),
      Self::sparse_tensor_type => Some("sparse_tensor_type"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ValueType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ValueType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ValueType {
    type Output = ValueType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ValueType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ValueType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ValueType {}
pub struct ValueTypeUnionTableOffset {}

pub enum AttributeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Attribute<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Attribute<'a> {
  type Inner = Attribute<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Attribute<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_REF_ATTR_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_F: flatbuffers::VOffsetT = 12;
  pub const VT_I: flatbuffers::VOffsetT = 14;
  pub const VT_S: flatbuffers::VOffsetT = 16;
  pub const VT_T: flatbuffers::VOffsetT = 18;
  pub const VT_G: flatbuffers::VOffsetT = 20;
  pub const VT_SPARSE_TENSOR: flatbuffers::VOffsetT = 22;
  pub const VT_TP: flatbuffers::VOffsetT = 24;
  pub const VT_FLOATS: flatbuffers::VOffsetT = 26;
  pub const VT_INTS: flatbuffers::VOffsetT = 28;
  pub const VT_STRINGS: flatbuffers::VOffsetT = 30;
  pub const VT_TENSORS: flatbuffers::VOffsetT = 32;
  pub const VT_GRAPHS: flatbuffers::VOffsetT = 34;
  pub const VT_SPARSE_TENSORS: flatbuffers::VOffsetT = 36;
  pub const VT_TYPES: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Attribute { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AttributeArgs<'args>
  ) -> flatbuffers::WIPOffset<Attribute<'bldr>> {
    let mut builder = AttributeBuilder::new(_fbb);
    builder.add_i(args.i);
    if let Some(x) = args.types { builder.add_types(x); }
    if let Some(x) = args.sparse_tensors { builder.add_sparse_tensors(x); }
    if let Some(x) = args.graphs { builder.add_graphs(x); }
    if let Some(x) = args.tensors { builder.add_tensors(x); }
    if let Some(x) = args.strings { builder.add_strings(x); }
    if let Some(x) = args.ints { builder.add_ints(x); }
    if let Some(x) = args.floats { builder.add_floats(x); }
    if let Some(x) = args.tp { builder.add_tp(x); }
    if let Some(x) = args.sparse_tensor { builder.add_sparse_tensor(x); }
    if let Some(x) = args.g { builder.add_g(x); }
    if let Some(x) = args.t { builder.add_t(x); }
    if let Some(x) = args.s { builder.add_s(x); }
    builder.add_f(args.f);
    builder.add_type_(args.type_);
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.ref_attr_name { builder.add_ref_attr_name(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Attribute::VT_NAME, None)}
  }
  #[inline]
  pub fn ref_attr_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Attribute::VT_REF_ATTR_NAME, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Attribute::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn type_(&self) -> AttributeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AttributeType>(Attribute::VT_TYPE_, Some(AttributeType::UNDEFINED)).unwrap()}
  }
  #[inline]
  pub fn f(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Attribute::VT_F, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn i(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Attribute::VT_I, Some(0)).unwrap()}
  }
  #[inline]
  pub fn s(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Attribute::VT_S, None)}
  }
  #[inline]
  pub fn t(&self) -> Option<Tensor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Attribute::VT_T, None)}
  }
  #[inline]
  pub fn g(&self) -> Option<Graph<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Graph>>(Attribute::VT_G, None)}
  }
  #[inline]
  pub fn sparse_tensor(&self) -> Option<SparseTensor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SparseTensor>>(Attribute::VT_SPARSE_TENSOR, None)}
  }
  #[inline]
  pub fn tp(&self) -> Option<TypeInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TypeInfo>>(Attribute::VT_TP, None)}
  }
  #[inline]
  pub fn floats(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Attribute::VT_FLOATS, None)}
  }
  #[inline]
  pub fn ints(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Attribute::VT_INTS, None)}
  }
  #[inline]
  pub fn strings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Attribute::VT_STRINGS, None)}
  }
  #[inline]
  pub fn tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor>>>>(Attribute::VT_TENSORS, None)}
  }
  #[inline]
  pub fn graphs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Graph<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Graph>>>>(Attribute::VT_GRAPHS, None)}
  }
  #[inline]
  pub fn sparse_tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensor>>>>(Attribute::VT_SPARSE_TENSORS, None)}
  }
  #[inline]
  pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeInfo>>>>(Attribute::VT_TYPES, None)}
  }
}

impl flatbuffers::Verifiable for Attribute<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ref_attr_name", Self::VT_REF_ATTR_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<AttributeType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f32>("f", Self::VT_F, false)?
     .visit_field::<i64>("i", Self::VT_I, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("s", Self::VT_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>("t", Self::VT_T, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("g", Self::VT_G, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SparseTensor>>("sparse_tensor", Self::VT_SPARSE_TENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TypeInfo>>("tp", Self::VT_TP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("floats", Self::VT_FLOATS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ints", Self::VT_INTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("strings", Self::VT_STRINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tensor>>>>("tensors", Self::VT_TENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Graph>>>>("graphs", Self::VT_GRAPHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SparseTensor>>>>("sparse_tensors", Self::VT_SPARSE_TENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TypeInfo>>>>("types", Self::VT_TYPES, false)?
     .finish();
    Ok(())
  }
}
pub struct AttributeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ref_attr_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: AttributeType,
    pub f: f32,
    pub i: i64,
    pub s: Option<flatbuffers::WIPOffset<&'a str>>,
    pub t: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub g: Option<flatbuffers::WIPOffset<Graph<'a>>>,
    pub sparse_tensor: Option<flatbuffers::WIPOffset<SparseTensor<'a>>>,
    pub tp: Option<flatbuffers::WIPOffset<TypeInfo<'a>>>,
    pub floats: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub ints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>>>,
    pub graphs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Graph<'a>>>>>,
    pub sparse_tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensor<'a>>>>>,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeInfo<'a>>>>>,
}
impl<'a> Default for AttributeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AttributeArgs {
      name: None,
      ref_attr_name: None,
      doc_string: None,
      type_: AttributeType::UNDEFINED,
      f: 0.0,
      i: 0,
      s: None,
      t: None,
      g: None,
      sparse_tensor: None,
      tp: None,
      floats: None,
      ints: None,
      strings: None,
      tensors: None,
      graphs: None,
      sparse_tensors: None,
      types: None,
    }
  }
}

pub struct AttributeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AttributeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_NAME, name);
  }
  #[inline]
  pub fn add_ref_attr_name(&mut self, ref_attr_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_REF_ATTR_NAME, ref_attr_name);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: AttributeType) {
    self.fbb_.push_slot::<AttributeType>(Attribute::VT_TYPE_, type_, AttributeType::UNDEFINED);
  }
  #[inline]
  pub fn add_f(&mut self, f: f32) {
    self.fbb_.push_slot::<f32>(Attribute::VT_F, f, 0.0);
  }
  #[inline]
  pub fn add_i(&mut self, i: i64) {
    self.fbb_.push_slot::<i64>(Attribute::VT_I, i, 0);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_S, s);
  }
  #[inline]
  pub fn add_t(&mut self, t: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Attribute::VT_T, t);
  }
  #[inline]
  pub fn add_g(&mut self, g: flatbuffers::WIPOffset<Graph<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Graph>>(Attribute::VT_G, g);
  }
  #[inline]
  pub fn add_sparse_tensor(&mut self, sparse_tensor: flatbuffers::WIPOffset<SparseTensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SparseTensor>>(Attribute::VT_SPARSE_TENSOR, sparse_tensor);
  }
  #[inline]
  pub fn add_tp(&mut self, tp: flatbuffers::WIPOffset<TypeInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TypeInfo>>(Attribute::VT_TP, tp);
  }
  #[inline]
  pub fn add_floats(&mut self, floats: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_FLOATS, floats);
  }
  #[inline]
  pub fn add_ints(&mut self, ints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_INTS, ints);
  }
  #[inline]
  pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_STRINGS, strings);
  }
  #[inline]
  pub fn add_tensors(&mut self, tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Tensor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_TENSORS, tensors);
  }
  #[inline]
  pub fn add_graphs(&mut self, graphs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Graph<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_GRAPHS, graphs);
  }
  #[inline]
  pub fn add_sparse_tensors(&mut self, sparse_tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SparseTensor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_SPARSE_TENSORS, sparse_tensors);
  }
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TypeInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Attribute::VT_TYPES, types);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AttributeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AttributeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Attribute<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Attribute<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Attribute");
      ds.field("name", &self.name());
      ds.field("ref_attr_name", &self.ref_attr_name());
      ds.field("doc_string", &self.doc_string());
      ds.field("type_", &self.type_());
      ds.field("f", &self.f());
      ds.field("i", &self.i());
      ds.field("s", &self.s());
      ds.field("t", &self.t());
      ds.field("g", &self.g());
      ds.field("sparse_tensor", &self.sparse_tensor());
      ds.field("tp", &self.tp());
      ds.field("floats", &self.floats());
      ds.field("ints", &self.ints());
      ds.field("strings", &self.strings());
      ds.field("tensors", &self.tensors());
      ds.field("graphs", &self.graphs());
      ds.field("sparse_tensors", &self.sparse_tensors());
      ds.field("types", &self.types());
      ds.finish()
  }
}
pub enum IntIntListEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntIntListEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntIntListEntry<'a> {
  type Inner = IntIntListEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntIntListEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntIntListEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntIntListEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<IntIntListEntry<'bldr>> {
    let mut builder = IntIntListEntryBuilder::new(_fbb);
    builder.add_key(args.key);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntIntListEntry::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(IntIntListEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for IntIntListEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntIntListEntryArgs<'a> {
    pub key: i64,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for IntIntListEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntIntListEntryArgs {
      key: 0,
      value: None,
    }
  }
}

pub struct IntIntListEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntIntListEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: i64) {
    self.fbb_.push_slot::<i64>(IntIntListEntry::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntIntListEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntIntListEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntIntListEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntIntListEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntIntListEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntIntListEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum NodeDeviceConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NodeDeviceConfiguration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NodeDeviceConfiguration<'a> {
  type Inner = NodeDeviceConfiguration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NodeDeviceConfiguration<'a> {
  pub const VT_CONFIGURATION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SHARDING_SPEC: flatbuffers::VOffsetT = 6;
  pub const VT_PIPELINE_STAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NodeDeviceConfiguration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NodeDeviceConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<NodeDeviceConfiguration<'bldr>> {
    let mut builder = NodeDeviceConfigurationBuilder::new(_fbb);
    builder.add_pipeline_stage(args.pipeline_stage);
    if let Some(x) = args.sharding_spec { builder.add_sharding_spec(x); }
    if let Some(x) = args.configuration_id { builder.add_configuration_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn configuration_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeDeviceConfiguration::VT_CONFIGURATION_ID, None)}
  }
  #[inline]
  pub fn sharding_spec(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShardingSpec<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShardingSpec>>>>(NodeDeviceConfiguration::VT_SHARDING_SPEC, None)}
  }
  #[inline]
  pub fn pipeline_stage(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(NodeDeviceConfiguration::VT_PIPELINE_STAGE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NodeDeviceConfiguration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("configuration_id", Self::VT_CONFIGURATION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShardingSpec>>>>("sharding_spec", Self::VT_SHARDING_SPEC, false)?
     .visit_field::<i32>("pipeline_stage", Self::VT_PIPELINE_STAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeDeviceConfigurationArgs<'a> {
    pub configuration_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sharding_spec: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShardingSpec<'a>>>>>,
    pub pipeline_stage: i32,
}
impl<'a> Default for NodeDeviceConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeDeviceConfigurationArgs {
      configuration_id: None,
      sharding_spec: None,
      pipeline_stage: 0,
    }
  }
}

pub struct NodeDeviceConfigurationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeDeviceConfigurationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_configuration_id(&mut self, configuration_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeDeviceConfiguration::VT_CONFIGURATION_ID, configuration_id);
  }
  #[inline]
  pub fn add_sharding_spec(&mut self, sharding_spec: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ShardingSpec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeDeviceConfiguration::VT_SHARDING_SPEC, sharding_spec);
  }
  #[inline]
  pub fn add_pipeline_stage(&mut self, pipeline_stage: i32) {
    self.fbb_.push_slot::<i32>(NodeDeviceConfiguration::VT_PIPELINE_STAGE, pipeline_stage, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NodeDeviceConfigurationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NodeDeviceConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NodeDeviceConfiguration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NodeDeviceConfiguration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NodeDeviceConfiguration");
      ds.field("configuration_id", &self.configuration_id());
      ds.field("sharding_spec", &self.sharding_spec());
      ds.field("pipeline_stage", &self.pipeline_stage());
      ds.finish()
  }
}
pub enum ShardingSpecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShardingSpec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShardingSpec<'a> {
  type Inner = ShardingSpec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShardingSpec<'a> {
  pub const VT_TENSOR_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DEVICE: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX_TO_DEVICE_GROUP_MAP: flatbuffers::VOffsetT = 8;
  pub const VT_SHARDED_DIM: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShardingSpec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShardingSpecArgs<'args>
  ) -> flatbuffers::WIPOffset<ShardingSpec<'bldr>> {
    let mut builder = ShardingSpecBuilder::new(_fbb);
    if let Some(x) = args.sharded_dim { builder.add_sharded_dim(x); }
    if let Some(x) = args.index_to_device_group_map { builder.add_index_to_device_group_map(x); }
    if let Some(x) = args.device { builder.add_device(x); }
    if let Some(x) = args.tensor_name { builder.add_tensor_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn tensor_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShardingSpec::VT_TENSOR_NAME, None)}
  }
  #[inline]
  pub fn device(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ShardingSpec::VT_DEVICE, None)}
  }
  #[inline]
  pub fn index_to_device_group_map(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntIntListEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntIntListEntry>>>>(ShardingSpec::VT_INDEX_TO_DEVICE_GROUP_MAP, None)}
  }
  #[inline]
  pub fn sharded_dim(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShardedDim<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShardedDim>>>>(ShardingSpec::VT_SHARDED_DIM, None)}
  }
}

impl flatbuffers::Verifiable for ShardingSpec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tensor_name", Self::VT_TENSOR_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("device", Self::VT_DEVICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntIntListEntry>>>>("index_to_device_group_map", Self::VT_INDEX_TO_DEVICE_GROUP_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShardedDim>>>>("sharded_dim", Self::VT_SHARDED_DIM, false)?
     .finish();
    Ok(())
  }
}
pub struct ShardingSpecArgs<'a> {
    pub tensor_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub device: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub index_to_device_group_map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntIntListEntry<'a>>>>>,
    pub sharded_dim: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShardedDim<'a>>>>>,
}
impl<'a> Default for ShardingSpecArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShardingSpecArgs {
      tensor_name: None,
      device: None,
      index_to_device_group_map: None,
      sharded_dim: None,
    }
  }
}

pub struct ShardingSpecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShardingSpecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tensor_name(&mut self, tensor_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShardingSpec::VT_TENSOR_NAME, tensor_name);
  }
  #[inline]
  pub fn add_device(&mut self, device: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShardingSpec::VT_DEVICE, device);
  }
  #[inline]
  pub fn add_index_to_device_group_map(&mut self, index_to_device_group_map: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntIntListEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShardingSpec::VT_INDEX_TO_DEVICE_GROUP_MAP, index_to_device_group_map);
  }
  #[inline]
  pub fn add_sharded_dim(&mut self, sharded_dim: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ShardedDim<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShardingSpec::VT_SHARDED_DIM, sharded_dim);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShardingSpecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShardingSpecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShardingSpec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShardingSpec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShardingSpec");
      ds.field("tensor_name", &self.tensor_name());
      ds.field("device", &self.device());
      ds.field("index_to_device_group_map", &self.index_to_device_group_map());
      ds.field("sharded_dim", &self.sharded_dim());
      ds.finish()
  }
}
pub enum ShardedDimOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShardedDim<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShardedDim<'a> {
  type Inner = ShardedDim<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShardedDim<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;
  pub const VT_SIMPLE_SHARDING: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShardedDim { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShardedDimArgs<'args>
  ) -> flatbuffers::WIPOffset<ShardedDim<'bldr>> {
    let mut builder = ShardedDimBuilder::new(_fbb);
    builder.add_axis(args.axis);
    if let Some(x) = args.simple_sharding { builder.add_simple_sharding(x); }
    builder.finish()
  }


  #[inline]
  pub fn axis(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ShardedDim::VT_AXIS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn simple_sharding(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SimpleShardedDim<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SimpleShardedDim>>>>(ShardedDim::VT_SIMPLE_SHARDING, None)}
  }
}

impl flatbuffers::Verifiable for ShardedDim<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("axis", Self::VT_AXIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SimpleShardedDim>>>>("simple_sharding", Self::VT_SIMPLE_SHARDING, false)?
     .finish();
    Ok(())
  }
}
pub struct ShardedDimArgs<'a> {
    pub axis: i64,
    pub simple_sharding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SimpleShardedDim<'a>>>>>,
}
impl<'a> Default for ShardedDimArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShardedDimArgs {
      axis: 0,
      simple_sharding: None,
    }
  }
}

pub struct ShardedDimBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShardedDimBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_axis(&mut self, axis: i64) {
    self.fbb_.push_slot::<i64>(ShardedDim::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn add_simple_sharding(&mut self, simple_sharding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SimpleShardedDim<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShardedDim::VT_SIMPLE_SHARDING, simple_sharding);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShardedDimBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShardedDimBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShardedDim<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShardedDim<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShardedDim");
      ds.field("axis", &self.axis());
      ds.field("simple_sharding", &self.simple_sharding());
      ds.finish()
  }
}
pub enum SimpleShardedDimOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SimpleShardedDim<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SimpleShardedDim<'a> {
  type Inner = SimpleShardedDim<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SimpleShardedDim<'a> {
  pub const VT_DIM: flatbuffers::VOffsetT = 4;
  pub const VT_NUM_SHARDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SimpleShardedDim { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SimpleShardedDimArgs<'args>
  ) -> flatbuffers::WIPOffset<SimpleShardedDim<'bldr>> {
    let mut builder = SimpleShardedDimBuilder::new(_fbb);
    builder.add_num_shards(args.num_shards);
    if let Some(x) = args.dim { builder.add_dim(x); }
    builder.finish()
  }


  #[inline]
  pub fn dim(&self) -> Option<DimensionValue<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionValue>>(SimpleShardedDim::VT_DIM, None)}
  }
  #[inline]
  pub fn num_shards(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(SimpleShardedDim::VT_NUM_SHARDS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SimpleShardedDim<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionValue>>("dim", Self::VT_DIM, false)?
     .visit_field::<i64>("num_shards", Self::VT_NUM_SHARDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SimpleShardedDimArgs<'a> {
    pub dim: Option<flatbuffers::WIPOffset<DimensionValue<'a>>>,
    pub num_shards: i64,
}
impl<'a> Default for SimpleShardedDimArgs<'a> {
  #[inline]
  fn default() -> Self {
    SimpleShardedDimArgs {
      dim: None,
      num_shards: 0,
    }
  }
}

pub struct SimpleShardedDimBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SimpleShardedDimBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dim(&mut self, dim: flatbuffers::WIPOffset<DimensionValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionValue>>(SimpleShardedDim::VT_DIM, dim);
  }
  #[inline]
  pub fn add_num_shards(&mut self, num_shards: i64) {
    self.fbb_.push_slot::<i64>(SimpleShardedDim::VT_NUM_SHARDS, num_shards, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SimpleShardedDimBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SimpleShardedDimBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SimpleShardedDim<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SimpleShardedDim<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SimpleShardedDim");
      ds.field("dim", &self.dim());
      ds.field("num_shards", &self.num_shards());
      ds.finish()
  }
}
pub enum TrainingInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TrainingInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TrainingInfo<'a> {
  type Inner = TrainingInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TrainingInfo<'a> {
  pub const VT_INITIALIZATION: flatbuffers::VOffsetT = 4;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 6;
  pub const VT_INITIALIZATION_BINDING: flatbuffers::VOffsetT = 8;
  pub const VT_UPDATE_BINDING: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TrainingInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TrainingInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<TrainingInfo<'bldr>> {
    let mut builder = TrainingInfoBuilder::new(_fbb);
    if let Some(x) = args.update_binding { builder.add_update_binding(x); }
    if let Some(x) = args.initialization_binding { builder.add_initialization_binding(x); }
    if let Some(x) = args.algorithm { builder.add_algorithm(x); }
    if let Some(x) = args.initialization { builder.add_initialization(x); }
    builder.finish()
  }


  #[inline]
  pub fn initialization(&self) -> Option<Graph<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Graph>>(TrainingInfo::VT_INITIALIZATION, None)}
  }
  #[inline]
  pub fn algorithm(&self) -> Option<Graph<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Graph>>(TrainingInfo::VT_ALGORITHM, None)}
  }
  #[inline]
  pub fn initialization_binding(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(TrainingInfo::VT_INITIALIZATION_BINDING, None)}
  }
  #[inline]
  pub fn update_binding(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(TrainingInfo::VT_UPDATE_BINDING, None)}
  }
}

impl flatbuffers::Verifiable for TrainingInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("initialization", Self::VT_INITIALIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("initialization_binding", Self::VT_INITIALIZATION_BINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("update_binding", Self::VT_UPDATE_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct TrainingInfoArgs<'a> {
    pub initialization: Option<flatbuffers::WIPOffset<Graph<'a>>>,
    pub algorithm: Option<flatbuffers::WIPOffset<Graph<'a>>>,
    pub initialization_binding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
    pub update_binding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for TrainingInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrainingInfoArgs {
      initialization: None,
      algorithm: None,
      initialization_binding: None,
      update_binding: None,
    }
  }
}

pub struct TrainingInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TrainingInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_initialization(&mut self, initialization: flatbuffers::WIPOffset<Graph<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Graph>>(TrainingInfo::VT_INITIALIZATION, initialization);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: flatbuffers::WIPOffset<Graph<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Graph>>(TrainingInfo::VT_ALGORITHM, algorithm);
  }
  #[inline]
  pub fn add_initialization_binding(&mut self, initialization_binding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrainingInfo::VT_INITIALIZATION_BINDING, initialization_binding);
  }
  #[inline]
  pub fn add_update_binding(&mut self, update_binding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrainingInfo::VT_UPDATE_BINDING, update_binding);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TrainingInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TrainingInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TrainingInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TrainingInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TrainingInfo");
      ds.field("initialization", &self.initialization());
      ds.field("algorithm", &self.algorithm());
      ds.field("initialization_binding", &self.initialization_binding());
      ds.field("update_binding", &self.update_binding());
      ds.finish()
  }
}
pub enum DeviceConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeviceConfiguration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeviceConfiguration<'a> {
  type Inner = DeviceConfiguration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DeviceConfiguration<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_NUM_DEVICES: flatbuffers::VOffsetT = 6;
  pub const VT_DEVICE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DeviceConfiguration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DeviceConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<DeviceConfiguration<'bldr>> {
    let mut builder = DeviceConfigurationBuilder::new(_fbb);
    if let Some(x) = args.device { builder.add_device(x); }
    builder.add_num_devices(args.num_devices);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DeviceConfiguration::VT_NAME, None)}
  }
  #[inline]
  pub fn num_devices(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DeviceConfiguration::VT_NUM_DEVICES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn device(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DeviceConfiguration::VT_DEVICE, None)}
  }
}

impl flatbuffers::Verifiable for DeviceConfiguration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("num_devices", Self::VT_NUM_DEVICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("device", Self::VT_DEVICE, false)?
     .finish();
    Ok(())
  }
}
pub struct DeviceConfigurationArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub num_devices: i32,
    pub device: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for DeviceConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    DeviceConfigurationArgs {
      name: None,
      num_devices: 0,
      device: None,
    }
  }
}

pub struct DeviceConfigurationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DeviceConfigurationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeviceConfiguration::VT_NAME, name);
  }
  #[inline]
  pub fn add_num_devices(&mut self, num_devices: i32) {
    self.fbb_.push_slot::<i32>(DeviceConfiguration::VT_NUM_DEVICES, num_devices, 0);
  }
  #[inline]
  pub fn add_device(&mut self, device: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeviceConfiguration::VT_DEVICE, device);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DeviceConfigurationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DeviceConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeviceConfiguration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DeviceConfiguration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DeviceConfiguration");
      ds.field("name", &self.name());
      ds.field("num_devices", &self.num_devices());
      ds.field("device", &self.device());
      ds.finish()
  }
}
pub enum StringStringEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringStringEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringStringEntry<'a> {
  type Inner = StringStringEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringStringEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringStringEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringStringEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<StringStringEntry<'bldr>> {
    let mut builder = StringStringEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringStringEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringStringEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for StringStringEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct StringStringEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringStringEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringStringEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct StringStringEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringStringEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringStringEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringStringEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringStringEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringStringEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringStringEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringStringEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringStringEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum TensorAnnotationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorAnnotation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorAnnotation<'a> {
  type Inner = TensorAnnotation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorAnnotation<'a> {
  pub const VT_TENSOR_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_QUANT_PARAMETER_TENSOR_NAMES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorAnnotation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorAnnotationArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorAnnotation<'bldr>> {
    let mut builder = TensorAnnotationBuilder::new(_fbb);
    if let Some(x) = args.quant_parameter_tensor_names { builder.add_quant_parameter_tensor_names(x); }
    if let Some(x) = args.tensor_name { builder.add_tensor_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn tensor_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorAnnotation::VT_TENSOR_NAME, None)}
  }
  #[inline]
  pub fn quant_parameter_tensor_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(TensorAnnotation::VT_QUANT_PARAMETER_TENSOR_NAMES, None)}
  }
}

impl flatbuffers::Verifiable for TensorAnnotation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tensor_name", Self::VT_TENSOR_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("quant_parameter_tensor_names", Self::VT_QUANT_PARAMETER_TENSOR_NAMES, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorAnnotationArgs<'a> {
    pub tensor_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quant_parameter_tensor_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for TensorAnnotationArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorAnnotationArgs {
      tensor_name: None,
      quant_parameter_tensor_names: None,
    }
  }
}

pub struct TensorAnnotationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorAnnotationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tensor_name(&mut self, tensor_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorAnnotation::VT_TENSOR_NAME, tensor_name);
  }
  #[inline]
  pub fn add_quant_parameter_tensor_names(&mut self, quant_parameter_tensor_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorAnnotation::VT_QUANT_PARAMETER_TENSOR_NAMES, quant_parameter_tensor_names);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorAnnotationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorAnnotationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorAnnotation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorAnnotation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorAnnotation");
      ds.field("tensor_name", &self.tensor_name());
      ds.field("quant_parameter_tensor_names", &self.quant_parameter_tensor_names());
      ds.finish()
  }
}
pub enum TensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
  type Inner = Tensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tensor<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 6;
  pub const VT_DIMS: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_RAW_DATA: flatbuffers::VOffsetT = 12;
  pub const VT_STRING_DATA: flatbuffers::VOffsetT = 14;
  pub const VT_EXTERNAL_DATA: flatbuffers::VOffsetT = 16;
  pub const VT_DATA_LOCATION: flatbuffers::VOffsetT = 18;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorArgs<'args>
  ) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
    let mut builder = TensorBuilder::new(_fbb);
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.external_data { builder.add_external_data(x); }
    if let Some(x) = args.string_data { builder.add_string_data(x); }
    if let Some(x) = args.raw_data { builder.add_raw_data(x); }
    builder.add_data_type(args.data_type);
    if let Some(x) = args.dims { builder.add_dims(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_data_location(args.data_location);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tensor::VT_NAME, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tensor::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn dims(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Tensor::VT_DIMS, None)}
  }
  #[inline]
  pub fn data_type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Tensor::VT_DATA_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn raw_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Tensor::VT_RAW_DATA, None)}
  }
  #[inline]
  pub fn string_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Tensor::VT_STRING_DATA, None)}
  }
  #[inline]
  pub fn external_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(Tensor::VT_EXTERNAL_DATA, None)}
  }
  #[inline]
  pub fn data_location(&self) -> TensorDataLocation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TensorDataLocation>(Tensor::VT_DATA_LOCATION, Some(TensorDataLocation::DEFAULT)).unwrap()}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(Tensor::VT_METADATA_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for Tensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("dims", Self::VT_DIMS, false)?
     .visit_field::<i32>("data_type", Self::VT_DATA_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("raw_data", Self::VT_RAW_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("string_data", Self::VT_STRING_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("external_data", Self::VT_EXTERNAL_DATA, false)?
     .visit_field::<TensorDataLocation>("data_location", Self::VT_DATA_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub data_type: i32,
    pub raw_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub string_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub external_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
    pub data_location: TensorDataLocation,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for TensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorArgs {
      name: None,
      doc_string: None,
      dims: None,
      data_type: 0,
      raw_data: None,
      string_data: None,
      external_data: None,
      data_location: TensorDataLocation::DEFAULT,
      metadata_props: None,
    }
  }
}

pub struct TensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_NAME, name);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_dims(&mut self, dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_DIMS, dims);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: i32) {
    self.fbb_.push_slot::<i32>(Tensor::VT_DATA_TYPE, data_type, 0);
  }
  #[inline]
  pub fn add_raw_data(&mut self, raw_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_RAW_DATA, raw_data);
  }
  #[inline]
  pub fn add_string_data(&mut self, string_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_STRING_DATA, string_data);
  }
  #[inline]
  pub fn add_external_data(&mut self, external_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_EXTERNAL_DATA, external_data);
  }
  #[inline]
  pub fn add_data_location(&mut self, data_location: TensorDataLocation) {
    self.fbb_.push_slot::<TensorDataLocation>(Tensor::VT_DATA_LOCATION, data_location, TensorDataLocation::DEFAULT);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tensor");
      ds.field("name", &self.name());
      ds.field("doc_string", &self.doc_string());
      ds.field("dims", &self.dims());
      ds.field("data_type", &self.data_type());
      ds.field("raw_data", &self.raw_data());
      ds.field("string_data", &self.string_data());
      ds.field("external_data", &self.external_data());
      ds.field("data_location", &self.data_location());
      ds.field("metadata_props", &self.metadata_props());
      ds.finish()
  }
}
pub enum TensorSegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorSegment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorSegment<'a> {
  type Inner = TensorSegment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorSegment<'a> {
  pub const VT_BEGIN: flatbuffers::VOffsetT = 4;
  pub const VT_END: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorSegment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorSegmentArgs
  ) -> flatbuffers::WIPOffset<TensorSegment<'bldr>> {
    let mut builder = TensorSegmentBuilder::new(_fbb);
    builder.add_end(args.end);
    builder.add_begin(args.begin);
    builder.finish()
  }


  #[inline]
  pub fn begin(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorSegment::VT_BEGIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn end(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorSegment::VT_END, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TensorSegment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("begin", Self::VT_BEGIN, false)?
     .visit_field::<i64>("end", Self::VT_END, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorSegmentArgs {
    pub begin: i64,
    pub end: i64,
}
impl<'a> Default for TensorSegmentArgs {
  #[inline]
  fn default() -> Self {
    TensorSegmentArgs {
      begin: 0,
      end: 0,
    }
  }
}

pub struct TensorSegmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorSegmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_begin(&mut self, begin: i64) {
    self.fbb_.push_slot::<i64>(TensorSegment::VT_BEGIN, begin, 0);
  }
  #[inline]
  pub fn add_end(&mut self, end: i64) {
    self.fbb_.push_slot::<i64>(TensorSegment::VT_END, end, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorSegmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorSegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorSegment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorSegment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorSegment");
      ds.field("begin", &self.begin());
      ds.field("end", &self.end());
      ds.finish()
  }
}
pub enum SparseTensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseTensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseTensor<'a> {
  type Inner = SparseTensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SparseTensor<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_INDICES: flatbuffers::VOffsetT = 6;
  pub const VT_DIMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparseTensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SparseTensorArgs<'args>
  ) -> flatbuffers::WIPOffset<SparseTensor<'bldr>> {
    let mut builder = SparseTensorBuilder::new(_fbb);
    if let Some(x) = args.dims { builder.add_dims(x); }
    if let Some(x) = args.indices { builder.add_indices(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<Tensor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(SparseTensor::VT_VALUES, None)}
  }
  #[inline]
  pub fn indices(&self) -> Option<Tensor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(SparseTensor::VT_INDICES, None)}
  }
  #[inline]
  pub fn dims(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(SparseTensor::VT_DIMS, None)}
  }
}

impl flatbuffers::Verifiable for SparseTensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>("values", Self::VT_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>("indices", Self::VT_INDICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("dims", Self::VT_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SparseTensorArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub indices: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for SparseTensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    SparseTensorArgs {
      values: None,
      indices: None,
      dims: None,
    }
  }
}

pub struct SparseTensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SparseTensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(SparseTensor::VT_VALUES, values);
  }
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(SparseTensor::VT_INDICES, indices);
  }
  #[inline]
  pub fn add_dims(&mut self, dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SparseTensor::VT_DIMS, dims);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SparseTensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SparseTensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparseTensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparseTensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparseTensor");
      ds.field("values", &self.values());
      ds.field("indices", &self.indices());
      ds.field("dims", &self.dims());
      ds.finish()
  }
}
pub enum ShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Shape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Shape<'a> {
  type Inner = Shape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Shape<'a> {
  pub const VT_DIM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Shape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShapeArgs<'args>
  ) -> flatbuffers::WIPOffset<Shape<'bldr>> {
    let mut builder = ShapeBuilder::new(_fbb);
    if let Some(x) = args.dim { builder.add_dim(x); }
    builder.finish()
  }


  #[inline]
  pub fn dim(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dimension<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dimension>>>>(Shape::VT_DIM, None)}
  }
}

impl flatbuffers::Verifiable for Shape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Dimension>>>>("dim", Self::VT_DIM, false)?
     .finish();
    Ok(())
  }
}
pub struct ShapeArgs<'a> {
    pub dim: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dimension<'a>>>>>,
}
impl<'a> Default for ShapeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShapeArgs {
      dim: None,
    }
  }
}

pub struct ShapeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShapeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dim(&mut self, dim: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Dimension<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shape::VT_DIM, dim);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShapeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Shape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Shape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Shape");
      ds.field("dim", &self.dim());
      ds.finish()
  }
}
pub enum DimensionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dimension<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dimension<'a> {
  type Inner = Dimension<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Dimension<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DENOTATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Dimension { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionArgs<'args>
  ) -> flatbuffers::WIPOffset<Dimension<'bldr>> {
    let mut builder = DimensionBuilder::new(_fbb);
    if let Some(x) = args.denotation { builder.add_denotation(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<DimensionValue<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionValue>>(Dimension::VT_VALUE, None)}
  }
  #[inline]
  pub fn denotation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Dimension::VT_DENOTATION, None)}
  }
}

impl flatbuffers::Verifiable for Dimension<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionValue>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("denotation", Self::VT_DENOTATION, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<DimensionValue<'a>>>,
    pub denotation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimensionArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionArgs {
      value: None,
      denotation: None,
    }
  }
}

pub struct DimensionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<DimensionValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionValue>>(Dimension::VT_VALUE, value);
  }
  #[inline]
  pub fn add_denotation(&mut self, denotation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dimension::VT_DENOTATION, denotation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dimension<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Dimension<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Dimension");
      ds.field("value", &self.value());
      ds.field("denotation", &self.denotation());
      ds.finish()
  }
}
pub enum DimensionValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionValue<'a> {
  type Inner = DimensionValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionValue<'a> {
  pub const VT_DIM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DIM_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_DIM_PARAM: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionValueArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionValue<'bldr>> {
    let mut builder = DimensionValueBuilder::new(_fbb);
    builder.add_dim_value(args.dim_value);
    if let Some(x) = args.dim_param { builder.add_dim_param(x); }
    builder.add_dim_type(args.dim_type);
    builder.finish()
  }


  #[inline]
  pub fn dim_type(&self) -> DimensionValueType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DimensionValueType>(DimensionValue::VT_DIM_TYPE, Some(DimensionValueType::UNKNOWN)).unwrap()}
  }
  #[inline]
  pub fn dim_value(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(DimensionValue::VT_DIM_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dim_param(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DimensionValue::VT_DIM_PARAM, None)}
  }
}

impl flatbuffers::Verifiable for DimensionValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DimensionValueType>("dim_type", Self::VT_DIM_TYPE, false)?
     .visit_field::<i64>("dim_value", Self::VT_DIM_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dim_param", Self::VT_DIM_PARAM, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionValueArgs<'a> {
    pub dim_type: DimensionValueType,
    pub dim_value: i64,
    pub dim_param: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimensionValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionValueArgs {
      dim_type: DimensionValueType::UNKNOWN,
      dim_value: 0,
      dim_param: None,
    }
  }
}

pub struct DimensionValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dim_type(&mut self, dim_type: DimensionValueType) {
    self.fbb_.push_slot::<DimensionValueType>(DimensionValue::VT_DIM_TYPE, dim_type, DimensionValueType::UNKNOWN);
  }
  #[inline]
  pub fn add_dim_value(&mut self, dim_value: i64) {
    self.fbb_.push_slot::<i64>(DimensionValue::VT_DIM_VALUE, dim_value, 0);
  }
  #[inline]
  pub fn add_dim_param(&mut self, dim_param: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionValue::VT_DIM_PARAM, dim_param);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionValue");
      ds.field("dim_type", &self.dim_type());
      ds.field("dim_value", &self.dim_value());
      ds.field("dim_param", &self.dim_param());
      ds.finish()
  }
}
pub enum TypeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TypeInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TypeInfo<'a> {
  type Inner = TypeInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TypeInfo<'a> {
  pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_DENOTATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TypeInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TypeInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<TypeInfo<'bldr>> {
    let mut builder = TypeInfoBuilder::new(_fbb);
    if let Some(x) = args.denotation { builder.add_denotation(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_value_type(args.value_type);
    builder.finish()
  }


  #[inline]
  pub fn value_type(&self) -> ValueType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValueType>(TypeInfo::VT_VALUE_TYPE, Some(ValueType::NONE)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(TypeInfo::VT_VALUE, None)}
  }
  #[inline]
  pub fn denotation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TypeInfo::VT_DENOTATION, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_tensor_type(&self) -> Option<TensorType<'a>> {
    if self.value_type() == ValueType::tensor_type {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_sequence_type(&self) -> Option<SequenceType<'a>> {
    if self.value_type() == ValueType::sequence_type {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SequenceType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_map_type(&self) -> Option<MapType<'a>> {
    if self.value_type() == ValueType::map_type {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MapType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_optional_type(&self) -> Option<OptionalType<'a>> {
    if self.value_type() == ValueType::optional_type {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OptionalType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_sparse_tensor_type(&self) -> Option<SparseTensorType<'a>> {
    if self.value_type() == ValueType::sparse_tensor_type {
      self.value().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SparseTensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for TypeInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ValueType, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          ValueType::tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TensorType>>("ValueType::tensor_type", pos),
          ValueType::sequence_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceType>>("ValueType::sequence_type", pos),
          ValueType::map_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MapType>>("ValueType::map_type", pos),
          ValueType::optional_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionalType>>("ValueType::optional_type", pos),
          ValueType::sparse_tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseTensorType>>("ValueType::sparse_tensor_type", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("denotation", Self::VT_DENOTATION, false)?
     .finish();
    Ok(())
  }
}
pub struct TypeInfoArgs<'a> {
    pub value_type: ValueType,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub denotation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TypeInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TypeInfoArgs {
      value_type: ValueType::NONE,
      value: None,
      denotation: None,
    }
  }
}

pub struct TypeInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TypeInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value_type(&mut self, value_type: ValueType) {
    self.fbb_.push_slot::<ValueType>(TypeInfo::VT_VALUE_TYPE, value_type, ValueType::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TypeInfo::VT_VALUE, value);
  }
  #[inline]
  pub fn add_denotation(&mut self, denotation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TypeInfo::VT_DENOTATION, denotation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TypeInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TypeInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TypeInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TypeInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TypeInfo");
      ds.field("value_type", &self.value_type());
      match self.value_type() {
        ValueType::tensor_type => {
          if let Some(x) = self.value_as_tensor_type() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sequence_type => {
          if let Some(x) = self.value_as_sequence_type() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::map_type => {
          if let Some(x) = self.value_as_map_type() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::optional_type => {
          if let Some(x) = self.value_as_optional_type() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sparse_tensor_type => {
          if let Some(x) = self.value_as_sparse_tensor_type() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("value", &x)
        },
      };
      ds.field("denotation", &self.denotation());
      ds.finish()
  }
}
pub enum TensorTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorType<'a> {
  type Inner = TensorType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorType<'a> {
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorType<'bldr>> {
    let mut builder = TensorTypeBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_elem_type(args.elem_type);
    builder.finish()
  }


  #[inline]
  pub fn elem_type(&self) -> DataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataType>(TensorType::VT_ELEM_TYPE, Some(DataType::UNDEFINED)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<Shape<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Shape>>(TensorType::VT_SHAPE, None)}
  }
}

impl flatbuffers::Verifiable for TensorType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DataType>("elem_type", Self::VT_ELEM_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Shape>>("shape", Self::VT_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorTypeArgs<'a> {
    pub elem_type: DataType,
    pub shape: Option<flatbuffers::WIPOffset<Shape<'a>>>,
}
impl<'a> Default for TensorTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorTypeArgs {
      elem_type: DataType::UNDEFINED,
      shape: None,
    }
  }
}

pub struct TensorTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: DataType) {
    self.fbb_.push_slot::<DataType>(TensorType::VT_ELEM_TYPE, elem_type, DataType::UNDEFINED);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<Shape<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Shape>>(TensorType::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorType");
      ds.field("elem_type", &self.elem_type());
      ds.field("shape", &self.shape());
      ds.finish()
  }
}
pub enum SequenceTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SequenceType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SequenceType<'a> {
  type Inner = SequenceType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SequenceType<'a> {
  pub const VT_ELEM_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SequenceType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SequenceTypeArgs
  ) -> flatbuffers::WIPOffset<SequenceType<'bldr>> {
    let mut builder = SequenceTypeBuilder::new(_fbb);
    if let Some(x) = args.elem_type { builder.add_elem_type(x); }
    builder.add_elem_type_type(args.elem_type_type);
    builder.finish()
  }


  #[inline]
  pub fn elem_type_type(&self) -> ValueType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValueType>(SequenceType::VT_ELEM_TYPE_TYPE, Some(ValueType::NONE)).unwrap()}
  }
  #[inline]
  pub fn elem_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SequenceType::VT_ELEM_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_tensor_type(&self) -> Option<TensorType<'a>> {
    if self.elem_type_type() == ValueType::tensor_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_sequence_type(&self) -> Option<SequenceType<'a>> {
    if self.elem_type_type() == ValueType::sequence_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SequenceType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_map_type(&self) -> Option<MapType<'a>> {
    if self.elem_type_type() == ValueType::map_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MapType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_optional_type(&self) -> Option<OptionalType<'a>> {
    if self.elem_type_type() == ValueType::optional_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OptionalType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_sparse_tensor_type(&self) -> Option<SparseTensorType<'a>> {
    if self.elem_type_type() == ValueType::sparse_tensor_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SparseTensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SequenceType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ValueType, _>("elem_type_type", Self::VT_ELEM_TYPE_TYPE, "elem_type", Self::VT_ELEM_TYPE, false, |key, v, pos| {
        match key {
          ValueType::tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TensorType>>("ValueType::tensor_type", pos),
          ValueType::sequence_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceType>>("ValueType::sequence_type", pos),
          ValueType::map_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MapType>>("ValueType::map_type", pos),
          ValueType::optional_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionalType>>("ValueType::optional_type", pos),
          ValueType::sparse_tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseTensorType>>("ValueType::sparse_tensor_type", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SequenceTypeArgs {
    pub elem_type_type: ValueType,
    pub elem_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SequenceTypeArgs {
  #[inline]
  fn default() -> Self {
    SequenceTypeArgs {
      elem_type_type: ValueType::NONE,
      elem_type: None,
    }
  }
}

pub struct SequenceTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SequenceTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_elem_type_type(&mut self, elem_type_type: ValueType) {
    self.fbb_.push_slot::<ValueType>(SequenceType::VT_ELEM_TYPE_TYPE, elem_type_type, ValueType::NONE);
  }
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequenceType::VT_ELEM_TYPE, elem_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SequenceTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SequenceTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SequenceType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SequenceType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SequenceType");
      ds.field("elem_type_type", &self.elem_type_type());
      match self.elem_type_type() {
        ValueType::tensor_type => {
          if let Some(x) = self.elem_type_as_tensor_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sequence_type => {
          if let Some(x) = self.elem_type_as_sequence_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::map_type => {
          if let Some(x) = self.elem_type_as_map_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::optional_type => {
          if let Some(x) = self.elem_type_as_optional_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sparse_tensor_type => {
          if let Some(x) = self.elem_type_as_sparse_tensor_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("elem_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum MapTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MapType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MapType<'a> {
  type Inner = MapType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MapType<'a> {
  pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE_TYPE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MapType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MapTypeArgs
  ) -> flatbuffers::WIPOffset<MapType<'bldr>> {
    let mut builder = MapTypeBuilder::new(_fbb);
    if let Some(x) = args.value_type { builder.add_value_type(x); }
    builder.add_key_type(args.key_type);
    builder.add_value_type_type(args.value_type_type);
    builder.finish()
  }


  #[inline]
  pub fn key_type(&self) -> DataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataType>(MapType::VT_KEY_TYPE, Some(DataType::UNDEFINED)).unwrap()}
  }
  #[inline]
  pub fn value_type_type(&self) -> ValueType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValueType>(MapType::VT_VALUE_TYPE_TYPE, Some(ValueType::NONE)).unwrap()}
  }
  #[inline]
  pub fn value_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(MapType::VT_VALUE_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_type_as_tensor_type(&self) -> Option<TensorType<'a>> {
    if self.value_type_type() == ValueType::tensor_type {
      self.value_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_type_as_sequence_type(&self) -> Option<SequenceType<'a>> {
    if self.value_type_type() == ValueType::sequence_type {
      self.value_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SequenceType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_type_as_map_type(&self) -> Option<MapType<'a>> {
    if self.value_type_type() == ValueType::map_type {
      self.value_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MapType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_type_as_optional_type(&self) -> Option<OptionalType<'a>> {
    if self.value_type_type() == ValueType::optional_type {
      self.value_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OptionalType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_type_as_sparse_tensor_type(&self) -> Option<SparseTensorType<'a>> {
    if self.value_type_type() == ValueType::sparse_tensor_type {
      self.value_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SparseTensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for MapType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DataType>("key_type", Self::VT_KEY_TYPE, false)?
     .visit_union::<ValueType, _>("value_type_type", Self::VT_VALUE_TYPE_TYPE, "value_type", Self::VT_VALUE_TYPE, false, |key, v, pos| {
        match key {
          ValueType::tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TensorType>>("ValueType::tensor_type", pos),
          ValueType::sequence_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceType>>("ValueType::sequence_type", pos),
          ValueType::map_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MapType>>("ValueType::map_type", pos),
          ValueType::optional_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionalType>>("ValueType::optional_type", pos),
          ValueType::sparse_tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseTensorType>>("ValueType::sparse_tensor_type", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MapTypeArgs {
    pub key_type: DataType,
    pub value_type_type: ValueType,
    pub value_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MapTypeArgs {
  #[inline]
  fn default() -> Self {
    MapTypeArgs {
      key_type: DataType::UNDEFINED,
      value_type_type: ValueType::NONE,
      value_type: None,
    }
  }
}

pub struct MapTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MapTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_type(&mut self, key_type: DataType) {
    self.fbb_.push_slot::<DataType>(MapType::VT_KEY_TYPE, key_type, DataType::UNDEFINED);
  }
  #[inline]
  pub fn add_value_type_type(&mut self, value_type_type: ValueType) {
    self.fbb_.push_slot::<ValueType>(MapType::VT_VALUE_TYPE_TYPE, value_type_type, ValueType::NONE);
  }
  #[inline]
  pub fn add_value_type(&mut self, value_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MapType::VT_VALUE_TYPE, value_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MapTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MapTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MapType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MapType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MapType");
      ds.field("key_type", &self.key_type());
      ds.field("value_type_type", &self.value_type_type());
      match self.value_type_type() {
        ValueType::tensor_type => {
          if let Some(x) = self.value_type_as_tensor_type() {
            ds.field("value_type", &x)
          } else {
            ds.field("value_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sequence_type => {
          if let Some(x) = self.value_type_as_sequence_type() {
            ds.field("value_type", &x)
          } else {
            ds.field("value_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::map_type => {
          if let Some(x) = self.value_type_as_map_type() {
            ds.field("value_type", &x)
          } else {
            ds.field("value_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::optional_type => {
          if let Some(x) = self.value_type_as_optional_type() {
            ds.field("value_type", &x)
          } else {
            ds.field("value_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sparse_tensor_type => {
          if let Some(x) = self.value_type_as_sparse_tensor_type() {
            ds.field("value_type", &x)
          } else {
            ds.field("value_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("value_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum OptionalTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OptionalType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OptionalType<'a> {
  type Inner = OptionalType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OptionalType<'a> {
  pub const VT_ELEM_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OptionalType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OptionalTypeArgs
  ) -> flatbuffers::WIPOffset<OptionalType<'bldr>> {
    let mut builder = OptionalTypeBuilder::new(_fbb);
    if let Some(x) = args.elem_type { builder.add_elem_type(x); }
    builder.add_elem_type_type(args.elem_type_type);
    builder.finish()
  }


  #[inline]
  pub fn elem_type_type(&self) -> ValueType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValueType>(OptionalType::VT_ELEM_TYPE_TYPE, Some(ValueType::NONE)).unwrap()}
  }
  #[inline]
  pub fn elem_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(OptionalType::VT_ELEM_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_tensor_type(&self) -> Option<TensorType<'a>> {
    if self.elem_type_type() == ValueType::tensor_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_sequence_type(&self) -> Option<SequenceType<'a>> {
    if self.elem_type_type() == ValueType::sequence_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SequenceType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_map_type(&self) -> Option<MapType<'a>> {
    if self.elem_type_type() == ValueType::map_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MapType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_optional_type(&self) -> Option<OptionalType<'a>> {
    if self.elem_type_type() == ValueType::optional_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OptionalType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn elem_type_as_sparse_tensor_type(&self) -> Option<SparseTensorType<'a>> {
    if self.elem_type_type() == ValueType::sparse_tensor_type {
      self.elem_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SparseTensorType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for OptionalType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ValueType, _>("elem_type_type", Self::VT_ELEM_TYPE_TYPE, "elem_type", Self::VT_ELEM_TYPE, false, |key, v, pos| {
        match key {
          ValueType::tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TensorType>>("ValueType::tensor_type", pos),
          ValueType::sequence_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceType>>("ValueType::sequence_type", pos),
          ValueType::map_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MapType>>("ValueType::map_type", pos),
          ValueType::optional_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OptionalType>>("ValueType::optional_type", pos),
          ValueType::sparse_tensor_type => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseTensorType>>("ValueType::sparse_tensor_type", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct OptionalTypeArgs {
    pub elem_type_type: ValueType,
    pub elem_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OptionalTypeArgs {
  #[inline]
  fn default() -> Self {
    OptionalTypeArgs {
      elem_type_type: ValueType::NONE,
      elem_type: None,
    }
  }
}

pub struct OptionalTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OptionalTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_elem_type_type(&mut self, elem_type_type: ValueType) {
    self.fbb_.push_slot::<ValueType>(OptionalType::VT_ELEM_TYPE_TYPE, elem_type_type, ValueType::NONE);
  }
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OptionalType::VT_ELEM_TYPE, elem_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OptionalTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OptionalTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OptionalType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OptionalType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OptionalType");
      ds.field("elem_type_type", &self.elem_type_type());
      match self.elem_type_type() {
        ValueType::tensor_type => {
          if let Some(x) = self.elem_type_as_tensor_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sequence_type => {
          if let Some(x) = self.elem_type_as_sequence_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::map_type => {
          if let Some(x) = self.elem_type_as_map_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::optional_type => {
          if let Some(x) = self.elem_type_as_optional_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueType::sparse_tensor_type => {
          if let Some(x) = self.elem_type_as_sparse_tensor_type() {
            ds.field("elem_type", &x)
          } else {
            ds.field("elem_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("elem_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum SparseTensorTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseTensorType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseTensorType<'a> {
  type Inner = SparseTensorType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SparseTensorType<'a> {
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparseTensorType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SparseTensorTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<SparseTensorType<'bldr>> {
    let mut builder = SparseTensorTypeBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_elem_type(args.elem_type);
    builder.finish()
  }


  #[inline]
  pub fn elem_type(&self) -> DataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataType>(SparseTensorType::VT_ELEM_TYPE, Some(DataType::UNDEFINED)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<Shape<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Shape>>(SparseTensorType::VT_SHAPE, None)}
  }
}

impl flatbuffers::Verifiable for SparseTensorType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DataType>("elem_type", Self::VT_ELEM_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Shape>>("shape", Self::VT_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct SparseTensorTypeArgs<'a> {
    pub elem_type: DataType,
    pub shape: Option<flatbuffers::WIPOffset<Shape<'a>>>,
}
impl<'a> Default for SparseTensorTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    SparseTensorTypeArgs {
      elem_type: DataType::UNDEFINED,
      shape: None,
    }
  }
}

pub struct SparseTensorTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SparseTensorTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: DataType) {
    self.fbb_.push_slot::<DataType>(SparseTensorType::VT_ELEM_TYPE, elem_type, DataType::UNDEFINED);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<Shape<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Shape>>(SparseTensorType::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SparseTensorTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SparseTensorTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparseTensorType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparseTensorType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparseTensorType");
      ds.field("elem_type", &self.elem_type());
      ds.field("shape", &self.shape());
      ds.finish()
  }
}
pub enum OperatorSetIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorSetId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorSetId<'a> {
  type Inner = OperatorSetId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OperatorSetId<'a> {
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OperatorSetId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OperatorSetIdArgs<'args>
  ) -> flatbuffers::WIPOffset<OperatorSetId<'bldr>> {
    let mut builder = OperatorSetIdBuilder::new(_fbb);
    builder.add_version(args.version);
    if let Some(x) = args.domain { builder.add_domain(x); }
    builder.finish()
  }


  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorSetId::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn version(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OperatorSetId::VT_VERSION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OperatorSetId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<i64>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorSetIdArgs<'a> {
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i64,
}
impl<'a> Default for OperatorSetIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorSetIdArgs {
      domain: None,
      version: 0,
    }
  }
}

pub struct OperatorSetIdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OperatorSetIdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorSetId::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_version(&mut self, version: i64) {
    self.fbb_.push_slot::<i64>(OperatorSetId::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OperatorSetIdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OperatorSetIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OperatorSetId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OperatorSetId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OperatorSetId");
      ds.field("domain", &self.domain());
      ds.field("version", &self.version());
      ds.finish()
  }
}
pub enum ValueInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueInfo<'a> {
  type Inner = ValueInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ValueInfo<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 8;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ValueInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValueInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<ValueInfo<'bldr>> {
    let mut builder = ValueInfoBuilder::new(_fbb);
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ValueInfo::VT_NAME, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<TypeInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TypeInfo>>(ValueInfo::VT_TYPE_, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ValueInfo::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(ValueInfo::VT_METADATA_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for ValueInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TypeInfo>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct ValueInfoArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<TypeInfo<'a>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for ValueInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValueInfoArgs {
      name: None,
      type_: None,
      doc_string: None,
      metadata_props: None,
    }
  }
}

pub struct ValueInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueInfo::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<TypeInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TypeInfo>>(ValueInfo::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueInfo::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueInfo::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValueInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValueInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ValueInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ValueInfo");
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("doc_string", &self.doc_string());
      ds.field("metadata_props", &self.metadata_props());
      ds.finish()
  }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
  type Inner = Node<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Node<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OP_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 8;
  pub const VT_OVERLOAD: flatbuffers::VOffsetT = 10;
  pub const VT_INPUT: flatbuffers::VOffsetT = 12;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 14;
  pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 16;
  pub const VT_DEVICE_CONFIGURATIONS: flatbuffers::VOffsetT = 18;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 20;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Node { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NodeArgs<'args>
  ) -> flatbuffers::WIPOffset<Node<'bldr>> {
    let mut builder = NodeBuilder::new(_fbb);
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.device_configurations { builder.add_device_configurations(x); }
    if let Some(x) = args.attribute { builder.add_attribute(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.overload { builder.add_overload(x); }
    if let Some(x) = args.domain { builder.add_domain(x); }
    if let Some(x) = args.op_type { builder.add_op_type(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_NAME, None)}
  }
  #[inline]
  pub fn op_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_OP_TYPE, None)}
  }
  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn overload(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_OVERLOAD, None)}
  }
  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Node::VT_INPUT, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Node::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn attribute(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute>>>>(Node::VT_ATTRIBUTE, None)}
  }
  #[inline]
  pub fn device_configurations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeDeviceConfiguration<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeDeviceConfiguration>>>>(Node::VT_DEVICE_CONFIGURATIONS, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(Node::VT_METADATA_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for Node<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("op_type", Self::VT_OP_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("overload", Self::VT_OVERLOAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("input", Self::VT_INPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Attribute>>>>("attribute", Self::VT_ATTRIBUTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeDeviceConfiguration>>>>("device_configurations", Self::VT_DEVICE_CONFIGURATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub op_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overload: Option<flatbuffers::WIPOffset<&'a str>>,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub attribute: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute<'a>>>>>,
    pub device_configurations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeDeviceConfiguration<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for NodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeArgs {
      name: None,
      op_type: None,
      domain: None,
      overload: None,
      input: None,
      output: None,
      attribute: None,
      device_configurations: None,
      doc_string: None,
      metadata_props: None,
    }
  }
}

pub struct NodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_NAME, name);
  }
  #[inline]
  pub fn add_op_type(&mut self, op_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_OP_TYPE, op_type);
  }
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_overload(&mut self, overload: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_OVERLOAD, overload);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_INPUT, input);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_attribute(&mut self, attribute: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Attribute<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_ATTRIBUTE, attribute);
  }
  #[inline]
  pub fn add_device_configurations(&mut self, device_configurations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NodeDeviceConfiguration<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DEVICE_CONFIGURATIONS, device_configurations);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NodeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Node<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Node");
      ds.field("name", &self.name());
      ds.field("op_type", &self.op_type());
      ds.field("domain", &self.domain());
      ds.field("overload", &self.overload());
      ds.field("input", &self.input());
      ds.field("output", &self.output());
      ds.field("attribute", &self.attribute());
      ds.field("device_configurations", &self.device_configurations());
      ds.field("doc_string", &self.doc_string());
      ds.field("metadata_props", &self.metadata_props());
      ds.finish()
  }
}
pub enum GraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Graph<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graph<'a> {
  type Inner = Graph<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Graph<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_NODE: flatbuffers::VOffsetT = 6;
  pub const VT_INITIALIZER: flatbuffers::VOffsetT = 8;
  pub const VT_SPARSE_INITIALIZER: flatbuffers::VOffsetT = 10;
  pub const VT_INPUT: flatbuffers::VOffsetT = 12;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 14;
  pub const VT_VALUE_INFO: flatbuffers::VOffsetT = 16;
  pub const VT_QUANTIZATION_ANNOTATION: flatbuffers::VOffsetT = 18;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 20;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Graph { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GraphArgs<'args>
  ) -> flatbuffers::WIPOffset<Graph<'bldr>> {
    let mut builder = GraphBuilder::new(_fbb);
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.quantization_annotation { builder.add_quantization_annotation(x); }
    if let Some(x) = args.value_info { builder.add_value_info(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.sparse_initializer { builder.add_sparse_initializer(x); }
    if let Some(x) = args.initializer { builder.add_initializer(x); }
    if let Some(x) = args.node { builder.add_node(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Graph::VT_NAME, None)}
  }
  #[inline]
  pub fn node(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>>>(Graph::VT_NODE, None)}
  }
  #[inline]
  pub fn initializer(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor>>>>(Graph::VT_INITIALIZER, None)}
  }
  #[inline]
  pub fn sparse_initializer(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensor>>>>(Graph::VT_SPARSE_INITIALIZER, None)}
  }
  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo>>>>(Graph::VT_INPUT, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo>>>>(Graph::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn value_info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo>>>>(Graph::VT_VALUE_INFO, None)}
  }
  #[inline]
  pub fn quantization_annotation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorAnnotation<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorAnnotation>>>>(Graph::VT_QUANTIZATION_ANNOTATION, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Graph::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(Graph::VT_METADATA_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for Graph<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>>>("node", Self::VT_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tensor>>>>("initializer", Self::VT_INITIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SparseTensor>>>>("sparse_initializer", Self::VT_SPARSE_INITIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfo>>>>("input", Self::VT_INPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfo>>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfo>>>>("value_info", Self::VT_VALUE_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorAnnotation>>>>("quantization_annotation", Self::VT_QUANTIZATION_ANNOTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct GraphArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub node: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>>,
    pub initializer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>>>,
    pub sparse_initializer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensor<'a>>>>>,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>>>,
    pub value_info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>>>,
    pub quantization_annotation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorAnnotation<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for GraphArgs<'a> {
  #[inline]
  fn default() -> Self {
    GraphArgs {
      name: None,
      node: None,
      initializer: None,
      sparse_initializer: None,
      input: None,
      output: None,
      value_info: None,
      quantization_annotation: None,
      doc_string: None,
      metadata_props: None,
    }
  }
}

pub struct GraphBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GraphBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_NAME, name);
  }
  #[inline]
  pub fn add_node(&mut self, node: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Node<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_NODE, node);
  }
  #[inline]
  pub fn add_initializer(&mut self, initializer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Tensor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_INITIALIZER, initializer);
  }
  #[inline]
  pub fn add_sparse_initializer(&mut self, sparse_initializer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SparseTensor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_SPARSE_INITIALIZER, sparse_initializer);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_INPUT, input);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_value_info(&mut self, value_info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_VALUE_INFO, value_info);
  }
  #[inline]
  pub fn add_quantization_annotation(&mut self, quantization_annotation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorAnnotation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_QUANTIZATION_ANNOTATION, quantization_annotation);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GraphBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GraphBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Graph<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Graph<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Graph");
      ds.field("name", &self.name());
      ds.field("node", &self.node());
      ds.field("initializer", &self.initializer());
      ds.field("sparse_initializer", &self.sparse_initializer());
      ds.field("input", &self.input());
      ds.field("output", &self.output());
      ds.field("value_info", &self.value_info());
      ds.field("quantization_annotation", &self.quantization_annotation());
      ds.field("doc_string", &self.doc_string());
      ds.field("metadata_props", &self.metadata_props());
      ds.finish()
  }
}
pub enum FunctionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Function<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Function<'a> {
  type Inner = Function<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Function<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 6;
  pub const VT_OVERLOAD: flatbuffers::VOffsetT = 8;
  pub const VT_OPSET_IMPORT: flatbuffers::VOffsetT = 10;
  pub const VT_INPUT: flatbuffers::VOffsetT = 12;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 14;
  pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 16;
  pub const VT_NODE: flatbuffers::VOffsetT = 18;
  pub const VT_VALUE_INFO: flatbuffers::VOffsetT = 20;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 22;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Function { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FunctionArgs<'args>
  ) -> flatbuffers::WIPOffset<Function<'bldr>> {
    let mut builder = FunctionBuilder::new(_fbb);
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.value_info { builder.add_value_info(x); }
    if let Some(x) = args.node { builder.add_node(x); }
    if let Some(x) = args.attribute { builder.add_attribute(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.opset_import { builder.add_opset_import(x); }
    if let Some(x) = args.overload { builder.add_overload(x); }
    if let Some(x) = args.domain { builder.add_domain(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_NAME, None)}
  }
  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn overload(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_OVERLOAD, None)}
  }
  #[inline]
  pub fn opset_import(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetId<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetId>>>>(Function::VT_OPSET_IMPORT, None)}
  }
  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Function::VT_INPUT, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Function::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn attribute(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute>>>>(Function::VT_ATTRIBUTE, None)}
  }
  #[inline]
  pub fn node(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>>>(Function::VT_NODE, None)}
  }
  #[inline]
  pub fn value_info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo>>>>(Function::VT_VALUE_INFO, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(Function::VT_METADATA_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for Function<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("overload", Self::VT_OVERLOAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorSetId>>>>("opset_import", Self::VT_OPSET_IMPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("input", Self::VT_INPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Attribute>>>>("attribute", Self::VT_ATTRIBUTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>>>("node", Self::VT_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfo>>>>("value_info", Self::VT_VALUE_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct FunctionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overload: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opset_import: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetId<'a>>>>>,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub attribute: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute<'a>>>>>,
    pub node: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>>,
    pub value_info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfo<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for FunctionArgs<'a> {
  #[inline]
  fn default() -> Self {
    FunctionArgs {
      name: None,
      domain: None,
      overload: None,
      opset_import: None,
      input: None,
      output: None,
      attribute: None,
      node: None,
      value_info: None,
      doc_string: None,
      metadata_props: None,
    }
  }
}

pub struct FunctionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FunctionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_NAME, name);
  }
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_overload(&mut self, overload: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_OVERLOAD, overload);
  }
  #[inline]
  pub fn add_opset_import(&mut self, opset_import: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OperatorSetId<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_OPSET_IMPORT, opset_import);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_INPUT, input);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_attribute(&mut self, attribute: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Attribute<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_ATTRIBUTE, attribute);
  }
  #[inline]
  pub fn add_node(&mut self, node: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Node<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_NODE, node);
  }
  #[inline]
  pub fn add_value_info(&mut self, value_info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_VALUE_INFO, value_info);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FunctionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Function<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Function<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Function");
      ds.field("name", &self.name());
      ds.field("domain", &self.domain());
      ds.field("overload", &self.overload());
      ds.field("opset_import", &self.opset_import());
      ds.field("input", &self.input());
      ds.field("output", &self.output());
      ds.field("attribute", &self.attribute());
      ds.field("node", &self.node());
      ds.field("value_info", &self.value_info());
      ds.field("doc_string", &self.doc_string());
      ds.field("metadata_props", &self.metadata_props());
      ds.finish()
  }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
  type Inner = Model<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Model<'a> {
  pub const VT_IR_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_OPSET_IMPORT: flatbuffers::VOffsetT = 6;
  pub const VT_PRODUCER_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_PRODUCER_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 12;
  pub const VT_MODEL_VERSION: flatbuffers::VOffsetT = 14;
  pub const VT_GRAPH: flatbuffers::VOffsetT = 16;
  pub const VT_FUNCTIONS: flatbuffers::VOffsetT = 18;
  pub const VT_TRAINING_INFO: flatbuffers::VOffsetT = 20;
  pub const VT_CONFIGURATION: flatbuffers::VOffsetT = 22;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 24;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Model { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ModelArgs<'args>
  ) -> flatbuffers::WIPOffset<Model<'bldr>> {
    let mut builder = ModelBuilder::new(_fbb);
    builder.add_model_version(args.model_version);
    builder.add_ir_version(args.ir_version);
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.configuration { builder.add_configuration(x); }
    if let Some(x) = args.training_info { builder.add_training_info(x); }
    if let Some(x) = args.functions { builder.add_functions(x); }
    if let Some(x) = args.graph { builder.add_graph(x); }
    if let Some(x) = args.domain { builder.add_domain(x); }
    if let Some(x) = args.producer_version { builder.add_producer_version(x); }
    if let Some(x) = args.producer_name { builder.add_producer_name(x); }
    if let Some(x) = args.opset_import { builder.add_opset_import(x); }
    builder.finish()
  }


  #[inline]
  pub fn ir_version(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Model::VT_IR_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn opset_import(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetId<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetId>>>>(Model::VT_OPSET_IMPORT, None)}
  }
  #[inline]
  pub fn producer_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_PRODUCER_NAME, None)}
  }
  #[inline]
  pub fn producer_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_PRODUCER_VERSION, None)}
  }
  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn model_version(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Model::VT_MODEL_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn graph(&self) -> Option<Graph<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Graph>>(Model::VT_GRAPH, None)}
  }
  #[inline]
  pub fn functions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Function<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Function>>>>(Model::VT_FUNCTIONS, None)}
  }
  #[inline]
  pub fn training_info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TrainingInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TrainingInfo>>>>(Model::VT_TRAINING_INFO, None)}
  }
  #[inline]
  pub fn configuration(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeviceConfiguration<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeviceConfiguration>>>>(Model::VT_CONFIGURATION, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry>>>>(Model::VT_METADATA_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for Model<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("ir_version", Self::VT_IR_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorSetId>>>>("opset_import", Self::VT_OPSET_IMPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("producer_name", Self::VT_PRODUCER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("producer_version", Self::VT_PRODUCER_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<i64>("model_version", Self::VT_MODEL_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("graph", Self::VT_GRAPH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Function>>>>("functions", Self::VT_FUNCTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TrainingInfo>>>>("training_info", Self::VT_TRAINING_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DeviceConfiguration>>>>("configuration", Self::VT_CONFIGURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntry>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct ModelArgs<'a> {
    pub ir_version: i64,
    pub opset_import: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetId<'a>>>>>,
    pub producer_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub producer_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub model_version: i64,
    pub graph: Option<flatbuffers::WIPOffset<Graph<'a>>>,
    pub functions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Function<'a>>>>>,
    pub training_info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TrainingInfo<'a>>>>>,
    pub configuration: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeviceConfiguration<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntry<'a>>>>>,
}
impl<'a> Default for ModelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ModelArgs {
      ir_version: 0,
      opset_import: None,
      producer_name: None,
      producer_version: None,
      domain: None,
      model_version: 0,
      graph: None,
      functions: None,
      training_info: None,
      configuration: None,
      doc_string: None,
      metadata_props: None,
    }
  }
}

pub struct ModelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ModelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ir_version(&mut self, ir_version: i64) {
    self.fbb_.push_slot::<i64>(Model::VT_IR_VERSION, ir_version, 0);
  }
  #[inline]
  pub fn add_opset_import(&mut self, opset_import: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OperatorSetId<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_OPSET_IMPORT, opset_import);
  }
  #[inline]
  pub fn add_producer_name(&mut self, producer_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_PRODUCER_NAME, producer_name);
  }
  #[inline]
  pub fn add_producer_version(&mut self, producer_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_PRODUCER_VERSION, producer_version);
  }
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_model_version(&mut self, model_version: i64) {
    self.fbb_.push_slot::<i64>(Model::VT_MODEL_VERSION, model_version, 0);
  }
  #[inline]
  pub fn add_graph(&mut self, graph: flatbuffers::WIPOffset<Graph<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Graph>>(Model::VT_GRAPH, graph);
  }
  #[inline]
  pub fn add_functions(&mut self, functions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Function<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_FUNCTIONS, functions);
  }
  #[inline]
  pub fn add_training_info(&mut self, training_info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TrainingInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_TRAINING_INFO, training_info);
  }
  #[inline]
  pub fn add_configuration(&mut self, configuration: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DeviceConfiguration<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_CONFIGURATION, configuration);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ModelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ModelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Model<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Model");
      ds.field("ir_version", &self.ir_version());
      ds.field("opset_import", &self.opset_import());
      ds.field("producer_name", &self.producer_name());
      ds.field("producer_version", &self.producer_version());
      ds.field("domain", &self.domain());
      ds.field("model_version", &self.model_version());
      ds.field("graph", &self.graph());
      ds.field("functions", &self.functions());
      ds.field("training_info", &self.training_info());
      ds.field("configuration", &self.configuration());
      ds.field("doc_string", &self.doc_string());
      ds.field("metadata_props", &self.metadata_props());
      ds.finish()
  }
}
}  // pub mod onnx

