// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod onnx {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VERSION: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VERSION: i32 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VERSION: [Version; 10] = [
  Version::_START_VERSION,
  Version::IR_VERSION_2017_10_10,
  Version::IR_VERSION_2017_10_30,
  Version::IR_VERSION_2017_11_3,
  Version::IR_VERSION_2019_1_22,
  Version::IR_VERSION_2019_3_18,
  Version::IR_VERSION_2019_9_19,
  Version::IR_VERSION_2020_5_8,
  Version::IR_VERSION_2021_7_30,
  Version::IR_VERSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Version(pub i32);
#[allow(non_upper_case_globals)]
impl Version {
  pub const _START_VERSION: Self = Self(0);
  pub const IR_VERSION_2017_10_10: Self = Self(1);
  pub const IR_VERSION_2017_10_30: Self = Self(2);
  pub const IR_VERSION_2017_11_3: Self = Self(3);
  pub const IR_VERSION_2019_1_22: Self = Self(4);
  pub const IR_VERSION_2019_3_18: Self = Self(5);
  pub const IR_VERSION_2019_9_19: Self = Self(6);
  pub const IR_VERSION_2020_5_8: Self = Self(7);
  pub const IR_VERSION_2021_7_30: Self = Self(8);
  pub const IR_VERSION: Self = Self(9);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::_START_VERSION,
    Self::IR_VERSION_2017_10_10,
    Self::IR_VERSION_2017_10_30,
    Self::IR_VERSION_2017_11_3,
    Self::IR_VERSION_2019_1_22,
    Self::IR_VERSION_2019_3_18,
    Self::IR_VERSION_2019_9_19,
    Self::IR_VERSION_2020_5_8,
    Self::IR_VERSION_2021_7_30,
    Self::IR_VERSION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::_START_VERSION => Some("_START_VERSION"),
      Self::IR_VERSION_2017_10_10 => Some("IR_VERSION_2017_10_10"),
      Self::IR_VERSION_2017_10_30 => Some("IR_VERSION_2017_10_30"),
      Self::IR_VERSION_2017_11_3 => Some("IR_VERSION_2017_11_3"),
      Self::IR_VERSION_2019_1_22 => Some("IR_VERSION_2019_1_22"),
      Self::IR_VERSION_2019_3_18 => Some("IR_VERSION_2019_3_18"),
      Self::IR_VERSION_2019_9_19 => Some("IR_VERSION_2019_9_19"),
      Self::IR_VERSION_2020_5_8 => Some("IR_VERSION_2020_5_8"),
      Self::IR_VERSION_2021_7_30 => Some("IR_VERSION_2021_7_30"),
      Self::IR_VERSION => Some("IR_VERSION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Version {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Version {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Version {
    type Output = Version;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Version {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Version {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Version {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OPERATOR_STATUS: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OPERATOR_STATUS: i32 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_STATUS: [OperatorStatus; 2] = [
  OperatorStatus::EXPERIMENTAL,
  OperatorStatus::STABLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorStatus(pub i32);
#[allow(non_upper_case_globals)]
impl OperatorStatus {
  pub const EXPERIMENTAL: Self = Self(0);
  pub const STABLE: Self = Self(1);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EXPERIMENTAL,
    Self::STABLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EXPERIMENTAL => Some("EXPERIMENTAL"),
      Self::STABLE => Some("STABLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OperatorStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OperatorStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OperatorStatus {
    type Output = OperatorStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OperatorStatus {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OperatorStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorStatus {}
pub enum AttributeProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AttributeProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttributeProto<'a> {
  type Inner = AttributeProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AttributeProto<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_REF_ATTR_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_F: flatbuffers::VOffsetT = 12;
  pub const VT_I: flatbuffers::VOffsetT = 14;
  pub const VT_S: flatbuffers::VOffsetT = 16;
  pub const VT_T: flatbuffers::VOffsetT = 18;
  pub const VT_G: flatbuffers::VOffsetT = 20;
  pub const VT_SPARSE_TENSOR: flatbuffers::VOffsetT = 22;
  pub const VT_TP: flatbuffers::VOffsetT = 24;
  pub const VT_FLOATS: flatbuffers::VOffsetT = 26;
  pub const VT_INTS: flatbuffers::VOffsetT = 28;
  pub const VT_STRINGS: flatbuffers::VOffsetT = 30;
  pub const VT_TENSORS: flatbuffers::VOffsetT = 32;
  pub const VT_GRAPHS: flatbuffers::VOffsetT = 34;
  pub const VT_SPARSE_TENSORS: flatbuffers::VOffsetT = 36;
  pub const VT_TYPE_PROTOS: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AttributeProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AttributeProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<AttributeProto<'bldr>> {
    let mut builder = AttributeProtoBuilder::new(_fbb);
    builder.add_i(args.i);
    if let Some(x) = args.type_protos { builder.add_type_protos(x); }
    if let Some(x) = args.sparse_tensors { builder.add_sparse_tensors(x); }
    if let Some(x) = args.graphs { builder.add_graphs(x); }
    if let Some(x) = args.tensors { builder.add_tensors(x); }
    if let Some(x) = args.strings { builder.add_strings(x); }
    if let Some(x) = args.ints { builder.add_ints(x); }
    if let Some(x) = args.floats { builder.add_floats(x); }
    if let Some(x) = args.tp { builder.add_tp(x); }
    if let Some(x) = args.sparse_tensor { builder.add_sparse_tensor(x); }
    if let Some(x) = args.g { builder.add_g(x); }
    if let Some(x) = args.t { builder.add_t(x); }
    if let Some(x) = args.s { builder.add_s(x); }
    builder.add_f(args.f);
    builder.add_type_(args.type_);
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.ref_attr_name { builder.add_ref_attr_name(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttributeProto::VT_NAME, None)}
  }
  #[inline]
  pub fn ref_attr_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttributeProto::VT_REF_ATTR_NAME, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttributeProto::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn type_(&self) -> attribute_proto_::AttributeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<attribute_proto_::AttributeType>(AttributeProto::VT_TYPE_, Some(attribute_proto_::AttributeType::UNDEFINED)).unwrap()}
  }
  #[inline]
  pub fn f(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AttributeProto::VT_F, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn i(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AttributeProto::VT_I, Some(0)).unwrap()}
  }
  #[inline]
  pub fn s(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AttributeProto::VT_S, None)}
  }
  #[inline]
  pub fn t(&self) -> Option<TensorProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TensorProto>>(AttributeProto::VT_T, None)}
  }
  #[inline]
  pub fn g(&self) -> Option<GraphProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GraphProto>>(AttributeProto::VT_G, None)}
  }
  #[inline]
  pub fn sparse_tensor(&self) -> Option<SparseTensorProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SparseTensorProto>>(AttributeProto::VT_SPARSE_TENSOR, None)}
  }
  #[inline]
  pub fn tp(&self) -> Option<TypeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TypeProto>>(AttributeProto::VT_TP, None)}
  }
  #[inline]
  pub fn floats(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(AttributeProto::VT_FLOATS, None)}
  }
  #[inline]
  pub fn ints(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(AttributeProto::VT_INTS, None)}
  }
  #[inline]
  pub fn strings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttributeProto::VT_STRINGS, None)}
  }
  #[inline]
  pub fn tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorProto>>>>(AttributeProto::VT_TENSORS, None)}
  }
  #[inline]
  pub fn graphs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GraphProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GraphProto>>>>(AttributeProto::VT_GRAPHS, None)}
  }
  #[inline]
  pub fn sparse_tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensorProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensorProto>>>>(AttributeProto::VT_SPARSE_TENSORS, None)}
  }
  #[inline]
  pub fn type_protos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeProto>>>>(AttributeProto::VT_TYPE_PROTOS, None)}
  }
}

impl flatbuffers::Verifiable for AttributeProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ref_attr_name", Self::VT_REF_ATTR_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<attribute_proto_::AttributeType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f32>("f", Self::VT_F, false)?
     .visit_field::<i64>("i", Self::VT_I, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("s", Self::VT_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TensorProto>>("t", Self::VT_T, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GraphProto>>("g", Self::VT_G, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SparseTensorProto>>("sparse_tensor", Self::VT_SPARSE_TENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TypeProto>>("tp", Self::VT_TP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("floats", Self::VT_FLOATS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ints", Self::VT_INTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("strings", Self::VT_STRINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorProto>>>>("tensors", Self::VT_TENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GraphProto>>>>("graphs", Self::VT_GRAPHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SparseTensorProto>>>>("sparse_tensors", Self::VT_SPARSE_TENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TypeProto>>>>("type_protos", Self::VT_TYPE_PROTOS, false)?
     .finish();
    Ok(())
  }
}
pub struct AttributeProtoArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ref_attr_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: attribute_proto_::AttributeType,
    pub f: f32,
    pub i: i64,
    pub s: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub t: Option<flatbuffers::WIPOffset<TensorProto<'a>>>,
    pub g: Option<flatbuffers::WIPOffset<GraphProto<'a>>>,
    pub sparse_tensor: Option<flatbuffers::WIPOffset<SparseTensorProto<'a>>>,
    pub tp: Option<flatbuffers::WIPOffset<TypeProto<'a>>>,
    pub floats: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub ints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorProto<'a>>>>>,
    pub graphs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GraphProto<'a>>>>>,
    pub sparse_tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensorProto<'a>>>>>,
    pub type_protos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TypeProto<'a>>>>>,
}
impl<'a> Default for AttributeProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    AttributeProtoArgs {
      name: None,
      ref_attr_name: None,
      doc_string: None,
      type_: attribute_proto_::AttributeType::UNDEFINED,
      f: 0.0,
      i: 0,
      s: None,
      t: None,
      g: None,
      sparse_tensor: None,
      tp: None,
      floats: None,
      ints: None,
      strings: None,
      tensors: None,
      graphs: None,
      sparse_tensors: None,
      type_protos: None,
    }
  }
}

pub struct AttributeProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AttributeProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_NAME, name);
  }
  #[inline]
  pub fn add_ref_attr_name(&mut self, ref_attr_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_REF_ATTR_NAME, ref_attr_name);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: attribute_proto_::AttributeType) {
    self.fbb_.push_slot::<attribute_proto_::AttributeType>(AttributeProto::VT_TYPE_, type_, attribute_proto_::AttributeType::UNDEFINED);
  }
  #[inline]
  pub fn add_f(&mut self, f: f32) {
    self.fbb_.push_slot::<f32>(AttributeProto::VT_F, f, 0.0);
  }
  #[inline]
  pub fn add_i(&mut self, i: i64) {
    self.fbb_.push_slot::<i64>(AttributeProto::VT_I, i, 0);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_S, s);
  }
  #[inline]
  pub fn add_t(&mut self, t: flatbuffers::WIPOffset<TensorProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TensorProto>>(AttributeProto::VT_T, t);
  }
  #[inline]
  pub fn add_g(&mut self, g: flatbuffers::WIPOffset<GraphProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GraphProto>>(AttributeProto::VT_G, g);
  }
  #[inline]
  pub fn add_sparse_tensor(&mut self, sparse_tensor: flatbuffers::WIPOffset<SparseTensorProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SparseTensorProto>>(AttributeProto::VT_SPARSE_TENSOR, sparse_tensor);
  }
  #[inline]
  pub fn add_tp(&mut self, tp: flatbuffers::WIPOffset<TypeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TypeProto>>(AttributeProto::VT_TP, tp);
  }
  #[inline]
  pub fn add_floats(&mut self, floats: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_FLOATS, floats);
  }
  #[inline]
  pub fn add_ints(&mut self, ints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_INTS, ints);
  }
  #[inline]
  pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_STRINGS, strings);
  }
  #[inline]
  pub fn add_tensors(&mut self, tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_TENSORS, tensors);
  }
  #[inline]
  pub fn add_graphs(&mut self, graphs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GraphProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_GRAPHS, graphs);
  }
  #[inline]
  pub fn add_sparse_tensors(&mut self, sparse_tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SparseTensorProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_SPARSE_TENSORS, sparse_tensors);
  }
  #[inline]
  pub fn add_type_protos(&mut self, type_protos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TypeProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttributeProto::VT_TYPE_PROTOS, type_protos);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AttributeProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AttributeProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AttributeProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AttributeProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AttributeProto");
      ds.field("name", &self.name());
      ds.field("ref_attr_name", &self.ref_attr_name());
      ds.field("doc_string", &self.doc_string());
      ds.field("type_", &self.type_());
      ds.field("f", &self.f());
      ds.field("i", &self.i());
      ds.field("s", &self.s());
      ds.field("t", &self.t());
      ds.field("g", &self.g());
      ds.field("sparse_tensor", &self.sparse_tensor());
      ds.field("tp", &self.tp());
      ds.field("floats", &self.floats());
      ds.field("ints", &self.ints());
      ds.field("strings", &self.strings());
      ds.field("tensors", &self.tensors());
      ds.field("graphs", &self.graphs());
      ds.field("sparse_tensors", &self.sparse_tensors());
      ds.field("type_protos", &self.type_protos());
      ds.finish()
  }
}
pub enum ValueInfoProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueInfoProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueInfoProto<'a> {
  type Inner = ValueInfoProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ValueInfoProto<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ValueInfoProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ValueInfoProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<ValueInfoProto<'bldr>> {
    let mut builder = ValueInfoProtoBuilder::new(_fbb);
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ValueInfoProto::VT_NAME, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<TypeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TypeProto>>(ValueInfoProto::VT_TYPE_, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ValueInfoProto::VT_DOC_STRING, None)}
  }
}

impl flatbuffers::Verifiable for ValueInfoProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TypeProto>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .finish();
    Ok(())
  }
}
pub struct ValueInfoProtoArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<TypeProto<'a>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ValueInfoProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValueInfoProtoArgs {
      name: None,
      type_: None,
      doc_string: None,
    }
  }
}

pub struct ValueInfoProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueInfoProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueInfoProto::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<TypeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TypeProto>>(ValueInfoProto::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueInfoProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueInfoProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ValueInfoProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValueInfoProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ValueInfoProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ValueInfoProto");
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("doc_string", &self.doc_string());
      ds.finish()
  }
}
pub enum NodeProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NodeProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NodeProto<'a> {
  type Inner = NodeProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NodeProto<'a> {
  pub const VT_INPUT: flatbuffers::VOffsetT = 4;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_OP_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 12;
  pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 14;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NodeProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NodeProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<NodeProto<'bldr>> {
    let mut builder = NodeProtoBuilder::new(_fbb);
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.attribute { builder.add_attribute(x); }
    if let Some(x) = args.domain { builder.add_domain(x); }
    if let Some(x) = args.op_type { builder.add_op_type(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.input { builder.add_input(x); }
    builder.finish()
  }


  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(NodeProto::VT_INPUT, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(NodeProto::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeProto::VT_NAME, None)}
  }
  #[inline]
  pub fn op_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeProto::VT_OP_TYPE, None)}
  }
  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeProto::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn attribute(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttributeProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttributeProto>>>>(NodeProto::VT_ATTRIBUTE, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NodeProto::VT_DOC_STRING, None)}
  }
}

impl flatbuffers::Verifiable for NodeProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("input", Self::VT_INPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("op_type", Self::VT_OP_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AttributeProto>>>>("attribute", Self::VT_ATTRIBUTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeProtoArgs<'a> {
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub op_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attribute: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttributeProto<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NodeProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeProtoArgs {
      input: None,
      output: None,
      name: None,
      op_type: None,
      domain: None,
      attribute: None,
      doc_string: None,
    }
  }
}

pub struct NodeProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NodeProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_INPUT, input);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_NAME, name);
  }
  #[inline]
  pub fn add_op_type(&mut self, op_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_OP_TYPE, op_type);
  }
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_attribute(&mut self, attribute: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AttributeProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_ATTRIBUTE, attribute);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NodeProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NodeProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NodeProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NodeProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NodeProto");
      ds.field("input", &self.input());
      ds.field("output", &self.output());
      ds.field("name", &self.name());
      ds.field("op_type", &self.op_type());
      ds.field("domain", &self.domain());
      ds.field("attribute", &self.attribute());
      ds.field("doc_string", &self.doc_string());
      ds.finish()
  }
}
pub enum TrainingInfoProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TrainingInfoProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TrainingInfoProto<'a> {
  type Inner = TrainingInfoProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TrainingInfoProto<'a> {
  pub const VT_INITIALIZATION: flatbuffers::VOffsetT = 4;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 6;
  pub const VT_INITIALIZATION_BINDING: flatbuffers::VOffsetT = 8;
  pub const VT_UPDATE_BINDING: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TrainingInfoProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TrainingInfoProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<TrainingInfoProto<'bldr>> {
    let mut builder = TrainingInfoProtoBuilder::new(_fbb);
    if let Some(x) = args.update_binding { builder.add_update_binding(x); }
    if let Some(x) = args.initialization_binding { builder.add_initialization_binding(x); }
    if let Some(x) = args.algorithm { builder.add_algorithm(x); }
    if let Some(x) = args.initialization { builder.add_initialization(x); }
    builder.finish()
  }


  #[inline]
  pub fn initialization(&self) -> Option<GraphProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GraphProto>>(TrainingInfoProto::VT_INITIALIZATION, None)}
  }
  #[inline]
  pub fn algorithm(&self) -> Option<GraphProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GraphProto>>(TrainingInfoProto::VT_ALGORITHM, None)}
  }
  #[inline]
  pub fn initialization_binding(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>(TrainingInfoProto::VT_INITIALIZATION_BINDING, None)}
  }
  #[inline]
  pub fn update_binding(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>(TrainingInfoProto::VT_UPDATE_BINDING, None)}
  }
}

impl flatbuffers::Verifiable for TrainingInfoProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<GraphProto>>("initialization", Self::VT_INITIALIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GraphProto>>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>("initialization_binding", Self::VT_INITIALIZATION_BINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>("update_binding", Self::VT_UPDATE_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct TrainingInfoProtoArgs<'a> {
    pub initialization: Option<flatbuffers::WIPOffset<GraphProto<'a>>>,
    pub algorithm: Option<flatbuffers::WIPOffset<GraphProto<'a>>>,
    pub initialization_binding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>>>,
    pub update_binding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>>>,
}
impl<'a> Default for TrainingInfoProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrainingInfoProtoArgs {
      initialization: None,
      algorithm: None,
      initialization_binding: None,
      update_binding: None,
    }
  }
}

pub struct TrainingInfoProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TrainingInfoProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_initialization(&mut self, initialization: flatbuffers::WIPOffset<GraphProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GraphProto>>(TrainingInfoProto::VT_INITIALIZATION, initialization);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: flatbuffers::WIPOffset<GraphProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GraphProto>>(TrainingInfoProto::VT_ALGORITHM, algorithm);
  }
  #[inline]
  pub fn add_initialization_binding(&mut self, initialization_binding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntryProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrainingInfoProto::VT_INITIALIZATION_BINDING, initialization_binding);
  }
  #[inline]
  pub fn add_update_binding(&mut self, update_binding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntryProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrainingInfoProto::VT_UPDATE_BINDING, update_binding);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TrainingInfoProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TrainingInfoProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TrainingInfoProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TrainingInfoProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TrainingInfoProto");
      ds.field("initialization", &self.initialization());
      ds.field("algorithm", &self.algorithm());
      ds.field("initialization_binding", &self.initialization_binding());
      ds.field("update_binding", &self.update_binding());
      ds.finish()
  }
}
pub enum ModelProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ModelProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ModelProto<'a> {
  type Inner = ModelProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ModelProto<'a> {
  pub const VT_IR_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_OPSET_IMPORT: flatbuffers::VOffsetT = 6;
  pub const VT_PRODUCER_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_PRODUCER_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 12;
  pub const VT_MODEL_VERSION: flatbuffers::VOffsetT = 14;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 16;
  pub const VT_GRAPH: flatbuffers::VOffsetT = 18;
  pub const VT_METADATA_PROPS: flatbuffers::VOffsetT = 20;
  pub const VT_TRAINING_INFO: flatbuffers::VOffsetT = 22;
  pub const VT_FUNCTIONS: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ModelProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ModelProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<ModelProto<'bldr>> {
    let mut builder = ModelProtoBuilder::new(_fbb);
    builder.add_model_version(args.model_version);
    builder.add_ir_version(args.ir_version);
    if let Some(x) = args.functions { builder.add_functions(x); }
    if let Some(x) = args.training_info { builder.add_training_info(x); }
    if let Some(x) = args.metadata_props { builder.add_metadata_props(x); }
    if let Some(x) = args.graph { builder.add_graph(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.domain { builder.add_domain(x); }
    if let Some(x) = args.producer_version { builder.add_producer_version(x); }
    if let Some(x) = args.producer_name { builder.add_producer_name(x); }
    if let Some(x) = args.opset_import { builder.add_opset_import(x); }
    builder.finish()
  }


  #[inline]
  pub fn ir_version(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ModelProto::VT_IR_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn opset_import(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetIdProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetIdProto>>>>(ModelProto::VT_OPSET_IMPORT, None)}
  }
  #[inline]
  pub fn producer_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ModelProto::VT_PRODUCER_NAME, None)}
  }
  #[inline]
  pub fn producer_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ModelProto::VT_PRODUCER_VERSION, None)}
  }
  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ModelProto::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn model_version(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ModelProto::VT_MODEL_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ModelProto::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn graph(&self) -> Option<GraphProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GraphProto>>(ModelProto::VT_GRAPH, None)}
  }
  #[inline]
  pub fn metadata_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>(ModelProto::VT_METADATA_PROPS, None)}
  }
  #[inline]
  pub fn training_info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TrainingInfoProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TrainingInfoProto>>>>(ModelProto::VT_TRAINING_INFO, None)}
  }
  #[inline]
  pub fn functions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionProto>>>>(ModelProto::VT_FUNCTIONS, None)}
  }
}

impl flatbuffers::Verifiable for ModelProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("ir_version", Self::VT_IR_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorSetIdProto>>>>("opset_import", Self::VT_OPSET_IMPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("producer_name", Self::VT_PRODUCER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("producer_version", Self::VT_PRODUCER_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<i64>("model_version", Self::VT_MODEL_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GraphProto>>("graph", Self::VT_GRAPH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>("metadata_props", Self::VT_METADATA_PROPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TrainingInfoProto>>>>("training_info", Self::VT_TRAINING_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FunctionProto>>>>("functions", Self::VT_FUNCTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ModelProtoArgs<'a> {
    pub ir_version: i64,
    pub opset_import: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetIdProto<'a>>>>>,
    pub producer_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub producer_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub model_version: i64,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub graph: Option<flatbuffers::WIPOffset<GraphProto<'a>>>,
    pub metadata_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>>>,
    pub training_info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TrainingInfoProto<'a>>>>>,
    pub functions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionProto<'a>>>>>,
}
impl<'a> Default for ModelProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    ModelProtoArgs {
      ir_version: 0,
      opset_import: None,
      producer_name: None,
      producer_version: None,
      domain: None,
      model_version: 0,
      doc_string: None,
      graph: None,
      metadata_props: None,
      training_info: None,
      functions: None,
    }
  }
}

pub struct ModelProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModelProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_ir_version(&mut self, ir_version: i64) {
    self.fbb_.push_slot::<i64>(ModelProto::VT_IR_VERSION, ir_version, 0);
  }
  #[inline]
  pub fn add_opset_import(&mut self, opset_import: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OperatorSetIdProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_OPSET_IMPORT, opset_import);
  }
  #[inline]
  pub fn add_producer_name(&mut self, producer_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_PRODUCER_NAME, producer_name);
  }
  #[inline]
  pub fn add_producer_version(&mut self, producer_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_PRODUCER_VERSION, producer_version);
  }
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_model_version(&mut self, model_version: i64) {
    self.fbb_.push_slot::<i64>(ModelProto::VT_MODEL_VERSION, model_version, 0);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_graph(&mut self, graph: flatbuffers::WIPOffset<GraphProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GraphProto>>(ModelProto::VT_GRAPH, graph);
  }
  #[inline]
  pub fn add_metadata_props(&mut self, metadata_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntryProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_METADATA_PROPS, metadata_props);
  }
  #[inline]
  pub fn add_training_info(&mut self, training_info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TrainingInfoProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_TRAINING_INFO, training_info);
  }
  #[inline]
  pub fn add_functions(&mut self, functions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FunctionProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ModelProto::VT_FUNCTIONS, functions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ModelProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ModelProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ModelProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ModelProto");
      ds.field("ir_version", &self.ir_version());
      ds.field("opset_import", &self.opset_import());
      ds.field("producer_name", &self.producer_name());
      ds.field("producer_version", &self.producer_version());
      ds.field("domain", &self.domain());
      ds.field("model_version", &self.model_version());
      ds.field("doc_string", &self.doc_string());
      ds.field("graph", &self.graph());
      ds.field("metadata_props", &self.metadata_props());
      ds.field("training_info", &self.training_info());
      ds.field("functions", &self.functions());
      ds.finish()
  }
}
pub enum StringStringEntryProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringStringEntryProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringStringEntryProto<'a> {
  type Inner = StringStringEntryProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringStringEntryProto<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringStringEntryProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StringStringEntryProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<StringStringEntryProto<'bldr>> {
    let mut builder = StringStringEntryProtoBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringStringEntryProto::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringStringEntryProto::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for StringStringEntryProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct StringStringEntryProtoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringStringEntryProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringStringEntryProtoArgs {
      key: None,
      value: None,
    }
  }
}

pub struct StringStringEntryProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StringStringEntryProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringStringEntryProto::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringStringEntryProto::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringStringEntryProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StringStringEntryProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringStringEntryProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringStringEntryProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringStringEntryProto");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum TensorAnnotationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorAnnotation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorAnnotation<'a> {
  type Inner = TensorAnnotation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorAnnotation<'a> {
  pub const VT_TENSOR_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_QUANT_PARAMETER_TENSOR_NAMES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorAnnotation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorAnnotationArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorAnnotation<'bldr>> {
    let mut builder = TensorAnnotationBuilder::new(_fbb);
    if let Some(x) = args.quant_parameter_tensor_names { builder.add_quant_parameter_tensor_names(x); }
    if let Some(x) = args.tensor_name { builder.add_tensor_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn tensor_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorAnnotation::VT_TENSOR_NAME, None)}
  }
  #[inline]
  pub fn quant_parameter_tensor_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>(TensorAnnotation::VT_QUANT_PARAMETER_TENSOR_NAMES, None)}
  }
}

impl flatbuffers::Verifiable for TensorAnnotation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tensor_name", Self::VT_TENSOR_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>("quant_parameter_tensor_names", Self::VT_QUANT_PARAMETER_TENSOR_NAMES, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorAnnotationArgs<'a> {
    pub tensor_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quant_parameter_tensor_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>>>,
}
impl<'a> Default for TensorAnnotationArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorAnnotationArgs {
      tensor_name: None,
      quant_parameter_tensor_names: None,
    }
  }
}

pub struct TensorAnnotationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorAnnotationBuilder<'a, 'b> {
  #[inline]
  pub fn add_tensor_name(&mut self, tensor_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorAnnotation::VT_TENSOR_NAME, tensor_name);
  }
  #[inline]
  pub fn add_quant_parameter_tensor_names(&mut self, quant_parameter_tensor_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntryProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorAnnotation::VT_QUANT_PARAMETER_TENSOR_NAMES, quant_parameter_tensor_names);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorAnnotationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorAnnotationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorAnnotation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorAnnotation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorAnnotation");
      ds.field("tensor_name", &self.tensor_name());
      ds.field("quant_parameter_tensor_names", &self.quant_parameter_tensor_names());
      ds.finish()
  }
}
pub enum GraphProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GraphProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GraphProto<'a> {
  type Inner = GraphProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GraphProto<'a> {
  pub const VT_NODE: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_INITIALIZER: flatbuffers::VOffsetT = 8;
  pub const VT_SPARSE_INITIALIZER: flatbuffers::VOffsetT = 10;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 12;
  pub const VT_INPUT: flatbuffers::VOffsetT = 14;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 16;
  pub const VT_VALUE_INFO: flatbuffers::VOffsetT = 18;
  pub const VT_QUANTIZATION_ANNOTATION: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GraphProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GraphProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<GraphProto<'bldr>> {
    let mut builder = GraphProtoBuilder::new(_fbb);
    if let Some(x) = args.quantization_annotation { builder.add_quantization_annotation(x); }
    if let Some(x) = args.value_info { builder.add_value_info(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.sparse_initializer { builder.add_sparse_initializer(x); }
    if let Some(x) = args.initializer { builder.add_initializer(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.node { builder.add_node(x); }
    builder.finish()
  }


  #[inline]
  pub fn node(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeProto>>>>(GraphProto::VT_NODE, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GraphProto::VT_NAME, None)}
  }
  #[inline]
  pub fn initializer(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorProto>>>>(GraphProto::VT_INITIALIZER, None)}
  }
  #[inline]
  pub fn sparse_initializer(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensorProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensorProto>>>>(GraphProto::VT_SPARSE_INITIALIZER, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GraphProto::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto>>>>(GraphProto::VT_INPUT, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto>>>>(GraphProto::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn value_info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto>>>>(GraphProto::VT_VALUE_INFO, None)}
  }
  #[inline]
  pub fn quantization_annotation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorAnnotation<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorAnnotation>>>>(GraphProto::VT_QUANTIZATION_ANNOTATION, None)}
  }
}

impl flatbuffers::Verifiable for GraphProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeProto>>>>("node", Self::VT_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorProto>>>>("initializer", Self::VT_INITIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SparseTensorProto>>>>("sparse_initializer", Self::VT_SPARSE_INITIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfoProto>>>>("input", Self::VT_INPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfoProto>>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueInfoProto>>>>("value_info", Self::VT_VALUE_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorAnnotation>>>>("quantization_annotation", Self::VT_QUANTIZATION_ANNOTATION, false)?
     .finish();
    Ok(())
  }
}
pub struct GraphProtoArgs<'a> {
    pub node: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeProto<'a>>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initializer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorProto<'a>>>>>,
    pub sparse_initializer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SparseTensorProto<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto<'a>>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto<'a>>>>>,
    pub value_info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueInfoProto<'a>>>>>,
    pub quantization_annotation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorAnnotation<'a>>>>>,
}
impl<'a> Default for GraphProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    GraphProtoArgs {
      node: None,
      name: None,
      initializer: None,
      sparse_initializer: None,
      doc_string: None,
      input: None,
      output: None,
      value_info: None,
      quantization_annotation: None,
    }
  }
}

pub struct GraphProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GraphProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_node(&mut self, node: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NodeProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_NODE, node);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_NAME, name);
  }
  #[inline]
  pub fn add_initializer(&mut self, initializer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_INITIALIZER, initializer);
  }
  #[inline]
  pub fn add_sparse_initializer(&mut self, sparse_initializer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SparseTensorProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_SPARSE_INITIALIZER, sparse_initializer);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfoProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_INPUT, input);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfoProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_value_info(&mut self, value_info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueInfoProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_VALUE_INFO, value_info);
  }
  #[inline]
  pub fn add_quantization_annotation(&mut self, quantization_annotation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorAnnotation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GraphProto::VT_QUANTIZATION_ANNOTATION, quantization_annotation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GraphProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GraphProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GraphProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GraphProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GraphProto");
      ds.field("node", &self.node());
      ds.field("name", &self.name());
      ds.field("initializer", &self.initializer());
      ds.field("sparse_initializer", &self.sparse_initializer());
      ds.field("doc_string", &self.doc_string());
      ds.field("input", &self.input());
      ds.field("output", &self.output());
      ds.field("value_info", &self.value_info());
      ds.field("quantization_annotation", &self.quantization_annotation());
      ds.finish()
  }
}
pub enum TensorProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorProto<'a> {
  type Inner = TensorProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorProto<'a> {
  pub const VT_DIMS: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SEGMENT: flatbuffers::VOffsetT = 8;
  pub const VT_FLOAT_DATA: flatbuffers::VOffsetT = 10;
  pub const VT_INT32_DATA: flatbuffers::VOffsetT = 12;
  pub const VT_STRING_DATA: flatbuffers::VOffsetT = 14;
  pub const VT_INT64_DATA: flatbuffers::VOffsetT = 16;
  pub const VT_NAME: flatbuffers::VOffsetT = 18;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 20;
  pub const VT_RAW_DATA: flatbuffers::VOffsetT = 22;
  pub const VT_EXTERNAL_DATA: flatbuffers::VOffsetT = 24;
  pub const VT_DATA_LOCATION: flatbuffers::VOffsetT = 26;
  pub const VT_DOUBLE_DATA: flatbuffers::VOffsetT = 28;
  pub const VT_UINT64_DATA: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorProto<'bldr>> {
    let mut builder = TensorProtoBuilder::new(_fbb);
    if let Some(x) = args.uint64_data { builder.add_uint64_data(x); }
    if let Some(x) = args.double_data { builder.add_double_data(x); }
    builder.add_data_location(args.data_location);
    if let Some(x) = args.external_data { builder.add_external_data(x); }
    if let Some(x) = args.raw_data { builder.add_raw_data(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.int64_data { builder.add_int64_data(x); }
    if let Some(x) = args.string_data { builder.add_string_data(x); }
    if let Some(x) = args.int32_data { builder.add_int32_data(x); }
    if let Some(x) = args.float_data { builder.add_float_data(x); }
    if let Some(x) = args.segment { builder.add_segment(x); }
    builder.add_data_type(args.data_type);
    if let Some(x) = args.dims { builder.add_dims(x); }
    builder.finish()
  }


  #[inline]
  pub fn dims(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(TensorProto::VT_DIMS, None)}
  }
  #[inline]
  pub fn data_type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorProto::VT_DATA_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn segment(&self) -> Option<tensor_proto_::Segment<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<tensor_proto_::Segment>>(TensorProto::VT_SEGMENT, None)}
  }
  #[inline]
  pub fn float_data(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(TensorProto::VT_FLOAT_DATA, None)}
  }
  #[inline]
  pub fn int32_data(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TensorProto::VT_INT32_DATA, None)}
  }
  #[inline]
  pub fn string_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TensorProto::VT_STRING_DATA, None)}
  }
  #[inline]
  pub fn int64_data(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(TensorProto::VT_INT64_DATA, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorProto::VT_NAME, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorProto::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn raw_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TensorProto::VT_RAW_DATA, None)}
  }
  #[inline]
  pub fn external_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>(TensorProto::VT_EXTERNAL_DATA, None)}
  }
  #[inline]
  pub fn data_location(&self) -> tensor_proto_::DataLocation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<tensor_proto_::DataLocation>(TensorProto::VT_DATA_LOCATION, Some(tensor_proto_::DataLocation::DEFAULT)).unwrap()}
  }
  #[inline]
  pub fn double_data(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TensorProto::VT_DOUBLE_DATA, None)}
  }
  #[inline]
  pub fn uint64_data(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(TensorProto::VT_UINT64_DATA, None)}
  }
}

impl flatbuffers::Verifiable for TensorProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("dims", Self::VT_DIMS, false)?
     .visit_field::<i32>("data_type", Self::VT_DATA_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<tensor_proto_::Segment>>("segment", Self::VT_SEGMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("float_data", Self::VT_FLOAT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("int32_data", Self::VT_INT32_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("string_data", Self::VT_STRING_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("int64_data", Self::VT_INT64_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("raw_data", Self::VT_RAW_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringStringEntryProto>>>>("external_data", Self::VT_EXTERNAL_DATA, false)?
     .visit_field::<tensor_proto_::DataLocation>("data_location", Self::VT_DATA_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("double_data", Self::VT_DOUBLE_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("uint64_data", Self::VT_UINT64_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorProtoArgs<'a> {
    pub dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub data_type: i32,
    pub segment: Option<flatbuffers::WIPOffset<tensor_proto_::Segment<'a>>>,
    pub float_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub int32_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub string_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub int64_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub raw_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub external_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringStringEntryProto<'a>>>>>,
    pub data_location: tensor_proto_::DataLocation,
    pub double_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub uint64_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for TensorProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorProtoArgs {
      dims: None,
      data_type: 0,
      segment: None,
      float_data: None,
      int32_data: None,
      string_data: None,
      int64_data: None,
      name: None,
      doc_string: None,
      raw_data: None,
      external_data: None,
      data_location: tensor_proto_::DataLocation::DEFAULT,
      double_data: None,
      uint64_data: None,
    }
  }
}

pub struct TensorProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_dims(&mut self, dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_DIMS, dims);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: i32) {
    self.fbb_.push_slot::<i32>(TensorProto::VT_DATA_TYPE, data_type, 0);
  }
  #[inline]
  pub fn add_segment(&mut self, segment: flatbuffers::WIPOffset<tensor_proto_::Segment<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<tensor_proto_::Segment>>(TensorProto::VT_SEGMENT, segment);
  }
  #[inline]
  pub fn add_float_data(&mut self, float_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_FLOAT_DATA, float_data);
  }
  #[inline]
  pub fn add_int32_data(&mut self, int32_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_INT32_DATA, int32_data);
  }
  #[inline]
  pub fn add_string_data(&mut self, string_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_STRING_DATA, string_data);
  }
  #[inline]
  pub fn add_int64_data(&mut self, int64_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_INT64_DATA, int64_data);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_NAME, name);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_raw_data(&mut self, raw_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_RAW_DATA, raw_data);
  }
  #[inline]
  pub fn add_external_data(&mut self, external_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringStringEntryProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_EXTERNAL_DATA, external_data);
  }
  #[inline]
  pub fn add_data_location(&mut self, data_location: tensor_proto_::DataLocation) {
    self.fbb_.push_slot::<tensor_proto_::DataLocation>(TensorProto::VT_DATA_LOCATION, data_location, tensor_proto_::DataLocation::DEFAULT);
  }
  #[inline]
  pub fn add_double_data(&mut self, double_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_DOUBLE_DATA, double_data);
  }
  #[inline]
  pub fn add_uint64_data(&mut self, uint64_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorProto::VT_UINT64_DATA, uint64_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorProto");
      ds.field("dims", &self.dims());
      ds.field("data_type", &self.data_type());
      ds.field("segment", &self.segment());
      ds.field("float_data", &self.float_data());
      ds.field("int32_data", &self.int32_data());
      ds.field("string_data", &self.string_data());
      ds.field("int64_data", &self.int64_data());
      ds.field("name", &self.name());
      ds.field("doc_string", &self.doc_string());
      ds.field("raw_data", &self.raw_data());
      ds.field("external_data", &self.external_data());
      ds.field("data_location", &self.data_location());
      ds.field("double_data", &self.double_data());
      ds.field("uint64_data", &self.uint64_data());
      ds.finish()
  }
}
pub enum SparseTensorProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseTensorProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseTensorProto<'a> {
  type Inner = SparseTensorProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SparseTensorProto<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_INDICES: flatbuffers::VOffsetT = 6;
  pub const VT_DIMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparseTensorProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SparseTensorProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<SparseTensorProto<'bldr>> {
    let mut builder = SparseTensorProtoBuilder::new(_fbb);
    if let Some(x) = args.dims { builder.add_dims(x); }
    if let Some(x) = args.indices { builder.add_indices(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<TensorProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TensorProto>>(SparseTensorProto::VT_VALUES, None)}
  }
  #[inline]
  pub fn indices(&self) -> Option<TensorProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TensorProto>>(SparseTensorProto::VT_INDICES, None)}
  }
  #[inline]
  pub fn dims(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(SparseTensorProto::VT_DIMS, None)}
  }
}

impl flatbuffers::Verifiable for SparseTensorProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TensorProto>>("values", Self::VT_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TensorProto>>("indices", Self::VT_INDICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("dims", Self::VT_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SparseTensorProtoArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<TensorProto<'a>>>,
    pub indices: Option<flatbuffers::WIPOffset<TensorProto<'a>>>,
    pub dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for SparseTensorProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    SparseTensorProtoArgs {
      values: None,
      indices: None,
      dims: None,
    }
  }
}

pub struct SparseTensorProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SparseTensorProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<TensorProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TensorProto>>(SparseTensorProto::VT_VALUES, values);
  }
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<TensorProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TensorProto>>(SparseTensorProto::VT_INDICES, indices);
  }
  #[inline]
  pub fn add_dims(&mut self, dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SparseTensorProto::VT_DIMS, dims);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SparseTensorProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SparseTensorProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparseTensorProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparseTensorProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparseTensorProto");
      ds.field("values", &self.values());
      ds.field("indices", &self.indices());
      ds.field("dims", &self.dims());
      ds.finish()
  }
}
pub enum TensorShapeProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorShapeProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorShapeProto<'a> {
  type Inner = TensorShapeProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorShapeProto<'a> {
  pub const VT_DIM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorShapeProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorShapeProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorShapeProto<'bldr>> {
    let mut builder = TensorShapeProtoBuilder::new(_fbb);
    if let Some(x) = args.dim { builder.add_dim(x); }
    builder.finish()
  }


  #[inline]
  pub fn dim(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<tensor_shape_proto_::Dimension<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<tensor_shape_proto_::Dimension>>>>(TensorShapeProto::VT_DIM, None)}
  }
}

impl flatbuffers::Verifiable for TensorShapeProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<tensor_shape_proto_::Dimension>>>>("dim", Self::VT_DIM, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorShapeProtoArgs<'a> {
    pub dim: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<tensor_shape_proto_::Dimension<'a>>>>>,
}
impl<'a> Default for TensorShapeProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorShapeProtoArgs {
      dim: None,
    }
  }
}

pub struct TensorShapeProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorShapeProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_dim(&mut self, dim: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<tensor_shape_proto_::Dimension<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorShapeProto::VT_DIM, dim);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorShapeProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorShapeProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorShapeProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorShapeProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorShapeProto");
      ds.field("dim", &self.dim());
      ds.finish()
  }
}
pub enum TypeProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TypeProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TypeProto<'a> {
  type Inner = TypeProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TypeProto<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DENOTATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TypeProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TypeProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<TypeProto<'bldr>> {
    let mut builder = TypeProtoBuilder::new(_fbb);
    if let Some(x) = args.denotation { builder.add_denotation(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<type_proto_::Anonymous1<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<type_proto_::Anonymous1>>(TypeProto::VT_VALUE, None)}
  }
  #[inline]
  pub fn denotation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TypeProto::VT_DENOTATION, None)}
  }
}

impl flatbuffers::Verifiable for TypeProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<type_proto_::Anonymous1>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("denotation", Self::VT_DENOTATION, false)?
     .finish();
    Ok(())
  }
}
pub struct TypeProtoArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<type_proto_::Anonymous1<'a>>>,
    pub denotation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TypeProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TypeProtoArgs {
      value: None,
      denotation: None,
    }
  }
}

pub struct TypeProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TypeProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<type_proto_::Anonymous1<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<type_proto_::Anonymous1>>(TypeProto::VT_VALUE, value);
  }
  #[inline]
  pub fn add_denotation(&mut self, denotation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TypeProto::VT_DENOTATION, denotation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TypeProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TypeProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TypeProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TypeProto");
      ds.field("value", &self.value());
      ds.field("denotation", &self.denotation());
      ds.finish()
  }
}
pub enum OperatorSetIdProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorSetIdProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorSetIdProto<'a> {
  type Inner = OperatorSetIdProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OperatorSetIdProto<'a> {
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OperatorSetIdProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OperatorSetIdProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<OperatorSetIdProto<'bldr>> {
    let mut builder = OperatorSetIdProtoBuilder::new(_fbb);
    builder.add_version(args.version);
    if let Some(x) = args.domain { builder.add_domain(x); }
    builder.finish()
  }


  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorSetIdProto::VT_DOMAIN, None)}
  }
  #[inline]
  pub fn version(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OperatorSetIdProto::VT_VERSION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OperatorSetIdProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .visit_field::<i64>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorSetIdProtoArgs<'a> {
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i64,
}
impl<'a> Default for OperatorSetIdProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorSetIdProtoArgs {
      domain: None,
      version: 0,
    }
  }
}

pub struct OperatorSetIdProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorSetIdProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorSetIdProto::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn add_version(&mut self, version: i64) {
    self.fbb_.push_slot::<i64>(OperatorSetIdProto::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorSetIdProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperatorSetIdProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OperatorSetIdProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OperatorSetIdProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OperatorSetIdProto");
      ds.field("domain", &self.domain());
      ds.field("version", &self.version());
      ds.finish()
  }
}
pub enum FunctionProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FunctionProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctionProto<'a> {
  type Inner = FunctionProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FunctionProto<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_INPUT: flatbuffers::VOffsetT = 6;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 8;
  pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 10;
  pub const VT_ATTRIBUTE_PROTO: flatbuffers::VOffsetT = 12;
  pub const VT_NODE: flatbuffers::VOffsetT = 14;
  pub const VT_DOC_STRING: flatbuffers::VOffsetT = 16;
  pub const VT_OPSET_IMPORT: flatbuffers::VOffsetT = 18;
  pub const VT_DOMAIN: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FunctionProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FunctionProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<FunctionProto<'bldr>> {
    let mut builder = FunctionProtoBuilder::new(_fbb);
    if let Some(x) = args.domain { builder.add_domain(x); }
    if let Some(x) = args.opset_import { builder.add_opset_import(x); }
    if let Some(x) = args.doc_string { builder.add_doc_string(x); }
    if let Some(x) = args.node { builder.add_node(x); }
    if let Some(x) = args.attribute_proto { builder.add_attribute_proto(x); }
    if let Some(x) = args.attribute { builder.add_attribute(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FunctionProto::VT_NAME, None)}
  }
  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(FunctionProto::VT_INPUT, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(FunctionProto::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn attribute(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(FunctionProto::VT_ATTRIBUTE, None)}
  }
  #[inline]
  pub fn attribute_proto(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttributeProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttributeProto>>>>(FunctionProto::VT_ATTRIBUTE_PROTO, None)}
  }
  #[inline]
  pub fn node(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeProto>>>>(FunctionProto::VT_NODE, None)}
  }
  #[inline]
  pub fn doc_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FunctionProto::VT_DOC_STRING, None)}
  }
  #[inline]
  pub fn opset_import(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetIdProto<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetIdProto>>>>(FunctionProto::VT_OPSET_IMPORT, None)}
  }
  #[inline]
  pub fn domain(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FunctionProto::VT_DOMAIN, None)}
  }
}

impl flatbuffers::Verifiable for FunctionProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("input", Self::VT_INPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("attribute", Self::VT_ATTRIBUTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AttributeProto>>>>("attribute_proto", Self::VT_ATTRIBUTE_PROTO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NodeProto>>>>("node", Self::VT_NODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_string", Self::VT_DOC_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorSetIdProto>>>>("opset_import", Self::VT_OPSET_IMPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("domain", Self::VT_DOMAIN, false)?
     .finish();
    Ok(())
  }
}
pub struct FunctionProtoArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub attribute: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub attribute_proto: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttributeProto<'a>>>>>,
    pub node: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NodeProto<'a>>>>>,
    pub doc_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opset_import: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorSetIdProto<'a>>>>>,
    pub domain: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FunctionProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    FunctionProtoArgs {
      name: None,
      input: None,
      output: None,
      attribute: None,
      attribute_proto: None,
      node: None,
      doc_string: None,
      opset_import: None,
      domain: None,
    }
  }
}

pub struct FunctionProtoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionProtoBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_NAME, name);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_INPUT, input);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_attribute(&mut self, attribute: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_ATTRIBUTE, attribute);
  }
  #[inline]
  pub fn add_attribute_proto(&mut self, attribute_proto: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AttributeProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_ATTRIBUTE_PROTO, attribute_proto);
  }
  #[inline]
  pub fn add_node(&mut self, node: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NodeProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_NODE, node);
  }
  #[inline]
  pub fn add_doc_string(&mut self, doc_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_DOC_STRING, doc_string);
  }
  #[inline]
  pub fn add_opset_import(&mut self, opset_import: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OperatorSetIdProto<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_OPSET_IMPORT, opset_import);
  }
  #[inline]
  pub fn add_domain(&mut self, domain: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionProto::VT_DOMAIN, domain);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionProtoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctionProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FunctionProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FunctionProto");
      ds.field("name", &self.name());
      ds.field("input", &self.input());
      ds.field("output", &self.output());
      ds.field("attribute", &self.attribute());
      ds.field("attribute_proto", &self.attribute_proto());
      ds.field("node", &self.node());
      ds.field("doc_string", &self.doc_string());
      ds.field("opset_import", &self.opset_import());
      ds.field("domain", &self.domain());
      ds.finish()
  }
}
#[allow(unused_imports, dead_code)]
pub mod attribute_proto_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ATTRIBUTE_TYPE: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ATTRIBUTE_TYPE: i32 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ATTRIBUTE_TYPE: [AttributeType; 15] = [
  AttributeType::UNDEFINED,
  AttributeType::FLOAT,
  AttributeType::INT,
  AttributeType::STRING,
  AttributeType::TENSOR,
  AttributeType::GRAPH,
  AttributeType::FLOATS,
  AttributeType::INTS,
  AttributeType::STRINGS,
  AttributeType::TENSORS,
  AttributeType::GRAPHS,
  AttributeType::SPARSE_TENSOR,
  AttributeType::SPARSE_TENSORS,
  AttributeType::TYPE_PROTO,
  AttributeType::TYPE_PROTOS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AttributeType(pub i32);
#[allow(non_upper_case_globals)]
impl AttributeType {
  pub const UNDEFINED: Self = Self(0);
  pub const FLOAT: Self = Self(1);
  pub const INT: Self = Self(2);
  pub const STRING: Self = Self(3);
  pub const TENSOR: Self = Self(4);
  pub const GRAPH: Self = Self(5);
  pub const FLOATS: Self = Self(6);
  pub const INTS: Self = Self(7);
  pub const STRINGS: Self = Self(8);
  pub const TENSORS: Self = Self(9);
  pub const GRAPHS: Self = Self(10);
  pub const SPARSE_TENSOR: Self = Self(11);
  pub const SPARSE_TENSORS: Self = Self(12);
  pub const TYPE_PROTO: Self = Self(13);
  pub const TYPE_PROTOS: Self = Self(14);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNDEFINED,
    Self::FLOAT,
    Self::INT,
    Self::STRING,
    Self::TENSOR,
    Self::GRAPH,
    Self::FLOATS,
    Self::INTS,
    Self::STRINGS,
    Self::TENSORS,
    Self::GRAPHS,
    Self::SPARSE_TENSOR,
    Self::SPARSE_TENSORS,
    Self::TYPE_PROTO,
    Self::TYPE_PROTOS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNDEFINED => Some("UNDEFINED"),
      Self::FLOAT => Some("FLOAT"),
      Self::INT => Some("INT"),
      Self::STRING => Some("STRING"),
      Self::TENSOR => Some("TENSOR"),
      Self::GRAPH => Some("GRAPH"),
      Self::FLOATS => Some("FLOATS"),
      Self::INTS => Some("INTS"),
      Self::STRINGS => Some("STRINGS"),
      Self::TENSORS => Some("TENSORS"),
      Self::GRAPHS => Some("GRAPHS"),
      Self::SPARSE_TENSOR => Some("SPARSE_TENSOR"),
      Self::SPARSE_TENSORS => Some("SPARSE_TENSORS"),
      Self::TYPE_PROTO => Some("TYPE_PROTO"),
      Self::TYPE_PROTOS => Some("TYPE_PROTOS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AttributeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AttributeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AttributeType {
    type Output = AttributeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AttributeType {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AttributeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AttributeType {}
}  // pub mod AttributeProto_

#[allow(unused_imports, dead_code)]
pub mod tensor_proto_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_TYPE: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_TYPE: i32 = 20;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 21] = [
  DataType::UNDEFINED,
  DataType::FLOAT,
  DataType::UINT8,
  DataType::INT8,
  DataType::UINT16,
  DataType::INT16,
  DataType::INT32,
  DataType::INT64,
  DataType::STRING,
  DataType::BOOL,
  DataType::FLOAT16,
  DataType::DOUBLE,
  DataType::UINT32,
  DataType::UINT64,
  DataType::COMPLEX64,
  DataType::COMPLEX128,
  DataType::BFLOAT16,
  DataType::FLOAT8E4M3FN,
  DataType::FLOAT8E4M3FNUZ,
  DataType::FLOAT8E5M2,
  DataType::FLOAT8E5M2FNUZ,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub i32);
#[allow(non_upper_case_globals)]
impl DataType {
  pub const UNDEFINED: Self = Self(0);
  pub const FLOAT: Self = Self(1);
  pub const UINT8: Self = Self(2);
  pub const INT8: Self = Self(3);
  pub const UINT16: Self = Self(4);
  pub const INT16: Self = Self(5);
  pub const INT32: Self = Self(6);
  pub const INT64: Self = Self(7);
  pub const STRING: Self = Self(8);
  pub const BOOL: Self = Self(9);
  pub const FLOAT16: Self = Self(10);
  pub const DOUBLE: Self = Self(11);
  pub const UINT32: Self = Self(12);
  pub const UINT64: Self = Self(13);
  pub const COMPLEX64: Self = Self(14);
  pub const COMPLEX128: Self = Self(15);
  pub const BFLOAT16: Self = Self(16);
  pub const FLOAT8E4M3FN: Self = Self(17);
  pub const FLOAT8E4M3FNUZ: Self = Self(18);
  pub const FLOAT8E5M2: Self = Self(19);
  pub const FLOAT8E5M2FNUZ: Self = Self(20);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 20;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNDEFINED,
    Self::FLOAT,
    Self::UINT8,
    Self::INT8,
    Self::UINT16,
    Self::INT16,
    Self::INT32,
    Self::INT64,
    Self::STRING,
    Self::BOOL,
    Self::FLOAT16,
    Self::DOUBLE,
    Self::UINT32,
    Self::UINT64,
    Self::COMPLEX64,
    Self::COMPLEX128,
    Self::BFLOAT16,
    Self::FLOAT8E4M3FN,
    Self::FLOAT8E4M3FNUZ,
    Self::FLOAT8E5M2,
    Self::FLOAT8E5M2FNUZ,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNDEFINED => Some("UNDEFINED"),
      Self::FLOAT => Some("FLOAT"),
      Self::UINT8 => Some("UINT8"),
      Self::INT8 => Some("INT8"),
      Self::UINT16 => Some("UINT16"),
      Self::INT16 => Some("INT16"),
      Self::INT32 => Some("INT32"),
      Self::INT64 => Some("INT64"),
      Self::STRING => Some("STRING"),
      Self::BOOL => Some("BOOL"),
      Self::FLOAT16 => Some("FLOAT16"),
      Self::DOUBLE => Some("DOUBLE"),
      Self::UINT32 => Some("UINT32"),
      Self::UINT64 => Some("UINT64"),
      Self::COMPLEX64 => Some("COMPLEX64"),
      Self::COMPLEX128 => Some("COMPLEX128"),
      Self::BFLOAT16 => Some("BFLOAT16"),
      Self::FLOAT8E4M3FN => Some("FLOAT8E4M3FN"),
      Self::FLOAT8E4M3FNUZ => Some("FLOAT8E4M3FNUZ"),
      Self::FLOAT8E5M2 => Some("FLOAT8E5M2"),
      Self::FLOAT8E5M2FNUZ => Some("FLOAT8E5M2FNUZ"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataType {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_LOCATION: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_LOCATION: i32 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_LOCATION: [DataLocation; 2] = [
  DataLocation::DEFAULT,
  DataLocation::EXTERNAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataLocation(pub i32);
#[allow(non_upper_case_globals)]
impl DataLocation {
  pub const DEFAULT: Self = Self(0);
  pub const EXTERNAL: Self = Self(1);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::EXTERNAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DEFAULT => Some("DEFAULT"),
      Self::EXTERNAL => Some("EXTERNAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataLocation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataLocation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataLocation {
    type Output = DataLocation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataLocation {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataLocation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataLocation {}
pub enum SegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Segment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Segment<'a> {
  type Inner = Segment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Segment<'a> {
  pub const VT_BEGIN: flatbuffers::VOffsetT = 4;
  pub const VT_END: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Segment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SegmentArgs
  ) -> flatbuffers::WIPOffset<Segment<'bldr>> {
    let mut builder = SegmentBuilder::new(_fbb);
    builder.add_end(args.end);
    builder.add_begin(args.begin);
    builder.finish()
  }


  #[inline]
  pub fn begin(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Segment::VT_BEGIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn end(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Segment::VT_END, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Segment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("begin", Self::VT_BEGIN, false)?
     .visit_field::<i64>("end", Self::VT_END, false)?
     .finish();
    Ok(())
  }
}
pub struct SegmentArgs {
    pub begin: i64,
    pub end: i64,
}
impl<'a> Default for SegmentArgs {
  #[inline]
  fn default() -> Self {
    SegmentArgs {
      begin: 0,
      end: 0,
    }
  }
}

pub struct SegmentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SegmentBuilder<'a, 'b> {
  #[inline]
  pub fn add_begin(&mut self, begin: i64) {
    self.fbb_.push_slot::<i64>(Segment::VT_BEGIN, begin, 0);
  }
  #[inline]
  pub fn add_end(&mut self, end: i64) {
    self.fbb_.push_slot::<i64>(Segment::VT_END, end, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SegmentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Segment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Segment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Segment");
      ds.field("begin", &self.begin());
      ds.field("end", &self.end());
      ds.finish()
  }
}
}  // pub mod TensorProto_

#[allow(unused_imports, dead_code)]
pub mod tensor_shape_proto_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum DimensionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dimension<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dimension<'a> {
  type Inner = Dimension<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Dimension<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DENOTATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Dimension { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DimensionArgs<'args>
  ) -> flatbuffers::WIPOffset<Dimension<'bldr>> {
    let mut builder = DimensionBuilder::new(_fbb);
    if let Some(x) = args.denotation { builder.add_denotation(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<dimension_::Anonymous0<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<dimension_::Anonymous0>>(Dimension::VT_VALUE, None)}
  }
  #[inline]
  pub fn denotation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Dimension::VT_DENOTATION, None)}
  }
}

impl flatbuffers::Verifiable for Dimension<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<dimension_::Anonymous0>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("denotation", Self::VT_DENOTATION, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<dimension_::Anonymous0<'a>>>,
    pub denotation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimensionArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionArgs {
      value: None,
      denotation: None,
    }
  }
}

pub struct DimensionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DimensionBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<dimension_::Anonymous0<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<dimension_::Anonymous0>>(Dimension::VT_VALUE, value);
  }
  #[inline]
  pub fn add_denotation(&mut self, denotation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dimension::VT_DENOTATION, denotation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DimensionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DimensionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dimension<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Dimension<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Dimension");
      ds.field("value", &self.value());
      ds.field("denotation", &self.denotation());
      ds.finish()
  }
}
#[allow(unused_imports, dead_code)]
pub mod dimension_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum Anonymous0Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Anonymous0<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anonymous0<'a> {
  type Inner = Anonymous0<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Anonymous0<'a> {
  pub const VT_DIM_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DIM_PARAM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Anonymous0 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Anonymous0Args<'args>
  ) -> flatbuffers::WIPOffset<Anonymous0<'bldr>> {
    let mut builder = Anonymous0Builder::new(_fbb);
    builder.add_dim_value(args.dim_value);
    if let Some(x) = args.dim_param { builder.add_dim_param(x); }
    builder.finish()
  }


  #[inline]
  pub fn dim_value(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Anonymous0::VT_DIM_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dim_param(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Anonymous0::VT_DIM_PARAM, None)}
  }
}

impl flatbuffers::Verifiable for Anonymous0<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("dim_value", Self::VT_DIM_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dim_param", Self::VT_DIM_PARAM, false)?
     .finish();
    Ok(())
  }
}
pub struct Anonymous0Args<'a> {
    pub dim_value: i64,
    pub dim_param: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Anonymous0Args<'a> {
  #[inline]
  fn default() -> Self {
    Anonymous0Args {
      dim_value: 0,
      dim_param: None,
    }
  }
}

pub struct Anonymous0Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Anonymous0Builder<'a, 'b> {
  #[inline]
  pub fn add_dim_value(&mut self, dim_value: i64) {
    self.fbb_.push_slot::<i64>(Anonymous0::VT_DIM_VALUE, dim_value, 0);
  }
  #[inline]
  pub fn add_dim_param(&mut self, dim_param: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anonymous0::VT_DIM_PARAM, dim_param);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Anonymous0Builder<'a, 'b> {
    let start = _fbb.start_table();
    Anonymous0Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anonymous0<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Anonymous0<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Anonymous0");
      ds.field("dim_value", &self.dim_value());
      ds.field("dim_param", &self.dim_param());
      ds.finish()
  }
}
}  // pub mod Dimension_
}  // pub mod TensorShapeProto_

#[allow(unused_imports, dead_code)]
pub mod type_proto_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum TensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
  type Inner = Tensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tensor<'a> {
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorArgs<'args>
  ) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
    let mut builder = TensorBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_elem_type(args.elem_type);
    builder.finish()
  }


  #[inline]
  pub fn elem_type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Tensor::VT_ELEM_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<super::TensorShapeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::TensorShapeProto>>(Tensor::VT_SHAPE, None)}
  }
}

impl flatbuffers::Verifiable for Tensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("elem_type", Self::VT_ELEM_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::TensorShapeProto>>("shape", Self::VT_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorArgs<'a> {
    pub elem_type: i32,
    pub shape: Option<flatbuffers::WIPOffset<super::TensorShapeProto<'a>>>,
}
impl<'a> Default for TensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorArgs {
      elem_type: 0,
      shape: None,
    }
  }
}

pub struct TensorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: i32) {
    self.fbb_.push_slot::<i32>(Tensor::VT_ELEM_TYPE, elem_type, 0);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<super::TensorShapeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::TensorShapeProto>>(Tensor::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tensor");
      ds.field("elem_type", &self.elem_type());
      ds.field("shape", &self.shape());
      ds.finish()
  }
}
pub enum SequenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Sequence<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sequence<'a> {
  type Inner = Sequence<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Sequence<'a> {
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Sequence { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SequenceArgs<'args>
  ) -> flatbuffers::WIPOffset<Sequence<'bldr>> {
    let mut builder = SequenceBuilder::new(_fbb);
    if let Some(x) = args.elem_type { builder.add_elem_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn elem_type(&self) -> Option<super::TypeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::TypeProto>>(Sequence::VT_ELEM_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for Sequence<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::TypeProto>>("elem_type", Self::VT_ELEM_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct SequenceArgs<'a> {
    pub elem_type: Option<flatbuffers::WIPOffset<super::TypeProto<'a>>>,
}
impl<'a> Default for SequenceArgs<'a> {
  #[inline]
  fn default() -> Self {
    SequenceArgs {
      elem_type: None,
    }
  }
}

pub struct SequenceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SequenceBuilder<'a, 'b> {
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: flatbuffers::WIPOffset<super::TypeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::TypeProto>>(Sequence::VT_ELEM_TYPE, elem_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SequenceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SequenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sequence<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Sequence<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Sequence");
      ds.field("elem_type", &self.elem_type());
      ds.finish()
  }
}
pub enum MapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Map<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Map<'a> {
  type Inner = Map<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Map<'a> {
  pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Map { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MapArgs<'args>
  ) -> flatbuffers::WIPOffset<Map<'bldr>> {
    let mut builder = MapBuilder::new(_fbb);
    if let Some(x) = args.value_type { builder.add_value_type(x); }
    builder.add_key_type(args.key_type);
    builder.finish()
  }


  #[inline]
  pub fn key_type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Map::VT_KEY_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value_type(&self) -> Option<super::TypeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::TypeProto>>(Map::VT_VALUE_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for Map<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("key_type", Self::VT_KEY_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::TypeProto>>("value_type", Self::VT_VALUE_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct MapArgs<'a> {
    pub key_type: i32,
    pub value_type: Option<flatbuffers::WIPOffset<super::TypeProto<'a>>>,
}
impl<'a> Default for MapArgs<'a> {
  #[inline]
  fn default() -> Self {
    MapArgs {
      key_type: 0,
      value_type: None,
    }
  }
}

pub struct MapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MapBuilder<'a, 'b> {
  #[inline]
  pub fn add_key_type(&mut self, key_type: i32) {
    self.fbb_.push_slot::<i32>(Map::VT_KEY_TYPE, key_type, 0);
  }
  #[inline]
  pub fn add_value_type(&mut self, value_type: flatbuffers::WIPOffset<super::TypeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::TypeProto>>(Map::VT_VALUE_TYPE, value_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Map<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Map<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Map");
      ds.field("key_type", &self.key_type());
      ds.field("value_type", &self.value_type());
      ds.finish()
  }
}
pub enum OptionalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Optional<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Optional<'a> {
  type Inner = Optional<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Optional<'a> {
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Optional { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OptionalArgs<'args>
  ) -> flatbuffers::WIPOffset<Optional<'bldr>> {
    let mut builder = OptionalBuilder::new(_fbb);
    if let Some(x) = args.elem_type { builder.add_elem_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn elem_type(&self) -> Option<super::TypeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::TypeProto>>(Optional::VT_ELEM_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for Optional<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::TypeProto>>("elem_type", Self::VT_ELEM_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct OptionalArgs<'a> {
    pub elem_type: Option<flatbuffers::WIPOffset<super::TypeProto<'a>>>,
}
impl<'a> Default for OptionalArgs<'a> {
  #[inline]
  fn default() -> Self {
    OptionalArgs {
      elem_type: None,
    }
  }
}

pub struct OptionalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OptionalBuilder<'a, 'b> {
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: flatbuffers::WIPOffset<super::TypeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::TypeProto>>(Optional::VT_ELEM_TYPE, elem_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OptionalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OptionalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Optional<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Optional<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Optional");
      ds.field("elem_type", &self.elem_type());
      ds.finish()
  }
}
pub enum SparseTensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseTensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseTensor<'a> {
  type Inner = SparseTensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SparseTensor<'a> {
  pub const VT_ELEM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparseTensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SparseTensorArgs<'args>
  ) -> flatbuffers::WIPOffset<SparseTensor<'bldr>> {
    let mut builder = SparseTensorBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_elem_type(args.elem_type);
    builder.finish()
  }


  #[inline]
  pub fn elem_type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SparseTensor::VT_ELEM_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<super::TensorShapeProto<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::TensorShapeProto>>(SparseTensor::VT_SHAPE, None)}
  }
}

impl flatbuffers::Verifiable for SparseTensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("elem_type", Self::VT_ELEM_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::TensorShapeProto>>("shape", Self::VT_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct SparseTensorArgs<'a> {
    pub elem_type: i32,
    pub shape: Option<flatbuffers::WIPOffset<super::TensorShapeProto<'a>>>,
}
impl<'a> Default for SparseTensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    SparseTensorArgs {
      elem_type: 0,
      shape: None,
    }
  }
}

pub struct SparseTensorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SparseTensorBuilder<'a, 'b> {
  #[inline]
  pub fn add_elem_type(&mut self, elem_type: i32) {
    self.fbb_.push_slot::<i32>(SparseTensor::VT_ELEM_TYPE, elem_type, 0);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<super::TensorShapeProto<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::TensorShapeProto>>(SparseTensor::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SparseTensorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SparseTensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparseTensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparseTensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparseTensor");
      ds.field("elem_type", &self.elem_type());
      ds.field("shape", &self.shape());
      ds.finish()
  }
}
pub enum Anonymous1Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Anonymous1<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anonymous1<'a> {
  type Inner = Anonymous1<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Anonymous1<'a> {
  pub const VT_TENSOR_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SEQUENCE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_MAP_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_OPTIONAL_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_SPARSE_TENSOR_TYPE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Anonymous1 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Anonymous1Args<'args>
  ) -> flatbuffers::WIPOffset<Anonymous1<'bldr>> {
    let mut builder = Anonymous1Builder::new(_fbb);
    if let Some(x) = args.sparse_tensor_type { builder.add_sparse_tensor_type(x); }
    if let Some(x) = args.optional_type { builder.add_optional_type(x); }
    if let Some(x) = args.map_type { builder.add_map_type(x); }
    if let Some(x) = args.sequence_type { builder.add_sequence_type(x); }
    if let Some(x) = args.tensor_type { builder.add_tensor_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn tensor_type(&self) -> Option<Tensor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Anonymous1::VT_TENSOR_TYPE, None)}
  }
  #[inline]
  pub fn sequence_type(&self) -> Option<Sequence<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Sequence>>(Anonymous1::VT_SEQUENCE_TYPE, None)}
  }
  #[inline]
  pub fn map_type(&self) -> Option<Map<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Map>>(Anonymous1::VT_MAP_TYPE, None)}
  }
  #[inline]
  pub fn optional_type(&self) -> Option<Optional<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Optional>>(Anonymous1::VT_OPTIONAL_TYPE, None)}
  }
  #[inline]
  pub fn sparse_tensor_type(&self) -> Option<SparseTensor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SparseTensor>>(Anonymous1::VT_SPARSE_TENSOR_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for Anonymous1<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>("tensor_type", Self::VT_TENSOR_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Sequence>>("sequence_type", Self::VT_SEQUENCE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Map>>("map_type", Self::VT_MAP_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Optional>>("optional_type", Self::VT_OPTIONAL_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SparseTensor>>("sparse_tensor_type", Self::VT_SPARSE_TENSOR_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct Anonymous1Args<'a> {
    pub tensor_type: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub sequence_type: Option<flatbuffers::WIPOffset<Sequence<'a>>>,
    pub map_type: Option<flatbuffers::WIPOffset<Map<'a>>>,
    pub optional_type: Option<flatbuffers::WIPOffset<Optional<'a>>>,
    pub sparse_tensor_type: Option<flatbuffers::WIPOffset<SparseTensor<'a>>>,
}
impl<'a> Default for Anonymous1Args<'a> {
  #[inline]
  fn default() -> Self {
    Anonymous1Args {
      tensor_type: None,
      sequence_type: None,
      map_type: None,
      optional_type: None,
      sparse_tensor_type: None,
    }
  }
}

pub struct Anonymous1Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Anonymous1Builder<'a, 'b> {
  #[inline]
  pub fn add_tensor_type(&mut self, tensor_type: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Anonymous1::VT_TENSOR_TYPE, tensor_type);
  }
  #[inline]
  pub fn add_sequence_type(&mut self, sequence_type: flatbuffers::WIPOffset<Sequence<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Sequence>>(Anonymous1::VT_SEQUENCE_TYPE, sequence_type);
  }
  #[inline]
  pub fn add_map_type(&mut self, map_type: flatbuffers::WIPOffset<Map<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Map>>(Anonymous1::VT_MAP_TYPE, map_type);
  }
  #[inline]
  pub fn add_optional_type(&mut self, optional_type: flatbuffers::WIPOffset<Optional<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Optional>>(Anonymous1::VT_OPTIONAL_TYPE, optional_type);
  }
  #[inline]
  pub fn add_sparse_tensor_type(&mut self, sparse_tensor_type: flatbuffers::WIPOffset<SparseTensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SparseTensor>>(Anonymous1::VT_SPARSE_TENSOR_TYPE, sparse_tensor_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Anonymous1Builder<'a, 'b> {
    let start = _fbb.start_table();
    Anonymous1Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anonymous1<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Anonymous1<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Anonymous1");
      ds.field("tensor_type", &self.tensor_type());
      ds.field("sequence_type", &self.sequence_type());
      ds.field("map_type", &self.map_type());
      ds.field("optional_type", &self.optional_type());
      ds.field("sparse_tensor_type", &self.sparse_tensor_type());
      ds.finish()
  }
}
}  // pub mod TypeProto_
}  // pub mod onnx

